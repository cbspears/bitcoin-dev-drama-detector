{
  "source": "github",
  "repository": "bitcoin/bips",
  "fetched_at": "2026-01-15T21:49:55.003083+00:00",
  "date": "2025-09-07",
  "pull_requests": [
    {
      "number": 1958,
      "title": "BIP85: Add Codex32 as application 93'",
      "body": "This allows wallets to derive codex32 secrets and codex32 shares from BIP-0032 master keys.\r\n\r\n**Summary of changes**\r\n- Add codex32 application\r\n- Add [BIP-0093](https://github.com/bitcoin/bips/blob/master/bip-0093.mediawiki) to references\r\n- Bump version number to 1.4.0\r\n- Add 1.4.0 [reference implementation](https://github.com/benwestgate/bip85)\r\n\r\n**Rationale**\r\n\r\n- Mirrors the existing BIP-85 application for BIP-39.\r\n- Codex32 offers error correction, hand verification, identifiers, and secret sharing improvements vs BIP-39.\r\n- Deterministic generation produces auditable backups by avoiding reliance on local RNG, helping users who distrust device entropy.\r\n\r\n**Specification**\r\n\r\n- Adds **Application 93'** to BIP-0085 using derivation path:\r\n```matlab\r\nm/83696968'/93'/{header}'/{byte_len}'/{index}''\r\n```\r\n\r\n**Tests**\r\nReference tests and new vectors will be included in the reference bipsea implementation:\r\nhttps://github.com/benwestgate/bipsea/compare/master...BenWestgate:bipsea:master\r\n\r\n**Mailing List**\r\nDiscussion: https://groups.google.com/g/bitcoindev/c/--lHTAtq0Qc\r\n\r\n**Status**\r\nReady for conceptual and approach review. This change is additive and does not modify existing BIP-85 behavior.",
      "state": "open",
      "user": "BenWestgate",
      "created_at": "2025-09-07T23:40:39Z",
      "updated_at": "2025-12-29T02:58:34Z",
      "comments": 20,
      "url": "https://github.com/bitcoin/bips/pull/1958",
      "labels": [
        "Proposed BIP modification",
        "Pending acceptance"
      ],
      "comment_list": [
        {
          "user": "akarve",
          "body": "Documenting recent discussions:\r\n@BenWestgate Please see my mailing list comments to your thread with suggestions and simplifications (path, byte extraction, idx, etc.). Regarding 1.4.0 the main thing is we want to warrant full compatibility (all features) up to the prior version and (just saw you reopened [68](https://github.com/akarve/bipsea/pull/68)) a PR to the 1.3.0 client is probably the easiest way to achieve that. Lmk if anything is unclear.",
          "created_at": "2025-09-10T18:47:26Z"
        },
        {
          "user": "BenWestgate",
          "body": "> Documenting recent discussions: @BenWestgate Please see my mailing list comments to your thread with suggestions and simplifications (path, byte extraction, idx, etc.). Regarding 1.4.0 the main thing is we want to warrant full compatibility (all features) up to the prior version and (just saw you reopened [68](https://github.com/akarve/bipsea/pull/68)) a PR to the 1.3.0 client is probably the easiest way to achieve that. Lmk if anything is unclear.\r\n\r\n\r\nIt seems you'd like to consolidate some of the paths. There's a few ways to do this, if you have a favorite or one that immediately stands out as obvious let me know.\r\n\r\nI'm thinking the identifier could be the bech32 encoding of the _bip85_ index, as the purpose of incrementing the index is to get new seeds, and BIP93 says \"...the identifier **SHOULD** be distinct for all master seeds the user may need to disambiguate.\"\r\n\r\nindex = 0 -> identifier = qqqq, index = 1 -> identifier qqqp, and so on.  A particular identifier could be selected by converting it to an integer {index} once index reaches 32^4, it can fall back to the default BIP-0032 fingerprint or roll over.\r\n\r\nOn byte extraction: I agree we should draw `byte_length` bytes and pad to a multiple of 5 bits with a CRC. The polynomials `(1 << crc_len) | 3` is optimal for 1-4 bits.\n\nIf we output share indices still can use the current read one byte at a time method.",
          "created_at": "2025-09-12T15:24:41Z"
        },
        {
          "user": "scgbckbone",
          "body": "Seems to me this is well over the BIP-85 application scope. As I understand it, BIP85 generates \"a thing\" from \"a thing\". Your application is generating \"multiple things\" from \"a thing\".\r\n\r\nWhy are you generating multiple initial shares via BIP85 ? \r\n\r\nWhat I imagined BIP85 application should looks like after reading BIP93:\r\n1. way to generate secret share `s` from BIP-32 root seed (so that you can load other wallets with derived entropy). Something like this: m/83696968'/93'/{b93_index mapped to int -> `s` in this case}'/{byte_length}'/{index}'\r\n2. way to generate any non-secret share from BIP32 root seed. This, as per rationale, would allow users to generate 2nd (and only 2nd) share deterministically via BIP85, and not via RNG. All other shares should be derived according to BIP93 via interpolation. m/83696968'/93'/{b93_index mapped to int -> `not s` in this case}'/{byte_length}'/{index}'\r\n\r\n** maybe even threshold should be part of the BIP32 derivation path, BUT I think not as it has no effect to the actual secret generated (it only affects checksum)\r\n\r\n Assuming I'm not wrong in my \"specualtion\", why not just use m/83696968'/128169'/{num_bytes}'/{index}' to generate deterministic bytes from BIP-32 root seed for any share ?",
          "created_at": "2025-10-13T11:48:12Z"
        },
        {
          "user": "BenWestgate",
          "body": "Thank you for great feedback @scgbckbone. I'll explain the rationale behind your questions first.\r\n\r\n> ...BIP85 generates \"a thing\" from \"a thing\".\r\n\r\nTrue, but that thing can be structured.\r\nFor example, BIP39 derives an entire mnemonic, not one word at a time.\r\nHere, the \"thing\" is a complete codex32 backup as there's no recoverable seed without at least `{threshold}` shares.\r\n\r\n> Why are you generating multiple initial shares via BIP85 ?\r\n\r\n **Determinism.**\r\nWe want to eliminate ambiguity about which initial share indices were derived by BIP85 to make BIP85 child seed recovery easier. Example:\r\n\r\n```python3\r\nbip85 = Bip85(master_root_xprv)\r\n# 1. generate secret share \"s\" from root seed\r\nsecret1 = bip85.derive_codex32(t=3, share_idx='s')\r\n# 2. generate `k` any non-\"s\" shares from root seed, interpolate according to BIP93\r\nsecret2 = Codex32String.interpolate_at(\r\n    [\r\n      bip85.derive_codex32(k=3, share_idx='a'),\r\n      bip85.derive_codex32(k=3, share_idx='c),\r\n      bip85.derive_codex32(k=3, share_idx='d'),\r\n    ],\r\n    target=\"s\"\r\n)\r\nsecret3 = Codex32String.recover(\r\n    [\r\n        bip85.derive_codex32(k=3, share_idx='x'),\r\n        bip85.derive_codex32(k=3, share_idx='y),\r\n        bip85.derive_codex32(k=3, share_idx='z'),\r\n    ],\r\n    target=\"s\"\r\n)\r\nderived_secrets = [secret1, secret2, secret3]\r\nidentifiers = set()\r\nmaster_seeds = set()\r\nfor secret in derived_secrets:\r\n    identifiers.add(secret.identifier)\r\n    master_seeds.add(secret.data)\r\n\r\nif len(identifiers) < len(master_seeds):\r\n    raise Bip93Quote(\"Identifier SHOULD be distinct for every master seed the user may need to disambiguate\")\r\n```\r\nFor the same BIP85 root key, each `{threshold}` set of initial `{share_idx}` BIP85 derived shares recovers a _different_ secret; and the `'s'` derivation yet another. That's a **bad property**: these codex32 sets share the same header `ms13<identifier>` making them hard to disambiguate. Mismatched sets recover _wrong seeds_.\r\n\r\n> ** maybe even threshold should be part of the BIP32 derivation path, BUT I think not as it has no effect to the actual secret generated (it only affects checksum)\r\n\r\nFor secret sharing, the `{threshold}` **must** be in the derivation path.\r\nOtherwise `ms12testa...` and `ms13testa...` share entropy payloads even though they're distinct backup sets, a security vulnerability if both are used.\r\n\r\nFor unshared secrets, the threshold has no effect, so it'd be ideal to ignore it when not secret sharing. That way, knowing the BIP85 index and root key uniquely identifies the seed, regardless of threshold, consistent with other BIP85 applications.\r\n\r\n> ...why not just use m/83696968'/128169'/{num_bytes}'/{index}' to generate deterministic bytes from BIP-32 root seed for any share ?\r\n\r\nThen why not use that for BIP39 or any other application too?\r\nLet users convert deterministic bytes into mnemonics or codex32 strings as they wish.\r\nThe point of a BIP85 application is to **standardize how** that entropy is consumed into a specific deterministic format.\r\n\r\n**Based on feedback from you and @akarve**\r\n**Simplified proposal:**\r\n**Derivation:**\r\n    ```matlab\r\n    m/83696968'/93'/{header}'/{byte_length}'/{index}'\r\n    ```\r\n   - where `{header}` is an int encoding of `<hrp>`, `<hrp>1<k>`, or `<hrp>1<k><identifier>` (TBD).\r\n\r\n**Simplifications:**\r\n  - `{share_idx}` and `{num_shares}` can be eliminated\r\n  - `{identifier}` can be implicit, but if user-defined, `{index}` should feed into it to keep output identifiers distinct per master seed\r\n  - \"Existing master seed\" derivation rule is removed, we only generate fresh seeds.\r\n    - Users can discard an initial share and interpolate if they have an existing master seed they wish to share.\r\n  - BIP93 interpolation and relabeling identifiers left to users.\r\n  - Default identifier = BIP32 fingerprint of derived seed.\r\n\r\n**Example of the simplified form**:\r\n\r\n```python3\r\nbip85 = Bip85(master_root_xprv)\r\n# 1. generate k=0 secret share \"s\" from root seed\r\nsecret1 = bip85.derive_codex32(k=0)\r\n# 2. generate `k` fixed non-\"s\" shares from root seed, interpolate according to BIP93\r\nshares = bip85.derive_codex32(k=2)\r\nsecret2 = Codex32String.interpolate_at(shares, target=\"s\")\r\nshares = bip85.derive_codex32(k=3)\r\nsecret3 = Codex32String.interpolate_at(shares, target=\"s\")\r\nderived_secrets = [secret1, secret2, secret3]\r\nidentifiers = set()\r\nmaster_seeds = set()\r\nfor secret in derived_secrets:\r\n    identifiers.add(secret.identifier)\r\n    master_seeds.add(secret.data)\r\n\r\nassert len(identifiers) == len(master_seeds)\r\n# header is distinct for each master seed the user may need to disambiguate\r\n\r\nassert len(master_seeds) == 1\r\n# same master seed for same {index}, regardless of k\r\n```\r\n\r\n> Seems over the BIP-85 scope.\r\n\r\nThe version brings it back within scope:\r\n- `k=0`: derive 1 codex32 secret.\r\n- `k=2`: derive 2 codex32 shares ('a' and 'c') → recover same secret.\r\n- `k=3`: generate 3 codex32 shares ('a',  'c' and, 'd') → recover same secret.\r\nIdentifier defaults to derived seed’s BIP32 fingerprint.\r\nIncrementing {index} yields new seeds, with new identifiers automatically.",
          "created_at": "2025-10-19T17:11:30Z"
        },
        {
          "user": "scgbckbone",
          "body": "> Then why not use that for BIP39 or any other application too?\r\nLet users convert deterministic bytes into mnemonics or codex32 strings as they wish.\r\nThe point of a BIP85 application is to standardize how that entropy is consumed into a specific deterministic format.\r\n\r\nagreed, rest my case here...\r\n\r\n> For example, BIP39 derives an entire mnemonic, not one word at a time.\r\n\r\nthis is bad comparison, as 12/24 words represent encoding of 16/32 bytes of entropy. While your approach creates multiple shares. Same as if I would create multiple 12 words seeds from 16 bytes of entropy.\r\n\r\nthis is imo ok (using code from your snippets whithout ever running it or reviewing it). My understanding is that each line in below snippet, generates just one share?\r\n```\r\nsecret_share = bip85.derive_codex32(t=3, share_idx='s')\r\nshare_a = bip85.derive_codex32(t=3, share_idx='a'),\r\nshare_c = bip85.derive_codex32(t=3, share_idx='c'),\r\nshare_d = bip85.derive_codex32(t=3, share_idx='d'),\r\n```\r\n\r\nwith what I have issue is this, where you just generating multiple shares (somehow):\r\n```\r\n# 2. generate `k` fixed non-\"s\" shares from root seed, interpolate according to BIP93\r\nshares = bip85.derive_codex32(k=2)\r\n```\r\n\r\n> The version brings it back within scope:\r\n\r\nonly `k=0` is within the scope (imho)\r\n\r\nDon't get me wrong, I'm not intending to block this BIP update. Updated version is much better. I'm only trying to figure out why is this needed & whether there is any advantage in what you're doing vs. what I'm doing. Here is my pseudo-code, to try to prove the point that nothing else than simple \"one share generation\" is needed here & rest can be left to BIP-93 interpolation:\r\n\r\n```\r\nCHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\r\nsecret_share = <32 bytes secret loaded in HWW>\r\nid = \"cash\"\r\nthreshold = 3\r\nnum_shares = 4\r\n# use BIP85 to deterministically generate secret share \"L\" (or any other, up to specific wallet implementation)\r\nshare_l = bip85(secret_share).derive_codex32(t=threshold, id=id, share_idx='l')\r\nshares = [sahre_l]\r\nfor i in range(num_shares - 1):  # -1 as share 'a' was already generated\r\n    shares.append(bip93.interpolate([secret_share, share_l], CHARSET[i]))   \r\n```\r\n\r\nAbove pseudo-code always generate the same shares.\r\n",
          "created_at": "2025-10-27T01:53:14Z"
        },
        {
          "user": "BenWestgate",
          "body": "> While your approach creates multiple shares. Same as if I would create multiple 12 words seeds from 16 bytes of entropy.\r\n\r\nI would not say these are quite the same. Both the initial k shares and 12 word seeds need entropy to create but a set of k shares _does_ represent a _single_ seed. `< k` can **not** recover a seed or define a specific backup set of shares. All other bip85 applications recover a _specific secret_ at each bip85 index so that it can be recovered later. If the app generates \"loose\" shares, this is not possible, bip85 does not know which initial shares generated, if at all, a master seed. And were that desired, users can discard some output. \r\n\r\n> only `k=0` is within scope (imho)\r\n\r\nThis can't generate shares because {share_idx} must be \"S\" for `k=0`. Of course, I like the simplicity of this small scope but it leaves users and wallets tasked with generating the randomness needed to securely secret share that BIP85 derived codex32 secret.\r\n\r\nIf the purpose of BIP85 is deterministic randomness from bip32 keychains, why suddenly stop short of providing the additional randomness needed to do SSS for an SSS-aware format?\r\n\r\nPath: ```m/83696968'/93'/{hrp}'/{byte_length}'/{index}'```\r\nWe could drop the bip93 interpolation and directly encode threshold strings at _fixed_ indices, using default bip32 fingerprint identifier.  BIP85 app output would be:\r\n`k=0`: a codex32 secret.\r\n`k=2`: same codex32 secret and share \"A\".\r\n`k=3`: same codex32 secret, a new share \"A\", and share \"C\".\r\n`k=4`: same codex32 secret, new shares \"A\" and \"C\", and share \"D\".\r\netc...\r\n\r\nNow each {bip85 index} derives a single seed as with bip39 but we also give deterministic entropy for secret sharing. Leaving wallets to interpolate any remaining shares.\r\n\r\n> My understanding is that each line in below snippet, generates just one share?\r\n\r\nYes, it was an example of part 2 of your proposal:\r\n\r\n>    2. way to generate **any** non-secret share from BIP32 root seed. This ... would allow users to generate share[s] deterministically via BIP85, and not via RNG.\r\n\r\nThe disadvantages I saw with it for the same {bip85 index}:\r\n\r\n1. Different arbitrary {share_idx} combinations of bip85 derived shares recover different seeds, which is unexpected bip85 behavior and less interoperable.\r\n   - Solution: fix the indices, only output:\r\n     1. \"S\", [\"A\", \"C\"] or, [\"A\", \"C\", \"D\"] for `k=0`, `k=2` and `k=3` respectively.  Or\r\n     1. \"S\", [\"S\", \"A\"] or, [\"S\", \"A\", \"C\"], etc\r\n   - Whichever is preferred, a is more usable by humans. Avoids mistakenly writing the secret. b avoids our bip85 app needing interpolation logic as it outputs direct entropy encodings.\r\n1. Different thresholds recover different seeds.\r\n   - Fix: Remove k from the derivation path and always encode seed as the first {bytes_length} from the DRNG\r\n     - Or use HMAC(derived_entropy, identifier) and truncate.\r\n1. {threshold} doesn't affect share payloads so they might be reused across backups.\r\n    - Seeds may be \"reshared\" but shares should be fresh.\r\n    - e.g. a 2-of-n and 3-of-n and accidentally use the same {bip85 index} then both backups have the same share 'A' payload. \r\n    - Fix: After generating the seed, reseed the DRNG with HMAC(derived_entropy, k) and then derive `k - 1` independent share payloads with {bytes_length} reads from the DRNG.\r\n      - Could also reseed with HMAC(derived_entropy, k + identifier) which would support resharing an existing master seed at the same threshold with a unique identifier.\r\n      - Or use HMAC(derived_entropy, k + identifier + share_idx) directly and truncate for each share payload.\r\n\r\n> I'm only trying to figure out why is this needed...\r\n\r\nTo support deterministic generation of **_initial strings_** for users/wallets intending to do SSS, we should output a threshold quantity of strings to avoid these 3 interoperability and recovery problems.\r\n\r\nHowever this isn't necessary for a minimum viable PR, as `k=0` is useful on its own. And I can break this into two PRs one for codex32 secrets and another for `k >= 2` which output a codex32 secret and `k-1` codex32 shares.\r\n\r\nHow should I proceed?",
          "created_at": "2025-10-28T13:29:15Z"
        },
        {
          "user": "jonatack",
          "body": "@akarve thoughts here? (thanks!)",
          "created_at": "2025-11-04T21:11:16Z"
        },
        {
          "user": "akarve",
          "body": "Yeah. Not to slow down the innovation here (and in @3rdIteration 's PRs) but my thinking is for me take on implementing both applications in the current reference implementation as Python protocols. My belief is that if we can come up with a standard duck typing interface for all BIP-85 applications that this—as yet non-existent—abstraction will stand the test of time. Of course anyone else in this thread is free to propose the shape of the protocol **and even implement it without me**. My experience is that we will need full unit tests and such for the protocol to be hard enough to stand the test of time. I'm volunteering to complete said protocol + implementation this quarter **but if anyone wants to go first down this path they're welcome**. \r\n\r\nProtocol designs can go in this thread. The ultimate goal is we have a standard protocol/interface for BIP-85 applications and a standard \"graph\" that they all go through and boom out come the entropy products. In this way all applications use the same protocol and same core logic. This would benefit current and future applications as well as benefit PR-clearing speed (after the initial investment) once the protocol is in place. Said protocol will also resolve the \"one-product/two-product\" style debates happening in this PR because the quacking of the duck types will resolve such points as how many things turn into how many other things. I hope that makes sense.",
          "created_at": "2025-11-04T21:31:06Z"
        },
        {
          "user": "BenWestgate",
          "body": "> Protocol designs can go in this thread.\r\n\r\nEach app should define a function to take parameters and derived entropy, truncate as needed (or seed a DNRG) and format it.\r\n\r\n>Each application SHOULD use up to the required number of bits necessary for their operation, and truncate the rest. \r\n\r\n```python\r\ndef entropy_to_output(entropy, parameters):\r\n    # Logic to produce output based on provided entropy and parameters\r\n    return formatted_output\r\n```\r\nDerivation paths have a semantic application number, end with an `/{index}'` to produce unique secrets. If there is a length quantity for the output that **SHOULD** precede `{index}` in the derivation path.\r\n\r\nMany applications also need to define a function to generate the BIP85 derivation path based on their parameters.\r\n\r\n```python\r\ndef parameters_to_path(parameters, index):\r\n    # Logic to produce the BIP85 derivation path\r\n    return bip85_derivation_path\r\n```\r\n\r\nI updated this PR to generate single codex32 strings per BIP85 `{index}`.",
          "created_at": "2025-11-06T02:04:07Z"
        },
        {
          "user": "BenWestgate",
          "body": "> What I imagined BIP85 application should looks like after reading BIP93:\r\n> \r\n>     1. way to generate secret share `s` from BIP-32 root seed (so that you can load other wallets with derived entropy). Something like this: m/83696968'/93'/{b93_index mapped to int -> `s` in this case}'/{byte_length}'/{index}'\r\n> \r\n>     2. way to generate any non-secret share from BIP32 root seed. This, as per rationale, would allow users to generate 2nd (and only 2nd) share deterministically via BIP85, and not via RNG. All other shares should be derived according to BIP93 via interpolation. m/83696968'/93'/{b93_index mapped to int -> `not s` in this case}'/{byte_length}'/{index}'\r\n> \r\n> \r\n> ** maybe even threshold should be part of the BIP32 derivation path, BUT I think not as it has no effect to the actual secret generated (it only affects checksum)\r\n\r\nAfter Heavy thinking, I concur the best solution is to generate single codex32 strings in a manner very similar to what @scgbckbone proposed.\r\n\r\nI have rewritten the BIP text to match this design, it is a fraction of the original's length so that's another win.\r\n\r\nI look forward to updated feedback and will be re-writing the reference implementation in the coming weeks.\r\n\r\nThe use-case that sold me on single share outputs was:\r\n\r\n> I have two trusted friends Alice and Bob. I want a master seed neither friend knows (unless they collude) that I can recover by asking Alice and Bob for derived shares. So Alice derives my threshold=2 share A with identifier \"help\", and Bob derives my threshold=2 share C with identifier \"help\" and I can recover the secret MS12HELPS..., and derive other shares such as \"M\", \"Y\", etc that will allow me to recover my seed without Alice or Bob. But even if I lose every share, I can still recover in the same manner as my seed was created.\r\n\r\nBy limiting the shares to the first threshold indicies and including the identifier in share entropy derivation, it avoids the issue of there being multiple seeds recoverable at a given threshold and identifier, at least from a single bip85 root key.",
          "created_at": "2025-11-11T23:08:49Z"
        },
        {
          "user": "BenWestgate",
          "body": "Quoting BIP93: *For a fresh master seed*  to justify my answers:\r\n\r\n> ...the user generates random initial shares, as follows:\r\n> \r\n> * Choose a bitsize, between 128 and 512, which must be a multiple of 8.\r\n> * Choose a threshold value _k_ between 2 and 9, inclusive\r\n> * Choose a 4 bech32 character identifier\r\n>   * We do not define how to choose the identifier, beyond noting that it SHOULD be distinct for every master seed the user may need to disambiguate.\r\n> * _k_ many times, generate a random share by:\r\n>   * Take the next available letter from the bech32 alphabet, in alphabetical order, as <code>a</code>, <code>c</code>, <code>d</code>, ..., to be the share index\r\n> * Set the first nine characters to be the prefix <code>ms1</code>, the threshold value _k_, the 4-character identifier, and then the share index\r\n> * ...\r\n\r\n> what are CANONICAL_INDICES ?\r\n\r\nI renamed that constant to:\r\n`IDX_ORDER = \"sacdefghjklmnpqrtuvwxyz023456789\"  # Canonical BIP93 share indices alphabetical order`\r\n\r\nIt is the secret index \"s\" followed by the 31 share indices (excluding 's') alphabetically sorted. Prepending \"s\" makes `IDX_ORDER.index(\"s\") == 0`, simplifying checks for the unshared secret index.\r\n\r\n> it seems that you limit maximum number of shares to 10 by using them ?\r\n\r\nBIP93 prescribes using the first _k_ alphabetical share indices for \"random initial shares\" (our bip85 entropy application).\r\n_k_ has max value 9. Including unshared secrets which use `share_idx = \"s\"`, leaves 10 valid.\r\n\r\nBIP85 deriving share indices beyond this initial _k_ makes recovery ambiguous where knowing the common share header of a backup (`hrp`, `threshold`, `identifier`), root key and bip85 index is no longer sufficient to recover a unique secret and **violates both** specs.\r\n\r\nExample:\r\nFor `bip85_index = 0`, prefix `ms12cash`, the initial shares bip85 derived with `share_idx = \"a\"` and `share_idx = \"c\"` would bip93 recover a _different secret_ with prefix `ms12cashs` than initial shares with `share_idx = \"y\"` and `share_idx = \"z\"` recover.\r\n\r\nBreaking BIP85's {index} customary rule: \r\n> The BIP85 index is a number used to derive unique child secrets from a root key. Each index generates **one** unique secret, allowing for up to 2^31 secrets based on the same root key.\r\n\r\nAnd BIP93's identifier rule:\r\n> ...[identifier] SHOULD be distinct for every master seed...\r\n\r\nIf `share_idx == \"s\"`, then _k_ MUST be `0` for the same reason. At the same child index and identifier, this presents two secrets: the directly bip85 derived unshared secret at `threshold = k, share_idx = \"s\"` and the recovered secret when _k_ `threshold = k` shares are first bip85 derived then bip93 interpolated to \"s\".\r\n\r\nThe additional 31-_k_ shares beyond the first _k_ may be derived using BIP93 interpolation, which is outside spec as it needs no fresh randomness. Outputting interpolated shares would be like our XPRV application producing an extended private key encoding of HMAC-SHA512(\"Bitcoin seed\", S) where S is the payload of our WIF application.  We don't do that, we always generate fresh randomness or nothing at all. And I've proven the problem with generating fresh randomness for shares beyond the first _k_ alphabetical indices.\r\n\r\n> What do you think about below derivation path calculation\r\n\r\nMy first thought was \"OH, that's good!\", I like this derivation path, provided we add the `share_idx` restrictions above.\r\n\r\nHowever, _Are you sure_ you want to eliminate the bip85 {index}?\r\n\r\nAll deployed BIP85 applications use this derivation path feature and the reference implementation expects one:\r\n> As with all applications, you can change the child index from it's default of zero to get a fresh, repeatable secret.\r\n\r\n> index, 0 to 2³¹ - 1 for millions of unique passwords\r\n\r\n> `def derive_cli(application, number, index, special, xprv, to):`\r\n\r\n> ```python\r\n> @click.option(\r\n>     \"-i\",\r\n>     \"--index\",\r\n>     type=click.IntRange(0, 2**31 - 1),\r\n>     default=0,\r\n>     help=\"Child index. Increment for fresh secrets.\",\r\n> ```\r\n\r\nIt's recommended headers be distinct for unique seeds, but not required as with no {child index} derivation.\r\n\r\n> why? imo this should be left out from this spec and left to specific implementations to decide\r\n\r\nIdentifier needs an assignment to encode the string so it may as well be the most useful deterministic data.\r\nThe codex32 authors like this as as a default for \"electronic implementations\" (which bip85 is):\r\nhttps://github.com/BlockstreamResearch/codex32/issues/54#issuecomment-1650573709\r\n\r\nIf the user can specify and we keep a child {index}, we break the \"SHOULD be distinct for every seed\" rule. I resorted to the fingerprint default based on an assumption bip85 applications **MUST** have a child index for \"millions of unique\" \"fresh secrets\" as per quotes above.\r\n\r\nI dislike the least significant bits of {index}' being `share_idx` as when I think of the phrase \"Child index. Increment for fresh secrets\" that's not happening if say, `share_idx = \"s\"` changes to `\"3\"` and my secret output becomes a share output. If it must go in the last child index derivation level, I prefer `share_idx` and _k_ as the most significant bits in the {index} serialization.\r\n\r\nRetaining child index and using a default fingerprint identifier for unshared secrets makes them most like other bip85 apps. It's not required though, we could derive unshared secrets like shares by serializing the identifier into the child index, subject to the restriction _k_ must be 0 if `share_idx = s`.\r\n\r\nThis version always requires the specifying the identifier even for secrets:\r\n```python3\r\nIDX_ORDER = \"sacdefghjk\"\r\nVALID_HRP = {\r\n    \"ms\": 0,\r\n    \"cl\": 1\r\n}\r\n\r\ndef bip93_parameters_to_path(hrp, threshold=0, identifier=\"\", share_idx, byte_len, index=0):\r\n    if threshold and share_idx not in IDX_ORDER[1:threshold+1]:\r\n        raise InvalidShareIndex()\r\n    if not identifier:\r\n        raise MissingIdentifier()\r\n    if index > 31:\r\n        raise ValueError(\"maximum index 31 allowed for codex32 strings\")\r\n    index = (\r\n                        + threshold * 2 // 2 + IDX_ORDER.index(share_idx) << 25\r\n                        + index << 20\r\n                        + int.from_bytes(bech32_decode(identifier), 'big')\r\n                      )\r\n    return f\"m/83696968'/93'/{VALID_HRP[hrp]}'/{byte_len}'/{index}'\"\r\n```\r\n\r\nThis allows 32 child index values which combined with a million+ identifiers meets the existing \"millions\" spec. Incrementing this level changes the identifier as expected by BIP93 for a unique secret.\r\n\r\nI still prefer combining `hrp`, `k` and `share_idx` in the first derivation level, and using the BIP32 fingerprint identifier for `share_idx = \"s\"` so we have all `2**31 - 1` child indices for fresh secrets and only codex32 shares break the established pattern (by being restricted to 2 ^ 11 - 1 child indices, as 20-bits are allocated for the required identifier).\r\n```python3\r\ndef bip93_parameters_to_path(hrp, k=0, identifier=\"\", share_idx, byte_len, index=0):\r\n    if share_idx not in IDX_ORDER[min(1, k) : k + 1]:\r\n        raise InvalidShareIndex()\r\n    header_path_int = VALID_HRP[hrp] * 100 + k * 10 + IDX_ORDER.index(share_idx)\r\n    if share_idx != \"s\":\r\n        if not identifier:\r\n            raise MissingIdentifier()\r\n        if index > 2**11 - 1:\r\n            raise ValueError(\"maximum index 2047 allowed for codex32 shares\")\r\n        index = index << 20 + from_bytes(bech32_decode(identifier), 'big')\r\n    return f\"m/83696968'/93'/{header_path_int}'/{byte_len}'/{index}'\"\r\n```\r\n\r\nWhat do you think?",
          "created_at": "2025-11-22T23:00:43Z"
        },
        {
          "user": "scgbckbone",
          "body": "> BIP93 prescribes using the first k alphabetical share indices for \"random initial shares\" (our bip85 entropy application)\r\n\r\ncompletely missed that one, thanks for the reminder + examples\r\n\r\n> However, Are you sure you want to eliminate the bip85 {index}?\r\n\r\nno, I'm not. Completely unsure about it tbh. I've got second thought while writing it & even more after I published. Now I think we should just have a proper index ((2**31) -1) at the end.\r\n\r\n> Identifier needs an assignment to encode the string so it may as well be the most useful deterministic data.\r\nThe codex32 authors like this as as a default for \"electronic implementations\" (which bip85 is):\r\n\r\nI like the idea of using master pubkey fingerprint, but is it even possible for bech32 charset where we do not have number `1`? (it can only be used as HRP separator in codex32 BIP)\r\n\r\n> f\"m/83696968'/93'/{header_int}'/{byte_len}'/{index}'\"\r\n* like this path (imo we should not use more than 5 derivation steps)\r\n* as I said, I'm now more inclined to use proper BIP85 index (2**31-1) without any more data encoded in it (but unsure)\r\n* that leaves us with the need to encode all the res to the header byte, which would not scale as we would (in my case) only have 2 more bits for HRP (good for now but broken in case more HRPs gonna be added).\r\n\r\nI your encoding two-way? can you get back to header used from int ? ",
          "created_at": "2025-11-23T12:10:58Z"
        },
        {
          "user": "BenWestgate",
          "body": "> Now I think we should just have a proper index ((2**31) -1) at the end.\r\n\r\nWe have index 0 through 2**32-1 for secrets (_k_= 0, `share_idx = \"s\"`) if `id = fingerprint()` or if `id` (identifier -> int) is packed in the first derivation level with `hrp`, `k` and `share_idx`.\r\n\r\nIn codex32 and bip85, `id` and child index mean the same thing: \"unique\" outputs. So in various iterations, I've either set the child index `index = id`, or serialized them together `index = index << 20 | id` since one has 31 bits and the other 20.  From a UX perspective it's better to choose 4 bech32 characters and decode it into the child index than to chose an integer child index that produces the desired 4 character identifier.\r\n\r\nFor identifier collision resistance, `index = id` is best, followed by `index = index << 20 | id`  as the first 2^20 child indexes all have unique identifiers before it rolls over. While the fingerprint likely begins to collide (birthday problem) after ~2^10 child indexes used. But the master pubkey fingerprint is far more _useful_ for identifying what the secret is for and harder to accidentally reuse on different child secrets. That practical benefit seems to outweigh the risk of identifier reuse in the first 2**20 child indices.\r\n\r\nSince only `hrp = \"ms\"` secrets represent a BIP-0032 master seed with an associated master key pair and master pubkey fingerprint perhaps we drop the fingerprint default?  Or (my preference) use it only in the `ms10` case?\r\n\r\n> Key identifiers\r\n> \r\n> Extended keys can be identified by the Hash160 of the public key, ignoring the chain code. This corresponds exactly to the data used in traditional Bitcoin addresses.\r\n> \r\n> The first 32 bits of the identifier are called the key fingerprint.\r\n\r\n`hrp = \"cl\"` secrets are a 32-byte private key so they technically don't have a key fingerprint, and at any rate this means custom per `hrp` identifier derivation logic.\r\n\r\n> I like the idea of using master pubkey fingerprint, but is it even possible for bech32 charset where we do not have number `1`? \r\n\r\nWe can bech32-encode the 20-MSB of master pubkey fingerprint into the 4-character identifier instead of 16-bits if we mapped hex characters, which we can't since `b, 1` are missing. It's easy to convert it to hex without electronics using the BIP-0173 table.\r\n \r\n> > f\"m/83696968'/93'/{header_int}'/{byte_len}'/{index}'\"\r\n> \r\n> like this path (imo we should not use more than 5 derivation steps)\r\n\r\nAgreed, this simplifies implementations assumptions about path lengths.\r\n \r\n> that leaves us with the need to encode all the res to the header byte, which would not scale...\r\n\r\nThere are 45 `k` and `share_idx` combos so they consume 6-bits (compressed) and `id` 20-bits, leaving 2^5 `hrp` codes, 30 remaining, a narrow margin. BIP-0173 has 288 registered prefixes but codex32 will never have as many since it is for private, not public data.\r\n \r\n> as I said, I'm now more inclined to use proper BIP85 index (2**31-1) without any more data encoded in it (but unsure)\r\n\r\nHere is an example path encoding that uses the 20-LSB of the identifier parameter as the 20-LSB of the child index derivation level, and left-shifts any optional \"index\" parameter 20-bits to not mangle the identifier part.\r\n\r\n> I your encoding two-way? can you get back to header used from int ?\r\n\r\nYes.\r\n\r\n```python3\r\nCHARSET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\r\nIDX_ORDER = sorted(CHARSET, key=lambda c: (c != 's', c.isdigit(), c))  # \"s\" then alphabetical order\r\nVALID_HRP = [\"ms\", \"cl\"]\r\n\r\ndef bip93_parameters_to_path(hrp, k, share_idx, byte_len, ident=\"\", index=0):\r\n    if k == 1 or not (0 <= k <= 9):\r\n        raise ValueError(\"Invalid threshold parameter\")\r\n    if share_idx not in IDX_ORDER[min(1, k) : k + 1]:\r\n        raise ValueError(\"Invalid share index\")\r\n    if len(ident) != 4:\r\n        raise ValueError(\"Missing unique 4-character bech32 identifier\")\r\n    if index > 2**11 - 1:\r\n        raise ValueError(\"maximum index 2047 allowed for codex32 shares\")\r\n    \r\n    header_path_int = VALID_HRP.index(hrp) * 100 + k * 10 + IDX_ORDER.index(share_idx)\r\n    for char in ident:\r\n        index = index << 5 | CHARSET.find(char)\r\n\r\n    return f\"m/83696968'/93'/{header_path_int}'/{byte_len}'/{index}'\"\r\n\r\n\r\ndef bip93_path_to_parameters(path=''):\r\n    header_int, byte_len, index = [int(segment[:-1]) for segment in path.split(\"/\")[3:]]\r\n    hrp = VALID_HRP[header_int // 100]\r\n    k = header_int // 10 % 10\r\n    share_idx = IDX_ORDER[header_int % 10]\r\n    ident = \"\".join([CHARSET[(index >> s) & 31] for s in (15, 10, 5, 0)])\r\n\r\n    return hrp, k, share_idx, byte_len, ident, index >> 20\r\n\r\n\r\n```\r\n\r\nI left out the custom rule for `hrp=\"ms\"` and `k=0` which would have defaulted the identifier to fingerprint for simplicity.\r\n\r\nHere are some test vectors:\r\n```python3\r\n\r\nassert bip93_path_to_parameters(\"m/83696968'/93'/0'/16'/0'\") == ('ms', 0, 's', 16, 'qqqq', 0)\r\nassert bip93_path_to_parameters(\"m/83696968'/93'/199'/32'/999999999'\") == ('cl', 9, 'k', 32, '4j0l', 953)\r\nassert bip93_path_to_parameters(\"m/83696968'/93'/199'/64'/2147483647'\") == ('cl', 9, 'k', 64, 'llll', 2047)\r\n\r\nassert bip93_parameters_to_path(\"ms\", 0, \"s\", 16, 'test', 0) == \"m/83696968'/93'/0'/16'/386571'\"\r\nassert bip93_parameters_to_path(\"ms\", 3, \"a\", 16, 'cash', 0) == \"m/83696968'/93'/31'/16'/816663'\"\r\nassert bip93_parameters_to_path(\"ms\", 3, \"c\", 16, 'cash', 0) == \"m/83696968'/93'/32'/16'/816663'\"\r\n\r\nassert bip93_parameters_to_path(\"ms\", 2, \"a\", 16, 'qqqq', 0) == \"m/83696968'/93'/21'/16'/0'\"\r\nassert bip93_parameters_to_path(\"ms\", 2, \"c\", 32, 'qqqp', 0) == \"m/83696968'/93'/22'/32'/1'\"\r\nassert bip93_parameters_to_path(\"ms\", 3, \"a\", 16, 'llll', 0) == \"m/83696968'/93'/31'/16'/1048575'\"\r\nassert bip93_parameters_to_path(\"ms\", 3, \"c\", 64, 'qqqq', 1) == \"m/83696968'/93'/32'/64'/1048576'\"\r\nassert bip93_parameters_to_path(\"ms\", 3, \"d\", 16, 'qqqp', 1) == \"m/83696968'/93'/33'/16'/1048577'\"\r\n\r\n```\r\nThis `header_path_int` encoding is very human-readable as 100s place is the hrp value, 10s is `k` and 1s the alphabetical order share index. The last index digit must be <= the `k` digit to be valid (our limitation discussed last week on valid share indexes to derive).\r\n\r\nIf we cram identifier into `header_int` as suggested: we lose this decimal readability AND 20-bits of hrp codes. So I am convinced the identifier needs to set the child index derivation level or, less preferably, be set by the child index value.\r\nEspecially given they have a purpose in common: a public _label_ for a _unique secret_.\r\n\r\n> Both BIP85 child indices and the codex32 identifier aim to disambiguate or label derived/encoded secrets so you can tell one master seed apart from another.\r\n\r\nThey're not the same thing but they're close enough we should handle them together for derivation purposes.",
          "created_at": "2025-11-24T19:54:43Z"
        },
        {
          "user": "scgbckbone",
          "body": "> Since only hrp = \"ms\" secrets represent a BIP-0032 master seed with an associated master key pair and master pubkey fingerprint perhaps we drop the fingerprint default? Or (my preference) use it only in the ms10 case?\r\n\r\nI'm planning to extende the BIP(s) with new HRP, that will encode chaincode+privkey (64bytes) for compatibility with BIP-39. I will use master fingerprint 20 MSB for it in my application as default. Users will have ability to change to custom ID. So up to you.\r\n\r\nHere is my xfp to codex32 id converter:\r\n```python\r\nc = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\"\r\n\r\ndef xfp_to_codex32_id(xfp):\r\n     x = (int(xfp, 16) >> 12) & 0xFFFFF  # Extract exactly 20 MSB\r\n     return c[(x >> 15) & 31] + c[(x >> 10) & 31] + c[(x >> 5) & 31] + c[x & 31]\r\n```\r\n\r\nok, I'm sold. You definitely put much more thought into this than I did. Thanks for lengthy & helpful explanations!\r\n\r\nConcept ACK",
          "created_at": "2025-11-26T13:22:31Z"
        },
        {
          "user": "BenWestgate",
          "body": "> I'm planning to extend the BIP(s) with new HRP, that will encode chaincode+privkey (64bytes) for compatibility with BIP-39. I will use master fingerprint 20 MSB for it in my application as default. Users will have ability to change to custom ID. So up to you.\r\n\r\nLets say that specific application prefixes may further restrict the valid byte length(s) and set a default identifier on output secrets.\r\n\r\nYour design should probably use the 20-MSB of the master key fingerprint as the identifier on master xprvs and master xpubs.  That has the awesome property of keeping the same default identifier as the master seed that derives them:\r\n\r\nmaster seed (hex): `deadbeefdeadbeef...`\r\nmaster key fingerprint (hex): `00000000`\r\ncodex32-encoded master seed (bech): `ms10qqqqs...`\r\ncodex32-encoded master extended private key (bech): `xprv10qqqqs...`\r\ncodex32-encoded master extended public key (bech): `xpub1qqqqs`\r\n\r\nTo support this though we must go with the original \"s\" secret design that does NOT incorporate the ID into the derivation.  As you need to know the derived private key to compute the fingerprint ID.\r\n\r\nThat way we can derive and label strings for your application properly.\r\n\r\nShares however still must incorporate the identifier in derivation.\r\n\r\nWe also need to relax the byte_length restriction in this PR to 1-626.\r\n\r\nI'm writing a PR to BIP93 to generalize it for any HRP, which is for precisely for applications like yours, so please review it if you have time:\r\n\r\nhttps://github.com/bitcoin/bips/pull/2040",
          "created_at": "2025-11-26T23:01:37Z"
        },
        {
          "user": "scgbckbone",
          "body": "> Your design should probably use the 20-MSB of the master key fingerprint as the identifier on master xprvs and master xpubs. That has the awesome property of keeping the same default identifier as the master seed that derives them:\r\n\r\n> To support this though we must go with the original \"s\" secret design that does NOT incorporate the ID into the derivation. As you need to know the derived private key to compute the fingerprint ID.\r\n\r\nI doubt anyone will start using bech32 encoded extended keys, at least I do not plan to, even tho better readability than base58, that standard is set in stone at this point. If you consider it useful, I do not mind if you optimize this BIP-85 app for it.",
          "created_at": "2025-11-27T15:14:10Z"
        },
        {
          "user": "BenWestgate",
          "body": "> I doubt anyone will start using bech32 encoded extended keys, at least I do not plan to, even tho better readability than base58, that standard is set in stone at this point. If you consider it useful, I do not mind if you optimize this BIP-85 app for it.\n\nThey should be upgraded, the same argument could be made for base58 addresses and BIP39.\nMy comments on the other PR may have been based on misunderstanding of the intent.\n\nWhen I see storing the chain code and private key, I am thinking you're encoding an extended key (you are) so that seems most useful to go all the way.\n\nAndrew already has an informal standard for storing BIP39 words in codex32 so we don't need to store the hdseed or extended key.\n",
          "created_at": "2025-11-27T17:49:30Z"
        },
        {
          "user": "scgbckbone",
          "body": "> When I see storing the chain code and private key, I am thinking you're encoding an extended key (you are) so that seems most useful to go all the way.\r\n\r\nyou're probably right that it make sense to attempt it all the way to proper extended key encoding, but no I wasn't treating it as such, I was just storing secret that consist from chaincode + privkey from which naked/root (without meta) extended private key can be re-assembled\r\n\r\n> Andrew already has an informal standard for storing BIP39 words in codex32 so we don't need to store the hdseed or extended key.\r\n\r\ndo you have link ?",
          "created_at": "2025-11-27T17:58:00Z"
        },
        {
          "user": "BenWestgate",
          "body": "> > Andrew already has an informal standard for storing BIP39 words in codex32 so we don't need to store the hdseed or extended key.\r\n> \r\n> do you have link ?\r\n\r\nhttps://github.com/BlockstreamResearch/codex32/issues/60\r\nhttps://github.com/bitcoin/bips/pull/2040#discussion_r2566747046\r\n\r\nHe suggested standardizing it on the SLIPs repository.",
          "created_at": "2025-11-27T19:01:00Z"
        },
        {
          "user": "akarve",
          "body": "@BenWestgate howdy and happy holidays. thanks for all of your input so far. i did manage to get an app protocol together so that you and others can hopefully add bip-85 apps to the reference implementation easily:\r\nhttps://github.com/bitcoin/bips/pull/1958\r\n\r\ni'm sure it needs some improvements as i rushed it but again should be a big step up. lmk if it works for your app and if you desire any protocol changes.\r\n\r\nhttps://github.com/akarve/bipsea/blob/protocol/src/bipsea/app_protocol.py",
          "created_at": "2025-12-29T02:58:34Z"
        }
      ]
    }
  ],
  "issues": [],
  "summary": {
    "pull_requests": 1,
    "issues": 0
  }
}