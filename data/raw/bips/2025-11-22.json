{
  "source": "github",
  "repository": "bitcoin/bips",
  "fetched_at": "2026-01-15T21:56:55.296056+00:00",
  "date": "2025-11-22",
  "pull_requests": [
    {
      "number": 2040,
      "title": "BIP93: Generalize codex32 format for any hrp and fix typos",
      "body": "**Summary of Changes:**\r\nDescribe codex32 format for arbitrary human-readable parts not just \"ms\", specify master seed encoding standard, add new test vectors and enhance readability. This makes the document more like BIP-0173: proposing an encoding \"codex32\", then defining a standard for something using it.\r\n\r\nSee discussion on https://github.com/bitcoin/bips/pull/2023#issuecomment-3538570493.\r\n\r\n**Spec:**\r\n- fixed the threshold mistake in the abstract\r\n- replaced \"master seed\" with \"secret\", prior to the \"Master seed format\" section and made descriptions hrp general\r\n- updated the checksum reference code to produce valid checksums for any `hrp`\r\n- change _t_ to _k_ to match the test vectors and book\r\n- defined \"ms\" codex32 secrets:\r\n  - using terms \"secret seed\" (as the book does) and \"codex32-encoded master seed\" to refer to \"ms\" codex32 secrets\r\n  - recommended using first 4 characters of the bech32-encoded fingerprint as the identifier\r\n  - recommended the padding bits be set with a CRC code for extra error detection. Provided reference code for this checksum.\r\n\r\n**Test Vectors:**\r\n\r\n- Fixed the cornucopia of naming conventions in the Test vectors \r\n  - used mostly \"secret seed\", \"codex32 secret\", and \"codex32-encoded X\".\r\n- Fixed test vector 5 which did not actually append a long checksum to \"random\" data as the text said it would.\r\n- Added vector 6 encoding a \"cl\" prefix codex32-encoded HSM secret, then relabels the identifier (producing a new checksum and codex32-encoded HSM secret)\r\n- Added vector 7 which parses a \"cl\" prefix codex32 secret and decodes the HSM secret\r\n- Clarified why invalid prefix test vectors were bad (their checksum is for \"ms\" but their prefix is not \"ms\")\r\n- We might want to add one that uses \"cl\" with the old \"ms\" checksum code as that will now fail with the updated `ms32_verify_checksum` function\r\n\r\n",
      "state": "open",
      "user": "BenWestgate",
      "created_at": "2025-11-22T06:36:29Z",
      "updated_at": "2026-01-08T21:32:57Z",
      "comments": 20,
      "url": "https://github.com/bitcoin/bips/pull/2040",
      "labels": [
        "Proposed BIP modification",
        "Pending acceptance"
      ],
      "comment_list": [
        {
          "user": "roconnor",
          "body": "Yes let's keep the silly exception for now for the sake of getting a agreeable PR.  We should hammer out the master seed bit-size restrictions in a separate PR.\r\n\r\nIf you want to say that length 96 ms seeds are deprecated that's okay too.  But I still want to argue for the merits of 160 bit master seeds.",
          "created_at": "2025-11-27T00:52:31Z"
        },
        {
          "user": "bosshaas13131313",
          "body": "No.\r\n\r\nOn Thu, Nov 27, 2025, 2:20 AM Ben Westgate ***@***.***> wrote:\r\n\r\n> ***@***.**** commented on this pull request.\r\n> ------------------------------\r\n>\r\n> In bip-0093.mediawiki\r\n> <https://github.com/bitcoin/bips/pull/2040#discussion_r2567413699>:\r\n>\r\n> > +def codex32_verify_checksum(hrp, data):\r\n>      if len(data) >= 96:                      # See Long codex32 Strings\r\n> -        return ms32_verify_long_checksum(data)\r\n> +        return codex32_verify_long_checksum(bech32_hrp_expand(hrp) + data)\r\n>      if len(data) <= 93:\r\n> -        return ms32_polymod(data) == MS32_CONST\r\n> +        return codex32_polymod(bech32_hrp_expand(hrp) + data) == CODEX32_CONST\r\n>      return False\r\n>\r\n> Needs to become now to:\r\n>\r\n> def codex32_verify_checksum(hrp, data):\r\n>     combined = bech32_hrp_expand(hrp) + data\r\n>     if len(combined) >= 96:\r\n>         return codex32_verify_long_checksum(combined)\r\n>     if len(combined) <= 93:\r\n>         return codex32_polymod(combined) == CODEX32_CONST\r\n>     return False\r\n>\r\n> Missing:\r\n>\r\n>    - the thorny zero length \"ms\" rule.\r\n>    - the check in codex32_decode() for the upper long codex32 length\r\n>    limit.\r\n>\r\n> Because of this new max length rule rule we have the curious situation\r\n> where valid \"long codex32\" strings can actually be shorter overall (and in\r\n> data part characters) than regular codex32.\r\n>\r\n> May want to rename that format any thoughts?\r\n>\r\n> Ex:\r\n> \"long\" codex32 format: 10 hrp characters + 1 + 6 header characters + 54\r\n> payload characters + 15 checksum characters = 86\r\n> codex32 format: \"ms\" hrp characters + 1 + 6 header characters + 74 payload\r\n> characters + 13 checksum characters = 96\r\n>\r\n> —\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/bitcoin/bips/pull/2040#pullrequestreview-3513818681>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/BNFR33IQPDGIR4ICII5KOVT362Q2BAVCNFSM6AAAAACM4BCWD6VHI2DSMVQWIX3LMV43YUDVNRWFEZLROVSXG5CSMV3GSZLXHMZTKMJTHAYTQNRYGE>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "created_at": "2025-11-27T07:23:14Z"
        },
        {
          "user": "scgbckbone",
          "body": "How I generate non-secret shares:\r\n1. From current loaded secret (whether it is mnemonic, xprv, or codex32)\r\n    * codex32: secret = master_seed (secret share with hrp MS)\r\n    * others: secret = chaincode + privkey (64bytes) (secret share with hrp CC)\r\n2. [BIP-85](https://github.com/bitcoin/bips/pull/1958) derive from above secret --> master secret for share 'a'\r\n3. interpolate secret share with share 'a' while changing only index (c,d,d,e,f,g,h...) to generate new shares",
          "created_at": "2025-11-27T15:46:33Z"
        },
        {
          "user": "BenWestgate",
          "body": ">     * HRP: `cc`\n\n\"bc\" and \"tb\" for Bech32 addresses were an upgrade in human-readable prefix from the base58 encoding.\n\nI consider it a regression if you use less characters to encode a human-readable prefix than the base58 extended key format did. \"xpriv\" is an option here.\n\n>     * encodes chaincode + private key of BIP-32 master extended key (64 bytes)\n\nDoes your format need a 65th byte for the public key that is zero when encoding private keys?\n\nThere are many advantages to the strings needing disambiguation having the same byte length.\n\n> I only have one HRP, I do not differentiate between testnet/mainnet, ... DO you consider the lack of testnet/mainnet separation an issue?\n>\n\nYes, this is a huge regression from the current bip32 extended key format we want to upgrade. Mostly that I can't tell by looking at the descriptor if it's for real funds or not.\n\n> Your addition of HRP into checksum definitely broke my tests wrt checksum for `cc` hrp secrets  (not an issue, I haven't released yet - but I'm planning to in few weeks)\n\nHRP was always in the checksum, it just was pre-computed for \"ms\" so the checksums for other HRP were wrong. I noticed when I tried to validate the CLN HSM secret examples in my python-codex32 package.\n\n\n> My implementation is not ECW.\n\n@roconnor has a PR in codex32 that does ECC you could test.\n\n>I even provide generate support for secret share S.  I only allow to generate 128 & 256 bit MS secrets (but allow to import also 512 bit).\n\nI have a codex32 PR to update wallets.md guidance for generation, you may see something useful, especially in the HWW case.\n\n\nIn short:\n> \n> 1. TRNG 256 entropy bits\n> \n> 2. r = sha256(sha265(entropy))\n> \n> 3. x = r[:byte_len]\n> \n> 4. x is new master secret, and default ID is 20 MSB from master XFP (but user can change if he wishes to)\n\n\nYou can and probably should use the entropy bits directly. If they lack entropy, sha256d is an illusion of security.\n\n> What are the chances of this patch-set to be accepted? Is this spec stable enough to start releasing it ? \n\nIt will need wider community review than us. But there's comments by P. Wuille as far back as 2020 stating a 4 error correcting bech32 encoding of extended keys is needed. So high acceptance changes once it's correct and shiney.\n\nThis spec PR will not change anything that affects your encoding of ~78 bytes or whatever an extended key has.\n\nWe're mostly debating behavior at the limit between short and long checksums. Yours unambiguously use long codex32.\n",
          "created_at": "2025-11-27T17:02:56Z"
        },
        {
          "user": "BenWestgate",
          "body": "> How I generate non-secret shares:\n\n> 2. [BIP-85](https://github.com/bitcoin/bips/pull/1958) derive from above secret --> master secret for share 'a'\n> \n> 3. interpolate secret share with share 'a' while changing only index (c,d,d,e,f,g,h...) to generate new shares\n\nIt is unsafe to child derive shares from the secret they recover. They should be independently random.\n\nWhen part of the secret is compromised and an attacker tries to brute force the rest: the dependent relation between the secret and share A allows an attacker with k-1 shares or share A to check his guesses against this. This is far faster than checking an address.\n",
          "created_at": "2025-11-27T17:10:34Z"
        },
        {
          "user": "scgbckbone",
          "body": "> HRP was always in the checksum, it just was pre-computed for \"ms\" so the checksums for other HRP were wrong. I noticed when I tried to validate the CLN HSM secret examples in my python-codex32 package.\r\n\r\nI see now...\r\n\r\n> It is unsafe to child derive shares from the secret they recover. They should be independently random.\r\n\r\nI do not want to use randomness here, as I want to split existing secret, and I require the \"split\" to be deterministic, so that if user is splitting the exact same secret, uses same hrp, same threshold, same id, and same number of shares - application always produces the exact same shares. I could add an option to to choose, if random, or deterministic split, but deterministic is a hard requirement.\r\n\r\n...also it is 5 hardened derivation steps plus hmac_sha512\r\n\r\n> When part of the secret is compromised and an attacker tries to brute force the rest: the dependent relation between the secret and share A allows an attacker with k-1 shares or share A to check his guesses against this. This is far faster than checking an address.\r\n\r\nthere are plenty other brute-force options if attacker has part of secret, I do not consider this scenario of yours to be something I should optimize for\r\n\r\n> Yes, this is a huge regression from the current bip32 extended key format we want to upgrade. Mostly that I can't tell by looking at the descriptor if it's for real funds or not.\r\n\r\nI do not encode extended key (or full extended key), I only encode chaincode + privkey, without any other data as I just want to be able to restore naked xpriv from it, without any more meta extended keys carry. As I use it for both mnemonics and extended keys. \r\n\r\nThat is why I dismissed the idea of doing testnet/mainnet differentiation as I consider my 64bytes to be the \"secret\"",
          "created_at": "2025-11-27T17:54:56Z"
        },
        {
          "user": "BenWestgate",
          "body": "> > It is unsafe to child derive shares from the secret they recover. They should be independently random.\r\n> \r\n> I do not want to use randomness here, as I want to split existing secret, and I require the \"split\" to be deterministic, so that if user is splitting the exact same secret, uses same hrp, same threshold, same id, and same number of shares - application always produces the exact same shares. I could add an option to to choose, if random, or deterministic split, but deterministic is a hard requirement.\r\n\r\nThe best you could do here if you insist, is perform a KDF on the secret data to harden it before deriving child shares from that derived key. But it still reduces security from information theoretic to computational.\r\n\r\n> ...also it is 5 hardened derivation steps plus hmac_sha512\r\n\r\nStill significantly faster than address checking. The EC mult is the bottleneck for address checking is what Andrew told me.\r\n\r\n> > When part of the secret is compromised and an attacker tries to brute force the rest: the dependent relation between the secret and share A allows an attacker with k-1 shares or share A to check his guesses against this. This is far faster than checking an address.\r\n> \r\n> there are plenty other brute-force options if attacker has part of secret, I do not consider this scenario of yours to be something I should optimize for\r\n\r\nMy point is your standard should be harder to exploit than all other options or we lose security for nothing. Simply deriving child shares from an argon2id or scrypt derived key is probably enough protection.\r\n\r\n> That is why I dismissed the idea of doing testnet/mainnet differentiation as I consider my 64bytes to be the \"secret\"\r\n\r\nIt seems better to encode the recovery words and wordlist with a `bip39_12w` or `bip39_24w` human-readable part encoding standard than encode the resulting private key and chaincode bytes. A full bip32 codex32 encoding standard would be more useful than a neutered master xprv only edition.",
          "created_at": "2025-11-27T19:45:51Z"
        },
        {
          "user": "BenWestgate",
          "body": "This table shows the undetectable errors, each row has 2-3 characters which cannot be distinguished since they differ only in the upper bits.\r\n<img width=\"324\" height=\"565\" alt=\"image\" src=\"https://github.com/user-attachments/assets/20ec9cdd-c65a-4b6c-aed9-9b7ef3825033\" />\r\n\nI found an 83 character Bech32 HRP with 3 substitutions that validates. In theory, some long HRP won't detect even 1-2 errors affecting high bits. We inherit this problem if we copy Bech32 max length rules.\n\nThe worse case is: a secret is transcribed wrong or damaged, user or heirs, application is forgotten, it validates or corrects to a different application and then is transmitted.\n\nThis is worse than a wrong HRP address validating.\n\nWe should guarantee to correct 2 HRP errors by covering the expanded characters. Now any wrong 2 character HRP for every seed length reveals it is \"ms\" secret data. For the more common errors affecting only the low (or high) bits two errors from the data can also be corrected.\n\nSo the correct 4 errors guarantee holds under the assumption the HRP errors affect only low (or high) bits. Same assumption as Bech32's detection guarantee, and it's a detection only standard. We store secrets so we need correction guarantees and this is how we get them.",
          "created_at": "2025-11-27T21:30:39Z"
        },
        {
          "user": "roconnor",
          "body": "I'm this close to throwing in the towel.  BIP-93's design was never intended to be generalized to arbitrary HRP, and it shows.  If people want to reuse our polynomial for their own schemes, then more power to them.  They can make their own BIP.",
          "created_at": "2025-11-27T22:08:19Z"
        },
        {
          "user": "apoelstra",
          "body": "Sorry for being late to the party. I have read through this whole discussion except for the digression about deterministic share derivation and except for Russell's detailed code. As I understand it there are a few issues at play:\r\n\r\n* Ben wants the HRP to be covered by the checksum, which has multiple problems\r\n   * if you don't know the HRP you arguably don't know the checksum so how can you correct it?\r\n   * but conversely Ben points out that we likely want `xpub`/`xprv` HRPs which are easy to mess up and would share a checksum\r\n   * each HRP character contributes two characters to the checksum plus an extra \"separator\" character so length n takes away 2n+1 from your total length, which is surprising and weird\r\n   * (There was a long discussion about restricting the character set of HRPs. As you have observed, I've already violated this with my `bip32_24w` HRPs. I'm skeptical this matters. If there is anybody except me doing this, they would have needed to do a comparable amount of insane off-spec work to accomplish it and \"protecting them\" by extending the spec to include them should not be a priority.)\r\n* How do we determine the threshold at which to switch to \"long codex32\" which is a totally different checksum\r\n   * Ben would like there to only be a few allowable lengths of long codex32 strings, which I directionally agree with, but I also note that I have violated this (I have 264-bit strings which are converted directly from BIP39 seed words).\r\n* Some discussion on what the allowable HRPs should be. BIP-173 allows any ASCII string up to 83 characters.\r\n   *  ...but if you look at the registered list of BIP-173 prefixes, despite there being some pretty crazy crap in there, every single prefix is less than 12 characters, and except for one using `:` and one using `@` every single one is alphanumeric\r\n   * Ben initially proposed restricting the set of characters to ones that all have distinct low bits so that we could \"ignore the high bits\". But as seen in his above table, this is impossible if we allow both numbers and letters.\r\n\r\n**In the interest of moving forward I would kinda like Ben to make a new PR with the non-HRP changes, which it seems like everyone agrees with and would reduce the size of the diff of this one.**\r\n\r\nThen my opinions on the above:\r\n\r\nI agree with Russell that in general we should not attempt to correct the HRP. This was outside of the design space for our codex32 SSSS application and among other things we (ab)used this fact to distinguish codex32 from long codex32 on length alone and not HRP. Having said this, if Ben wants to try to error-correct HRPs all the power to him and we should take some effort to avoid undermining that goal.\r\n\r\nSo for *this BIP* we should say:\r\n\r\n* Users can register their own HRPs at [link] but they are only allowed to use ASCII 96 to 126, and their length can be at most 8, say. (These are the tightest restrictions I would support, and I'd also accept any looser ones up to the \"83 ascii characters free for all\" of BIP 173.) This gives us `{` `|` `}` and `~` as well as letters. People who want a separator should be happy to use `~`.\r\n* The HRP defines the checksum and SHOULD NOT be error-corrected, *unless* there is a separate specification describing how to do this. `xpub`/`xprv` I think needs to have its own BIP for this. Maybe there could be a general-purpose \"bip93 with HRP correction\" BIP that covers questions like \"what if the user has a character outside of the allowable set\" or \"should we preferentially try to correct `_` and `-` to `~` or just try random things\" or \"should we have a fixed set of supported HRPs and just try all of these\". It seems that different answers make sense in different contexts.\r\n* I'm happy with whatever length threshold we want for switching between codex32 and long codex32. I think \"93 - length of HRP\" is fine, along with an exception for `ms`. We should specify the maximum length in the table of registered HRPs so people don't have to know the formula if they don't want to.\r\n\r\nI think this should make everyone happy, except that it leaves HRP correction underspecified and delegated to another future BIP. (I would also be open to bringing more text into BIP 93 itself, but let's try to accomplish the above before we do that.)",
          "created_at": "2025-12-05T17:37:55Z"
        },
        {
          "user": "jonatack",
          "body": "@BenWestgate Do you plan to update here following the merge of #2052?",
          "created_at": "2025-12-15T17:37:34Z"
        },
        {
          "user": "BenWestgate",
          "body": "> * How do we determine the threshold at which to switch to \"long codex32\" which is a totally different checksum\n\nIt's best for this to depend only on length. Consistent with BIP-0173. \n\nThe \"ms\" exception for 93 data characters we can either:\n- deprecate (let it decode but future `len(hrp) + len(data) > 80` characters encodings will use long codex32\n- count \"ms\" as zero characters so nothing changes\n\n> * Some discussion on what the allowable HRPs should be.\n\nPrefer keeping what BIP-0173 allows to avoid redefinition.\n\n>    * Ben initially proposed restricting the set of characters to ones that all have distinct low bits so that we could \"ignore the high bits\". But as seen in his above table, this is impossible if we allow both numbers and letters.\n\nNot quite, I propose to restrict the _registry_ so that every hrp in it has unique low bits from every other registered hrp.\n\nAllow every US-ASCII character but applications should not register an hrp that is only unique in the high bits as it might be mistaken for another.\n\nI think this maintains 8 character error detection guarantees as the low bits are always covered and unique among valid hrp.\n\n\n> **...I would like Ben to make a new PR... [to] reduce the size of the diff of this one.**\n\nDone and merged.\n\n> Then my opinions on the above:\n> \n> I agree with Russell that in general we should not attempt to correct the HRP.\n\nI agree. Error detection guarantees on it are enough to avoid disasters when honest software detects data it should not have been given.\n\n> So for *this BIP* we should say:\n\n> * The HRP defines the checksum and SHOULD NOT be error-corrected, *unless* there is a separate specification describing how to do this.\n\nCorrection should try all registered hrp if rebroadcast is not an option. Assume the fewest edits is the valid hrp. According to the edit distance formula in wallets.md\n\n>`xpub`/`xprv` I think needs to have its own BIP for this.\n\nAgreed. Someone may have volunteered to do this.\n\n> * I'm happy with whatever length threshold we want for switching between codex32 and long codex32. I think \"93 - length of HRP\" is fine, along with an exception for `ms`.\n\nAgree. `93-len(hrp)` is simplest. Is that \"ms\" rule a verify exception (deprecate) or create and verify exception?\n\n>specify the maximum length in the table of registered HRPs so people don't have to know the formula if they don't want to.\n\nUnsure why string length for a given payload size and hrp belongs in the registry.\n\n> except that it leaves HRP correction underspecified and delegated to another future BIP.\n\nI think that's fine, correction is application specific. Or at very least rules for: public/private/secret and always/sometimes/never retransmissable data. That's up to 9 hrp types and then correction guidance may include contexts expecting combinations of multiple of these.\n\nI just don't think it can or should all be said here. Just enough to avoid disasters such *IF* hrp correction is attempted the least edits should be assumed as the correct hrp. And in applications that transmit data, probably MUST.\n\n>(I would also be open to bringing more text into BIP 93 itself, but let's try to accomplish the above before we do that.)\n\nAgreed. Safety guidance only here\n\n",
          "created_at": "2025-12-15T19:24:45Z"
        },
        {
          "user": "BenWestgate",
          "body": "> @BenWestgate Do you plan to update here following the merge of #2052?\n\nYea. Enough consensus has formed to do another commit incorporating it this week.",
          "created_at": "2025-12-15T19:32:28Z"
        },
        {
          "user": "roconnor",
          "body": "If it is helpful we could start with an intermediate amendment to BIP-93 seed sizes to only allow between 128 and 256 bit seeds (specifically 16 to 32  byte seeds) for short codex 32 strings, and only allow exactly 512 bit secrets for long codex32 strings.  This would eliminate the 95 and 96 character special exceptions we are worried about.  I think we all agree we want to restrict the valid size values to some subset of these values anyways, and there is only a small debate on how far we ought to go.\r\n\r\nE.g. I would also not oppose going as far as restricting seed sizes to be of 128, 160, 192, 224, and 256, which are the entropy sizes listed in BIP-39.  (And also keeping 512 bit long codex32 for compatibility with BIP-39 generated master seeds).\r\n\r\nMy only hesitation is that I know some folks want to restrict this list even further, and it would be somewhat annoying to make \"breaking changes\" twice.  I use the word \"breaking changes\" loosely since, in practice people are using 128, 256 and 512 bit entropy sizes.\r\n",
          "created_at": "2025-12-15T19:40:08Z"
        },
        {
          "user": "BenWestgate",
          "body": "I found this reply in my browser cache:\r\n\r\n> if you don't know the HRP you arguably don't know the checksum so how can you correct it?\r\n\r\nBech32/Bech32m checksum:\r\n- length 90 or less\r\n- 1st value is 0-16\r\n- The seventh-from-last character has zero padding\r\n- implementations SHOULD NOT implement correction...\r\n\r\nCodex32 checksum:\r\n- length 94 or less or 97 or more\r\n- Data starts with digit\r\n  - If \"0\", 6th character is \"s\"\r\n- 14/16th (short/long) from last character may have a 1 in its padding\r\n- MAY implement correction...\r\n  \r\nOnly threshold 9, 8, 2, and 0 are valid segwit `data[0]` and 0 has  \"s\" ruling 31:1 in codex32 favor.\r\n61.25% of random 7th from last characters will have a 1 in their padding. 1 in 10^9 the Bech32 checksum validates\r\n\r\nAny attempt at suggesting HRP corrections should assume codex32 after checking it's invalid:\r\n- Bech32/Bech32m\r\n- Base58Check\r\n- Hex encoded public key\r\n\r\nThen only suggest registered HRP.\r\n\r\n> If it is helpful we could start with an intermediate amendment to BIP-93 seed sizes to only allow between 128 and 256 bit seeds (specifically 16 to 32 byte seeds) for short codex 32 strings, and only allow exactly 512 bit secrets for long codex32 strings.\r\n\r\nIt is very helpful to lose the \"ms\" exceptions. These rules fit perfectly in the new \"Master seed format\" section.\r\n16..32 for regular and 64 for long looks great if you're OK with no insert/delete correction outside 16, 24, 32, and 64.\r\n**Do you want to write it, or should I?**\r\n\r\nWallets.md says:\r\n> MAY attempt correction by deleting and/or inserting characters, as long as the resulting string has a valid length for a codex32 string. **ECWs MAY assume the correct length is the closest of 48 or 74.**\r\n\r\nWe can safely amend that to \"48, 61, or 74.\" as the correctable lengths of each do not overlap.\r\n\r\n>I think we all agree we want to restrict the valid size values to some subset of these values anyways, and there is only a small debate on how far we ought to go.\r\n\r\nIf it's ready to test again, https://github.com/BlockstreamResearch/codex32/pull/70 could give objective data how much performance or accuracy insert/delete correction loses when it checks every length or lengths other than 48, 61, or 74.\r\n \r\n> E.g. I would also not oppose going as far as restricting seed sizes to be of 128, 160, 192, 224, and 256, which are the entropy sizes listed in BIP-39. (And also keeping 512 bit long codex32 for compatibility with BIP-39 generated master seeds).\r\n\r\nHaving just two lengths in correction range is like losing 1-bit of checksum, 160 and 224 may not significantly harm accuracy.\r\n \r\n> My only hesitation is that I know some folks want to restrict this list even further, and it would be somewhat annoying to make \"breaking changes\" twice. I use the word \"breaking changes\" loosely since, in practice people are using 128, 256 and 512 bit entropy sizes.\r\n\r\nIf testing shows a significant loss of insert/delete correction accuracy would that sway your opinion? If not, only 128, 160, 192, 224, and 256 has consensus.\r\n\r\nP.S.: I checked the characters for descriptor key origin data and if it is prepended inside the HRP of xpub/tpub, it maintains the \"low bits always unique\" hrp registry rule for any master fingerprint hex and derivation path symbols which is a nice omen.",
          "created_at": "2025-12-16T05:56:08Z"
        },
        {
          "user": "BenWestgate",
          "body": "Since it looks like the simplest and best direction for length switching is based on:\r\n```python\r\ndef codex32_verify_checksum(hrp, data):\r\n    \"\"\"Verify a checksum given HRP and converted data characters.\"\"\"\r\n    if 93 < len(hrp) + len(data) < 96:\r\n        raise InvalidLength\r\n    spec = Encoding.CODEX32 if len(hrp) + len(data) <= 93 else Encoding.CODEX32_LONG\r\n    return verify_checksum(bech32_hrp_expand(hrp) + data, spec)\r\n\r\n```\r\nThis \"wrong checksum for their given data sizes\" test vector now should pass:\r\n`\"ms10fauxsxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxv70wkzrjr4ntqet\"`\r\n\r\nIt would have had 95 data part length but with the inclusion of the hrp it's now valid.  Mark it as an xfail?\r\n\r\nIs it time to make that helper PR where we restrict master seed payload lengths (\"ms\", other applications can stay 19-1023 as discussed)?",
          "created_at": "2026-01-05T21:46:38Z"
        },
        {
          "user": "roconnor",
          "body": ">     if 93 < len(hrp) + len(data) < 96:\r\n\r\nI don't understand the logic behind this condition.",
          "created_at": "2026-01-06T15:46:42Z"
        },
        {
          "user": "BenWestgate",
          "body": "> > ```\r\n> > if 93 < len(hrp) + len(data) < 96:\r\n> > ```\r\n> \r\n> I don't understand the logic behind this condition.\r\n\r\nThe condition enforces the gap between regular and long codex32.\r\nTotal covered length is `len(hrp) + len(data)` per BIP-0173 (this PR aligns).\r\nValues ≤93 use CODEX32, values ≥96 use CODEX32_LONG.\r\nLengths 94–95 are explicitly invalid, so this check rejects that range before selecting a spec.\r\n\r\nIt saves a line versus saying the equivalent:\r\n```python3\r\ndef codex32_verify_checksum(hrp, data):\r\n    \"\"\"Verify a checksum given HRP and converted data characters.\"\"\"\r\n    if len(data) >= 96:                      # See Long codex32 Strings\r\n        return Encoding.CODEX32_LONG.verify_checksum(bech32_hrp_expand(hrp) + data)\r\n    if len(data) <= 93:\r\n        return Encoding.CODEX32.verify_checksum(bech32_hrp_expand(hrp) + data)\r\n    raise InvalidLength\r\n```",
          "created_at": "2026-01-07T21:54:29Z"
        },
        {
          "user": "roconnor",
          "body": "Oh right, because the long checksum is longer.  I remember now.",
          "created_at": "2026-01-07T21:57:13Z"
        },
        {
          "user": "BenWestgate",
          "body": "@roconnor I have written the [length restriction](https://github.com/bitcoin/bips/pull/2077) helper PR for this PR. I'll see you there.\r\n",
          "created_at": "2026-01-08T21:32:01Z"
        }
      ]
    }
  ],
  "issues": [],
  "summary": {
    "pull_requests": 1,
    "issues": 0
  }
}