{
  "source": "github",
  "repository": "bitcoin/bips",
  "fetched_at": "2026-01-15T21:53:35.214745+00:00",
  "date": "2025-10-15",
  "pull_requests": [
    {
      "number": 2006,
      "title": "BIP3: add guidance on originality, quality, LLMs",
      "body": "and soundness, and ensure it was proposed to the ML by one of the BIP authors.\r\n\r\nFollows up on the discussion starting from https://github.com/bitcoin/bips/pull/2005#issuecomment-3408065869.",
      "state": "closed",
      "user": "jonatack",
      "created_at": "2025-10-15T21:53:23Z",
      "updated_at": "2025-11-30T10:54:00Z",
      "comments": 0,
      "url": "https://github.com/bitcoin/bips/pull/2006",
      "labels": [
        "Proposed BIP modification"
      ]
    },
    {
      "number": 2005,
      "title": "BIP-0444: Taproot and Script Limits to Prevent Arbitrary Inscriptions",
      "body": "Summary: soft-fork proposal + policy defaults to prevent large arbitrary inscriptions, reduce UTXO/script bloat.\r\n\r\nHighlights:\r\n\r\nConsensus: tapscript push-run cap (256), IF/NOTIF ban, script push cap (256, BIP16 redeem exception), control block cap (257), SPK size cap (34), undefined witness/taproot versions invalid.\r\n\r\nPolicy: per-input v1 witness cap (1024 default), tapscript IF ban + push-only IF-body (80), push-run (256), control block (257), SPK size (34), push cap (256), unknown witness off by default.\r\n\r\nDeployment: BIP8 with one-year signaling window and delayed min activation.\r\n\r\nLink to discussion thread: https://gnusha.org/pi/bitcoindev/CALeFGL0PDjtRt2rfbY4gTkoc+5oNQ0mn_obraE7PrtHuNYFpQw@mail.gmail.com/T/#mb71350c5dfb119efeb92c5ee738b6c8225bf15b6\r\n\r\nNote: open to edits per BIP editors’ feedback.",
      "state": "closed",
      "user": "justinfilip",
      "created_at": "2025-10-15T04:17:35Z",
      "updated_at": "2025-10-16T19:48:55Z",
      "comments": 8,
      "url": "https://github.com/bitcoin/bips/pull/2005",
      "labels": [],
      "comment_list": [
        {
          "user": "vostrnad",
          "body": "What's the policy on accepting BIPs that are largely written by an LLM?",
          "created_at": "2025-10-15T04:30:09Z"
        },
        {
          "user": "justinfilip",
          "body": "@jonatack \r\n\r\n> 1. Please study BIP 2 for the process; notably, do not self-assign a BIP number\r\n\r\nJust finished reviewing. Understand the misstep.\r\n\r\n> 2. Are you one of the participants in the linked mailing list discussion?\r\n\r\nI am not, but I don't think it should matter, so long as it has been discussed by others.\r\n\r\n> 3. Is this your original work, or does it use LLMs?\r\n\r\nMostly LLM. When using LLMs in my areas of expertise, it works really well for me. It decreases development time and increases the scale of workload I can take on as an individual actor. The problem here is, the bitcoin codebase and developer community SOPs are not my area of expertise. \r\n\r\nTherefore, my approach is to take Luke's proposal and discussion from the mailing list and get the ball rolling - then lean on the review process to get it right. Very possible there are other efforts I'm not aware of, but generally I don't see others taking action and I do see Luke implying he is tired of being the one to propose and develop fixes, specifically requesting other developers to step up to the plate.\r\n\r\n\r\n@kwsantiago \r\n\r\n> Critical blockers:\r\n> \r\n> 1. Rule 2 vs 3 contradiction: You both ban OP_IF entirely (Rule 3) and define limits for OP_IF branches (Rule 2). Pick one approach.\r\n\r\nGood point. The BIP conflates temporary policy with intended consensus. \r\n\r\nFor clarification:\r\n\r\n1. The narrower Rule 2; ban only push-only IF/NOTIF branch bodies exceeding 80 bytes, while allowing legitimate conditional logic with non-push opcodes. \r\n\r\n2. Rule 3 (total IF ban) could be a temporary consensus measure that self-expires after 1–2 years if we want extra caution during the transition.\r\n\r\n> 2. Rule 7 breaks Bitcoin's upgrade path: Banning undefined witness versions removes the forward compatibility that Segwit/Taproot were designed for. This prevents future soft forks and contradicts BIP141/342 philosophy. OP_SUCCESS* ban breaks BIP342's explicit upgrade mechanism.\r\n\r\nYes, I think it would be a good idea to shut the door. I could be wrong there, but Luke seems sure of the viability and I am mostly leaning on his perspective. Generally, I think it would be great if we reduce bitcoin's usage to just money and leave it alone from that point forward. (Edit: other than bug fixes like the time bug, client UI/UX enhancements, etc)\r\n\r\n> 3. Missing parameter: Pseudocode references MAX_V1_PUSHONLY_WITNESS_ELEM but it's never defined in your parameters section.\r\n\r\nI can verify and fix that depending on what direction we're going.\r\n\r\n> 4. Rule 4 is too restrictive: 257-byte control block limit caps Taproot trees at ~128 leaves (7 merkle levels). BIP341 allows 4129 bytes for a reason: large trees (1000s of spending paths) are legitimate use cases.\r\n\r\nAgain leaning on Luke's perspective there. I personally would like to know what those legitimate use cases are, if there are some.\r\n\r\n> 5. Pseudocode has bounds-checking bugs: Multiple off-by-one errors and missing overflow checks in PUSHDATA parsing which could cause consensus splits.\r\n\r\nI can verify and fix that depending on what direction we're going.\r\n\r\n> Broader concerns:\r\n> \r\n> Deployment timeline is too aggressive (1-year signaling insufficient for this magnitude of change)\r\n\r\nNo disagreements with changing that depending on what direction we're going, just a placeholder.\r\n\r\n> No ecosystem impact analysis for miners, Lightning, existing contracts etc\r\n\r\nThat is true.\r\n\r\n> 3. Test vectors incomplete (no hex examples despite specification requiring them)\r\n\r\nCan iterate and improve. \r\n\r\n> 4. This BIP needs substantial revision before considering for implementation. The forward-compatibility break alone (Rule 7) should be a non-starter.\r\n\r\nI think that rule was made to be broken so long as it doesn't cause a hard fork and retains bitcoin's purpose as money (without arbitrary data inclusion).\r\n\r\n\r\n\r\n- My overarching question is: are there other developers out there who are willing to go on this path with me? Or are we going to make Luke do it? And then what from that point?\r\n\r\nAppreciate all the feedback.",
          "created_at": "2025-10-15T19:26:55Z"
        },
        {
          "user": "jonatack",
          "body": "> What's the policy on accepting BIPs that are largely written by an LLM?\r\n\r\nGood point. We are discussing an update to BIP 3 to cover these situations. For now, it seems at a minimum reasonable to state that:\r\n\r\n- Use of LLMs violates community norms and please don't waste our time (credit to @kanzure)\r\n- Authors must proactively disclose any use of LLMs\r\n",
          "created_at": "2025-10-15T20:06:02Z"
        },
        {
          "user": "jonatack",
          "body": "@justinfilip Thank you for your replies. I think it's best to close this: A number was self-assigned, this content didn't involve cooperation or collaboration with the contributors to the required ML discussion, and indeed it is mostly LLM-generated, which is a non-starter with respect to community norms and not wasting the valuable time of people working on these critical topics. We'll work to clarify these further for future submissions. Regards.",
          "created_at": "2025-10-15T20:16:40Z"
        },
        {
          "user": "kanzure",
          "body": "> Use of LLMs violates community norms and please don't waste our time (credit to @kanzure)\r\n\r\nWasting the community's time violates our community norms. LLM slop is therefore also a norm violation. However, it doesn't matter if it's LLM generated slop or non-LLM slop, slop is still slop.\r\n\r\n> Therefore, my approach is to take Luke's proposal and discussion from the mailing list and get the ball rolling - then lean on the review process to get it right.\r\n\r\nthis is not incentive compatible behavior. Also it's not how the BIP process works. Finally, I think it's contrary to your interests because it creates even more work (plus a bias towards defection) for the next person to sort through in order to achieve your goals,.",
          "created_at": "2025-10-15T20:27:43Z"
        },
        {
          "user": "luke-jr",
          "body": "> Rule 7 breaks Bitcoin's upgrade path: Banning undefined witness versions removes the forward compatibility that Segwit/Taproot were designed for. This prevents future soft forks and contradicts BIP141/342 philosophy. OP_SUCCESS* ban breaks BIP342's explicit upgrade mechanism.\r\n\r\n> Rule 4 is too restrictive: 257-byte control block limit caps Taproot trees at ~128 leaves (7 merkle levels). BIP341 allows 4129 bytes for a reason: large trees (1000s of spending paths) are legitimate use cases.\r\n\r\nNote these are NOT critical blockers.",
          "created_at": "2025-10-15T22:10:48Z"
        },
        {
          "user": "gmaxwell",
          "body": "> Note these are NOT critical blockers.\r\n\r\nhundreds to thousands of spending paths were a specifically advertised and discussed part of the proposal, it's what gives you some forms of efficient sparse multisig.  Also just blocking it confiscates coins.\r\n",
          "created_at": "2025-10-16T01:18:04Z"
        },
        {
          "user": "justinfilip",
          "body": "However it got here, with the benefit of hindsight, it's time to do the right thing. It's going to happen whether I'm involved or not, so you should wake up and get to work on Core. The games being played everywhere are pathetic.",
          "created_at": "2025-10-16T19:48:55Z"
        }
      ]
    },
    {
      "number": 2004,
      "title": "BIP 89: Chain Code Delegation for Private Collaborative Custody",
      "body": "We propose a new BIP for Chain Code Delegation, a collaborative custody technique that involves privileged participants (delegatee) withholding BIP32 chain codes at key setup time from a delegator, and sharing only enough information for non‑privileged participants to provide their signature.\r\n\r\nFor non-blinded signing, the delegatee derives a per‑spend scalar tweak t from the (withheld) chain code, the delegator computes the child key (x+t, P+tG), and produces a standard signature over the transaction’s sighash. For blind signing, the nonce and challenge are blinded so the delegator returns a blind Schnorr signature that the counterparty unblinds; thanks to Schnorr’s linearity, the same tweak is incorporated without revealing the final message or linkable details (optionally with predicate proofs for policy).\r\n\r\nThis enables participants like collaborative custodians to co‑sign when needed, while avoiding the broad visibility that comes with holding an xpub.\r\n\r\nMore background and discussions can be found: https://delvingbitcoin.org/t/chain-code-delegation-private-access-control-for-bitcoin-keys/1837. \r\n\r\nThis is joint work with @jesseposner. Feedback appreciated! ",
      "state": "open",
      "user": "jurvis",
      "created_at": "2025-10-15T03:28:50Z",
      "updated_at": "2026-01-08T20:48:05Z",
      "comments": 14,
      "url": "https://github.com/bitcoin/bips/pull/2004",
      "labels": [
        "New BIP",
        "PR Author action required"
      ],
      "comment_list": [
        {
          "user": "jurvis",
          "body": "@arminsabouri @jonatack thank you for taking the time to review! I've gone ahead and addressed your comments in \r\n9a47c29",
          "created_at": "2025-11-30T23:39:17Z"
        },
        {
          "user": "jurvis",
          "body": "thanks @jonatack! i think i got everything!",
          "created_at": "2025-12-03T22:48:02Z"
        },
        {
          "user": "jonatack",
          "body": "Thanks for updating.\r\n\r\n> Final verdict: 95 % LLM-generated or LLM-heavy, with ~5 % human origination of the core idea and final review.\r\n\r\n@jurvis can you help me out, please: Is this accurate? I'm trying to adapt our process and understanding.",
          "created_at": "2025-12-06T17:57:40Z"
        },
        {
          "user": "jurvis",
          "body": "hi @jonatack, happy to help. does the scan run through the sample code as well? the sample code contains a lot of boilerplate that we leveraged LLMs to help us with, and may be the reason why it registers high. \r\n\r\nHowever, the contents of the mediawiki itself should be ~90% original. We leaned on LLM use in the mediawiki mostly to  ensure that our formatting was aligned with existing conventions (heavily referencing BIP 340, BIP 352, BIP 32, and BIP 3), and to convert it from Markdown, which we had originally used to write our draft. \r\n\r\nFor example, we wrote out our original one of the algorithms in the following format originally:\r\n```\r\nSigning\r\n======\r\nWhen the counterparty requests that the collaborative custodian sign a transaction, it derives the BIP32 scalar tweak from the xpub (i.e. the value `parse_256(I_L)` from BIP32) and provides it to the custodian:\r\n\r\n# Inputs:\r\n#   chain_code : 32-byte chain code (hidden from custodian)\r\n#   P_par      : custodian’s parent public key (compressed)\r\n#   i          : child index for spending\r\n\r\nI   = HMAC-SHA512(key = chain_code,\r\n                 data = serP(P_par) || ser32(i))\r\nI_L = I[0:32]            # left half\r\nt_i = parse256(I_L)      # scalar tweak mod n\r\n# (I_R would be the child chain code—discarded here.)\r\n\r\n# Counterparty → Custodian: send t_i\r\n```\r\n\r\nWhich we got ultimately turned into this, to align with how BIP 32 reads:\r\n\r\n\r\n```\r\n=== Tweak Calculation ===\r\nTo produce CCD tweak data, a delegatee computes a per-participant scalar that aggregates the non-hardened derivation tweaks along the remaining path. Let the extended key retained by the delegatee be P at depth d, and let the target index vector be I = (i<sub>d+1</sub>, …, i<sub>n</sub>) with each i<sub>k</sub> < 2<sup>31</sup>.\r\n\r\n<div>\r\nAlgorithm ''ComputeBIP32Tweak(P, I)'':\r\n* Inputs:\r\n** ''P'': base public key at depth ''d''\r\n** ''I = (i<sub>d+1</sub>, …, i<sub>n</sub>)'': ordered sequence of non-hardened child indices\r\n* Let ''t = 0'' and ''E = P''.\r\n* For each index ''i'' in ''I'' (from left to right):\r\n** Run the BIP32 non-hardened derivation ''CKDpub'' on ''E'' with child index ''i'', yielding the child extended key ''P<sub>child</sub>'' and its scalar tweak ''δ'' (the parse<sub>256</sub>(''I<sub>L</sub>'') term from BIP32).\r\n** Let ''t = (t + δ) mod n''.\r\n** Let ''E = P<sub>child</sub>''.\r\n* If ''I'' is empty, let ''P′ = P''; otherwise let ''P′ = P<sub>child</sub>'' from the final iteration.\r\n* Return ''(t, P′)''.\r\n</div>\r\n```\r\n\r\nHope that helps.",
          "created_at": "2025-12-06T18:11:49Z"
        },
        {
          "user": "jonatack",
          "body": "> hi @jonatack, happy to help. does the scan run through the sample code as well?\r\n\r\nGave it the BIP draft only.\r\n\r\n",
          "created_at": "2025-12-06T18:15:51Z"
        },
        {
          "user": "jurvis",
          "body": "hi @jonatack just following up to see if there's anything I can do here to move things along. thanks!",
          "created_at": "2025-12-18T22:33:16Z"
        },
        {
          "user": "real-or-random",
          "body": "The inclusion of major parts of secp256k1lab in this form violates the (only) requirement in the MIT license under which secp256k1lab is distributed, see its COPYING file. ",
          "created_at": "2026-01-05T15:00:57Z"
        },
        {
          "user": "real-or-random",
          "body": "A related editorial question is whether it's a good idea to include distributions of secp256k1lab in the BIPs repo. This question is relevant not only for this BIP draft but also for #2070 and for the ChillDKG draft BIP (no PR yet). \r\n\r\nWe had raised that question in the context of ChillDKG over a year ago on the mailing list, specifically hoping to hear the opinion of the BIPs editors, but noone has commented so far: https://groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ (This post refers to the library as \"secp256k1proto\". This was our working title before we switched to \"secp256k1lab\" when publishing the code in a separate repo.)  \r\n\r\n\r\n",
          "created_at": "2026-01-05T16:17:06Z"
        },
        {
          "user": "murchandamus",
          "body": "> We had raised that question in the context of ChillDKG over a year ago on the mailing list, specifically hoping to hear the opinion of the BIPs editors, but noone has commented so far: https://groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ (This post refers to the library as \"secp256k1proto\". This was our working title before we switched to \"secp256k1lab\" when publishing the code in a separate repo.)\r\n\r\n@real-or-random: TBH, I don’t think I fully understand the trade-offs of the approaches you proposed. I would prefer that any software with on-going development were maintained outside of the BIPs repository, but maybe we could chat some time so that I better understand the situation.",
          "created_at": "2026-01-06T00:44:31Z"
        },
        {
          "user": "real-or-random",
          "body": "> > We had raised that question in the context of ChillDKG over a year ago on the mailing list, specifically hoping to hear the opinion of the BIPs editors, but noone has commented so far: [groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ](https://groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ) (This post refers to the library as \"secp256k1proto\". This was our working title before we switched to \"secp256k1lab\" when publishing the code in a separate repo.)\r\n> \r\n> @real-or-random: TBH, I don’t think I fully understand the trade-offs of the approaches you proposed. I would prefer that any software with on-going development were maintained outside of the BIPs repository, but maybe we could chat some time so that I better understand the situation.\r\n\r\nLet me try to simplify the discussion: If the BIP editors are okay with integrating a snapshot of secp256klab as a subtree in each `bip-xxxx` folder of a BIP whose code uses secp256k1lab (as currently proposed in this PR and in #2070), then I'm happy with that. I think it's the best solution.\r\n\r\n\"Snapshot\" means that it is a static thing, and maintenance of secp256k1lab will, of course, happen in its repo. I guess the only reason to ever touch a snapshot subtree in the BIPs repo is to fix a secp256k1 bug that specifically affects the BIP code that uses the library (and even in that case, other ways to resolve the overall issue could be considered).",
          "created_at": "2026-01-06T07:36:27Z"
        },
        {
          "user": "murchandamus",
          "body": "> > > We had raised that question in the context of ChillDKG over a year ago on the mailing list, specifically hoping to hear the opinion of the BIPs editors, but noone has commented so far: [groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ](https://groups.google.com/g/bitcoindev/c/HE3HSnGTpoQ/m/Y2VhaMCrCAAJ) (This post refers to the library as \"secp256k1proto\". This was our working title before we switched to \"secp256k1lab\" when publishing the code in a separate repo.)\r\n> > \r\n> > \r\n> > @real-or-random: TBH, I don’t think I fully understand the trade-offs of the approaches you proposed. I would prefer that any software with on-going development were maintained outside of the BIPs repository, but maybe we could chat some time so that I better understand the situation.\r\n> \r\n> Let me try to simplify the discussion: If the BIP editors are okay with integrating a snapshot of secp256klab as a subtree in each `bip-xxxx` folder of a BIP whose code uses secp256k1lab (as currently proposed in this PR and in #2070), then I'm happy with that. I think it's the best solution.\r\n> \r\n> \"Snapshot\" means that it is a static thing, and maintenance of secp256k1lab will, of course, happen in its repo. I guess the only reason to ever touch a snapshot subtree in the BIPs repo is to fix a secp256k1 bug that specifically affects the BIP code that uses the library (and even in that case, other ways to resolve the overall issue could be considered).\r\n\r\nThat seems reasonable to me, as it ensures that a functional reference implementation is retained in the context of the BIPs. The only concern that comes to mind would be that we might get more pull requests by LLM-commit farmers on those, but I guess we’d just have to filter those.",
          "created_at": "2026-01-06T22:15:23Z"
        },
        {
          "user": "jesseposner",
          "body": "@murchandamus Thanks for the detailed review, I will revise accordingly. I agree that delegatee/delgator is confusing, but I'm not sure what the better terminology is.\r\n\r\n@real-or-random I'll make sure to include the copyright and permission notice which I believe will satisfy the license requirements for secp256k1lab.",
          "created_at": "2026-01-07T19:52:56Z"
        },
        {
          "user": "real-or-random",
          "body": "> @real-or-random I'll make sure to include the copyright and permission notice which I believe will satisfy the license requirements for secp256k1lab.\r\n\r\nYep, thanks, and no offense, by the way.  :) I just think it's good practice to keep licenses with the code. It helps everyone later on. I suggest just including the existing COPYING file. And I think it would also be very useful to future readers of the BIP to note somewhere from which commit the files are taken, (e.g., have a sentence in the BIP, in some README file, or added to the top of the COPYING file) such as `The contents of this directory are taken from https://github.com/secp256k1lab/secp256k1lab commit id 01234567890abcdef...`.\r\n\r\n",
          "created_at": "2026-01-08T13:10:22Z"
        },
        {
          "user": "murchandamus",
          "body": "Hopefully the last comment on the secp-library discussion in your PR: Let’s continue that conversation in https://github.com/bitcoin/bips/pull/1855",
          "created_at": "2026-01-08T20:48:05Z"
        }
      ]
    }
  ],
  "issues": [],
  "summary": {
    "pull_requests": 3,
    "issues": 0
  }
}