{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T05:41:32.112395+00:00",
  "date": "2026-01-08",
  "pull_requests": [
    {
      "number": 34236,
      "title": "Add sedited to trusted-keys",
      "user": "sedited",
      "state": "closed",
      "created_at": "2026-01-08T19:11:51Z",
      "updated_at": "2026-01-10T05:17:23Z",
      "body": "As discussed on irc: https://www.erisian.com.au/bitcoin-core-dev/log-2026-01-08.html#l-286",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34236"
    },
    {
      "number": 34235,
      "title": "miniminer: stop assuming ancestor fees >= self fees",
      "user": "glozow",
      "state": "closed",
      "created_at": "2026-01-08T15:58:17Z",
      "updated_at": "2026-01-09T11:24:08Z",
      "body": "These assertions exist to detect double-deducting values when we update descendants. However, negative fees are possible with `prioritisetransaction` so it doesn't make sense to check this.\r\n\r\nLeave the check for sizes because those are never negative.\r\n\r\nFixes #34234\r\n",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34235"
    },
    {
      "number": 34233,
      "title": "test: fix Windows CI failures in wallet_multiwallet and old binary tests (ancient wallets)",
      "user": "w0xlt",
      "state": "closed",
      "created_at": "2026-01-08T15:17:11Z",
      "updated_at": "2026-01-09T16:26:47Z",
      "body": "Currently, the `wallet_multiwallet.py` and `feature_unsupported_utxo_db.py` functional tests are disabled on CI because they rely on legacy wallet binaries that do not correctly handle Unicode paths. \r\n\r\nThis is tracked as a `TODO` in `.github/workflows/ci.yml`. The limitation also blocks efforts to expand ancient wallet test coverage (e.g. bitcoin/bitcoin#33186).\r\n\r\nThis PR restores functional test coverage on Windows CI by addressing two root causes:\r\n\r\n1. **Skip Windows-incompatible tests in `wallet_multiwallet`**: Several test cases depend on Unix-specific filesystem behavior that is not supported on Windows:\r\n     - Directory permission tests using chmod (Windows ignores `os.chmod(path, 0)`)\r\n     - Recursive directory symlink tests (unsupported by listwalletdir)\r\n     - File symlink detection tests (Windows handles file symlinks differently)\r\n\r\n  2. **Use ASCII-only tmpdir for old binary tests**: When running tests against previous releases (`feature_unsupported_utxo_db`, `wallet_multiwallet`) on Windows, an ASCII-only temporary directory name (`test_runner_btc_run_`) is used instead of `test_runner_â‚¿_ðŸƒ_`. This avoids failures caused by older binaries lacking proper Unicode path support.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34233"
    },
    {
      "number": 34231,
      "title": "consensus: Fix potential null pointer crash in CalculateSequenceLocks",
      "user": "tboy1337",
      "state": "closed",
      "created_at": "2026-01-08T11:35:52Z",
      "updated_at": "2026-01-08T12:32:23Z",
      "body": "This PR fixes a potential null pointer dereference crash in the `CalculateSequenceLocks` function when processing time-based sequence locks with invalid input heights.\r\n\r\n### Problem\r\nThe `CalculateSequenceLocks` function in `src/consensus/tx_verify.cpp` was using `Assert(block.GetAncestor(std::max(nCoinHeight - 1, 0)))->GetMedianTimePast()` which could return a null pointer when the ancestor block doesn't exist (e.g., when input height is greater than current block height), leading to a crash when attempting to dereference it.\r\n\r\n### Solution\r\nModified the code to safely check if the ancestor block exists before attempting to access its median time past. When the ancestor lookup fails, the time-based sequence lock calculation is skipped for that input, preventing the crash while maintaining correct behavior.\r\n\r\n### Changes\r\n- **src/consensus/tx_verify.cpp**: Added null pointer check in `CalculateSequenceLocks` before accessing ancestor block for time-based sequence locks\r\n- **src/test/transaction_tests.cpp**: Added comprehensive unit tests covering edge cases for invalid heights, valid heights, and empty transactions\r\n- **test/functional/feature_bip68_sequence.py**: Added functional regression test to verify the fix works in real transaction processing\r\n\r\n### Testing\r\nThe fix includes:\r\n- Unit tests for `CalculateSequenceLocks` with invalid input heights (regression test)\r\n- Unit tests for normal operation with valid heights  \r\n- Unit tests for edge cases like empty transactions\r\n- Functional test that creates and processes a transaction with time-based sequence locks to ensure no crash occurs\r\n\r\nAll tests pass and the change maintains backward compatibility while preventing the crash scenario.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34231"
    },
    {
      "number": 34230,
      "title": "fuzz: Reject too large descriptor leaf sizes in scriptpubkeyman target",
      "user": "maflcko",
      "state": "closed",
      "created_at": "2026-01-08T11:23:25Z",
      "updated_at": "2026-01-14T21:35:44Z",
      "body": "Accepting \"expensive\" fuzz inputs which have no real use-case is problematic, because it prevents the fuzz engine from spending time on the next useful fuzz input.\r\n\r\nAlso, this may lead to problems, where the fuzz target can not be run at all on some platforms. See https://github.com/bitcoin/bitcoin/issues/34110.\r\n\r\nFixes https://github.com/bitcoin/bitcoin/issues/34110 by rejecting those useless and expensive inputs (via the third commit)\r\n\r\nCan be tested by running the input and checking the time before and after the changes here:\r\n\r\n```\r\ncurl -fLO 'https://github.com/bitcoin-core/qa-assets/raw/b5ad78e070e4cf36beb415d7b490d948d70ba73f/fuzz_corpora/scriptpubkeyman/1cf91e0c6bfff9dafcd4db5b0ba36b1e906f4cf5'\r\nFUZZ=scriptpubkeyman time ./bld-cmake/bin/fuzz ./1cf91e0c6bfff9dafcd4db5b0ba36b1e906f4cf5\r\n```\r\n\r\nAlso, the second commit fixes https://github.com/bitcoin/bitcoin/issues/31066.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34230"
    },
    {
      "number": 34229,
      "title": "[30.2] Backports & Final",
      "user": "fanquake",
      "state": "closed",
      "created_at": "2026-01-08T10:25:29Z",
      "updated_at": "2026-01-09T14:05:06Z",
      "body": "Backports:\r\n* #34221\r\n* #34226\r\n* #34227",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34229"
    },
    {
      "number": 34228,
      "title": "depends: Unset `SOURCE_DATE_EPOCH` in `gen_id` script",
      "user": "hebasto",
      "state": "closed",
      "created_at": "2026-01-08T08:35:38Z",
      "updated_at": "2026-01-11T00:11:02Z",
      "body": "When performing Guix builds for `{x86_64,arm64}-apple-darwin` hosts across different commits, all packages in `depends` are rebuilt even if there are no changes in either the  `depends` or `contrib/guix` subdirectories.\r\n\r\nThis occurs because the `SOURCE_DATE_EPOCH` environment variable enables Clang's `-source-date-epoch` option, which then appears in the output of `clang -v -E -xc -o /dev/null - < /dev/null`. For example:\r\n```\r\n$ SOURCE_DATE_EPOCH=1767855465 clang -v -E -xc++ -o /dev/null - < /dev/null\r\nclang version 21.1.7 (Fedora 21.1.7-1.fc43)\r\nTarget: x86_64-redhat-linux-gnu\r\nThread model: posix\r\nInstalledDir: /usr/bin\r\nConfiguration file: /etc/clang/x86_64-redhat-linux-gnu-clang.cfg\r\nSystem configuration file directory: /etc/clang/\r\nFound candidate GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/14\r\nFound candidate GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/15\r\nSelected GCC installation: /usr/bin/../lib/gcc/x86_64-redhat-linux/15\r\nCandidate multilib: .;@m64\r\nCandidate multilib: 32;@m32\r\nSelected multilib: .;@m64\r\n (in-process)\r\n \"/usr/bin/clang-21\" -cc1 -triple x86_64-redhat-linux-gnu -E -disable-free -clear-ast-before-backend -disable-llvm-verifier -discard-value-names -main-file-name - -mrelocation-model static -mframe-pointer=all -fmath-errno -ffp-contract=on -fno-rounding-math -mconstructor-aliases -funwind-tables=2 -target-cpu x86-64 -tune-cpu generic -debugger-tuning=gdb -fdebug-compilation-dir=/home/hebasto -v -fcoverage-compilation-dir=/home/hebasto -resource-dir /usr/bin/../lib/clang/21 -internal-isystem /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15 -internal-isystem /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15/x86_64-redhat-linux -internal-isystem /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15/backward -internal-isystem /usr/bin/../lib/clang/21/include -internal-isystem /usr/local/include -internal-isystem /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../x86_64-redhat-linux/include -internal-externc-isystem /include -internal-externc-isystem /usr/include -source-date-epoch 1767855465 -fdeprecated-macro -ferror-limit 19 -fmessage-length=180 -fgnuc-version=4.2.1 -fskip-odr-check-in-gmf -fcxx-exceptions -fexceptions -fcolor-diagnostics -faddrsig -D__GCC_HAVE_DWARF2_CFI_ASM=1 -o /dev/null -x c++ -\r\nclang -cc1 version 21.1.7 based upon LLVM 21.1.7 default target x86_64-redhat-linux-gnu\r\nignoring nonexistent directory \"/usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../x86_64-redhat-linux/include\"\r\nignoring nonexistent directory \"/include\"\r\n#include \"...\" search starts here:\r\n#include <...> search starts here:\r\n /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15\r\n /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15/x86_64-redhat-linux\r\n /usr/bin/../lib/gcc/x86_64-redhat-linux/15/../../../../include/c++/15/backward\r\n /usr/bin/../lib/clang/21/include\r\n /usr/local/include\r\n /usr/include\r\nEnd of search list.\r\n```\r\n\r\nAs a result, each package id differs between builds, which causes the script to treat the toolchain as changed and triggers unnecessary rebuilds.\r\n\r\nThis PR resolves this issue by unsetting `SOURCE_DATE_EPOCH` in a subshell before collecting toolchain details.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34228"
    },
    {
      "number": 34227,
      "title": "guix: Fix `osslsigncode` tests",
      "user": "hebasto",
      "state": "closed",
      "created_at": "2026-01-08T01:41:56Z",
      "updated_at": "2026-01-13T17:11:03Z",
      "body": "This PR aims to improve the experience for Guix builders when creating new Guix profiles after 2025. In particular, it should be helpful for those who are new to building with Guix.\r\n\r\nFixes https://github.com/bitcoin/bitcoin/issues/34220.\r\n\r\nOther possible alternatives to consider include:\r\n1. Applying a workaround as suggested [here](https://github.com/bitcoin/bitcoin/issues/34220#issuecomment-3718991398).\r\n\r\n2. Updating the package as suggested [here](https://github.com/bitcoin/bitcoin/issues/34220#issuecomment-3719022287).\r\n\r\n3. Disabling tests as suggested [here](https://github.com/bitcoin/bitcoin/issues/34220#issuecomment-3719538660).",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34227"
    },
    {
      "number": 34226,
      "title": "wallet: test: Relative wallet failed migration cleanup",
      "user": "davidgumberg",
      "state": "closed",
      "created_at": "2026-01-08T01:01:49Z",
      "updated_at": "2026-01-09T10:13:08Z",
      "body": "Prior to https://github.com/bitcoin/bitcoin/pull/34156, an issue existed where if migration of a wallet with a relative pathname failed, the relatively specified path where the legacy wallet is would be deleted. This issue predates #32273, because the relative pathnames get stacked together, e.g. \"../../\", the copy conflict bug that caused migration to abort early instead of getting far enough to attempt clean-up that was fixed in #32273 is avoided.\r\n\r\nThis is a functional test demonstrating that we handle failed migration clean-up correctly for relatively-named wallets. To see the issue, you can backport this test onto 29.x: https://github.com/davidgumberg/bitcoin/tree/2026-01-07-rel-migration-test-backport\r\n\r\nI've also added an absolute path failed migration cleanup test. WRT this and #34156, absolute paths exhibit similar behavior to unnamed wallets. Because of the name-conflict bug prior to #32273 an absolute-path migration would fail no matter what because migration would attempt to copy a file to a destination that already exists. But after #32273, absolute-path migration gets past there, and if it fails for some other reason, the same behavior that's fixed in #34156 occurs where the directory containing the wallet file is deleted.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34226"
    }
  ],
  "issues": [
    {
      "number": 34234,
      "title": "wallet: `MiniMiner` assertion failures when `prioritisetransaction` creates negative fees",
      "user": "dergoegge",
      "state": "closed",
      "created_at": "2026-01-08T15:23:53Z",
      "updated_at": "2026-01-09T11:24:07Z",
      "body": "*I hit these assertions in a test running on [Antithesis](https://antithesis.com/).*\n\nVibe coded functional tests to demonstrate: https://github.com/dergoegge/bitcoin/commit/1ccc289193f79b26c66bb958b459ed6e47ca425f.\n\n```\nnode0 stderr node/mini_miner.cpp:213 void node::MiniMiner::DeleteAncestorPackage(const std::set<MockEntryMap::iterator, IteratorComparator> &): Assertion `descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee()' failed.\nnode0 stderr node/mini_miner.cpp:240 void node::MiniMiner::SanityCheck() const: Assertion `std::all_of(m_entries.begin(), m_entries.end(), [](const auto& entry) { return entry->second.GetSizeWithAncestors() >= entry->second.GetTxSize() && entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee();})' failed.\n```\n\n<details>\n\n<summary>Here's an LLM's explanation for the bug:</summary>\n\n## Root Cause\n\nMiniMiner assumes transaction fees are always non-negative. When `prioritisetransaction` is used to apply large negative fee deltas, this assumption is violated, causing assertion failures.\n\nThe mempool correctly tracks negative modified fees, but MiniMiner's internal invariants break down when ancestor fee sums become negative.\n\n## Symptoms\n\n### 1. SanityCheck Assertion (mini_miner.cpp)\n\n```cpp\nAssert(entry->second.GetModFeesWithAncestors() >= entry->second.GetModifiedFee());\n```\n\n**Triggered when:** An ancestor has a very negative fee that drags the descendant's `ancestor_fees` below its own positive `own_fee`.\n\n**Example:**\n- Parent: fee = -2 BTC (via prioritisetransaction)\n- Child: fee = +141 sats\n- Child's ancestor_fees = -2 BTC + 141 sats â‰ˆ -2 BTC\n- Assertion: -2 BTC >= +141 sats â†’ **FALSE**\n\n### 2. DeleteAncestorPackage Assertion (mini_miner.cpp)\n\n```cpp\nAssert(descendant->second.GetModFeesWithAncestors() >= anc->second.GetModifiedFee());\n```\n\n**Triggered when:** A child has a negative fee such that its `ancestor_fees` is less than its parent's positive fee, while still satisfying SanityCheck.\n\n**Example:**\n- Parent: fee = +1410 sats\n- Child: fee = -705 sats (via prioritisetransaction)\n- Child's ancestor_fees = 1410 + (-705) = +705 sats\n- SanityCheck: 705 >= -705 â†’ **TRUE** (passes)\n- DeleteAncestorPackage: 705 >= 1410 â†’ **FALSE**\n\n## Reproduction\n\nFunctional tests: `test/functional/wallet_miniminer_sanitycheck.py` and `test/functional/wallet_miniminer_deleteancestorpackage.py`\n\nBoth tests:\n1. Create a parent-child transaction chain in the mempool\n2. Use `prioritisetransaction` to make fees negative\n3. Trigger MiniMiner via wallet `sendtoaddress` (which calculates bump fees)\n4. Node crashes on assertion failure\n\n</details>\n\n\n\n\n",
      "comments": 4,
      "url": "https://github.com/bitcoin/bitcoin/issues/34234"
    },
    {
      "number": 34232,
      "title": "wallet: SetBumpFeeDiscount(const CAmount): Assertion `discount >= 0' failed",
      "user": "dergoegge",
      "state": "open",
      "created_at": "2026-01-08T12:35:53Z",
      "updated_at": "2026-01-08T12:37:25Z",
      "body": "*I hit this assertion in a test running on [Antithesis](https://antithesis.com/).*\n\nVibe coded functional test to demonstrate: https://github.com/dergoegge/bitcoin/commit/587e42c3504bed5cb45137cd151f1e80e2314eed. Because this is caused by a race condition, the commit also includes a sleep to reliably trigger the issue.\n\n```\nnode0 stderr bitcoind: wallet/coinselection.cpp:823: void wallet::SelectionResult::SetBumpFeeDiscount(const CAmount): Assertion `discount >= 0' failed.\n```\n\n<details>\n\n<summary>Here's an LLM's explanation for the bug:</summary>\n\n## Bug\n\nAssertion `discount >= 0` fails in `SelectionResult::SetBumpFeeDiscount` (`src/wallet/coinselection.cpp:823`).\n\nFound during Antithesis testing with concurrent transaction creation.\n\n## Root Cause\n\nRace condition between two MiniMiner calculations during coin selection:\n\n1. **Individual bump fees** calculated in `AvailableCoins` (`spend.cpp:517`) via `calculateIndividualBumpFees()` - creates MiniMiner, copies mempool state, releases lock\n2. **Combined bump fee** calculated later in `ChooseSelectionResult` (`spend.cpp:809`) via `calculateCombinedBumpFee()` - creates a *new* MiniMiner with potentially different mempool state\n\nEach MiniMiner constructor acquires `LOCK(mempool.cs)` only for the duration of the constructor (`mini_miner.cpp:26`). The lock is released before the actual fee calculations run.\n\nIf mempool state changes between these two calls (e.g., fee deltas modified via `prioritisetransaction`, new transactions, evictions), the combined calculation can return a higher value than the sum of individual calculations:\n\n```cpp\n// spend.cpp:813-815\nCAmount bump_fee_overestimate = summed_bump_fees - combined_bump_fee.value();\nif (bump_fee_overestimate) {\n    result.SetBumpFeeDiscount(bump_fee_overestimate);  // negative if combined > summed\n}\n```\n</details>\n\n\n\n\n",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/issues/34232"
    }
  ],
  "summary": {
    "pull_requests": 9,
    "issues": 2
  }
}