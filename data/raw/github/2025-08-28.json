{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T20:09:38.309610+00:00",
  "date": "2025-08-28",
  "pull_requests": [
    {
      "number": 33268,
      "title": "wallet: Identify transactions spending 0-value outputs, and add tests for anchor outputs in a wallet",
      "body": "One of the ways that the wallet would determine if a transaction was sent from the wallet was by checking if the total amount being spent by a transaction from outputs known to the wallet was greater than 0. This has worked fine until recently since there was no reason for 0-value outputs to be created. However, with ephemeral dust and P2A, it is possible to create standard 0-value outputs, and the wallet was not correctly identifying the spends of such outputs. This PR updates `IsFromMe` to only check whether the wallet knows any of the inputs, rather than checking the debit amount of a transaction.\r\n\r\nAdditionally, a new functional test is added to test for this case, as well as a few other anchor output related scenarios. This also revealed a bug in `sendall` which would cause an assertion error when trying to spend all of the outputs in a wallet that has anchor outputs.\r\n\r\nFixes #33265 ",
      "state": "closed",
      "user": "achow101",
      "created_at": "2025-08-28T22:28:48Z",
      "updated_at": "2026-01-13T09:44:45Z",
      "comments": 16,
      "url": "https://github.com/bitcoin/bitcoin/pull/33268",
      "labels": [
        "Wallet"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33268.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [rkrux](https://github.com/bitcoin/bitcoin/pull/33268#pullrequestreview-3184703865), [enirox001](https://github.com/bitcoin/bitcoin/pull/33268#pullrequestreview-3197482104), [furszy](https://github.com/bitcoin/bitcoin/pull/33268#pullrequestreview-3213451317) |\n| Stale ACK | [jsarenik](https://github.com/bitcoin/bitcoin/pull/33268#issuecomment-3239456408), [w0xlt](https://github.com/bitcoin/bitcoin/pull/33268#pullrequestreview-3178375101), [kannapoix](https://github.com/bitcoin/bitcoin/pull/33268#pullrequestreview-3178686997) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#31615](https://github.com/bitcoin/bitcoin/pull/31615) (validation: ensure assumevalid is always used during reindex by Eunovo)\n* [#27865](https://github.com/bitcoin/bitcoin/pull/27865) (wallet: Track no-longer-spendable TXOs separately by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-08-28T22:28:53Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/49140364057</sub>\n<sub>LLM reason (âœ¨ experimental): Lint failure (py_lint) due to an unused import in test_wallet_anchor.py (CTransaction) flagged by ruff.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-08-28T22:52:28Z"
        },
        {
          "user": "jsarenik",
          "body": "Tested ACK 7d1c3ce7f0f0. I have compiled it and ran the script from issue #33265 with no output other than the current UTC date. Works for me.\r\n\r\nThanks!",
          "created_at": "2025-08-29T08:00:29Z"
        },
        {
          "user": "jsarenik",
          "body": "After it gets merged into `master` branch, I would recommend backporting it to current stable release branch which already contains the ephemeral outputs support ([29.x](https://github.com/bitcoin/bitcoin/blob/7cc9a087069bfcdb79a08ce77eb3a60adf9483af/doc/release-notes/release-notes-29.0.md?plain=1#L64})).",
          "created_at": "2025-08-29T12:09:41Z"
        },
        {
          "user": "instagibbs",
          "body": "@jsarenik technically this issue could happen if miners mine 0-value outputs of any kind, but given that it's now relay-possible, seems like a good idea to backport",
          "created_at": "2025-08-29T13:04:00Z"
        },
        {
          "user": "jsarenik",
          "body": "Tested ACK de98ffb",
          "created_at": "2025-08-30T18:53:48Z"
        },
        {
          "user": "achow101",
          "body": "> is `IsFromMe()` method still relevant?\r\n\r\nYes, transactions that we make are still treated specially.",
          "created_at": "2025-08-31T18:31:10Z"
        },
        {
          "user": "furszy",
          "body": "> > is `IsFromMe()` method still relevant?\r\n> \r\n> Yes, transactions that we make are still treated specially.\r\n\r\nWhere?. `IsFromMe()` seems to be only ever called in `AddToWalletIfInvolvingMe()` and `ApplyMigrationData()` next to the `IsMine()` call. In both places we effectively treat it as `is_mine = IsMine(outputs) || IsFromMe(inputs)`.",
          "created_at": "2025-08-31T18:59:22Z"
        },
        {
          "user": "achow101",
          "body": "> Where?\r\n\r\nHmm, I forgot that `CachedTxIsFromMe` does not use `IsFromMe`. Might need to change that in this PR as well.",
          "created_at": "2025-08-31T19:30:06Z"
        },
        {
          "user": "achow101",
          "body": "> Hmm, I forgot that `CachedTxIsFromMe` does not use `IsFromMe`. Might need to change that in this PR as well.\r\n\r\nI've pulled in 2 commits from #27865 which drop `CachedTxIsFromMe` and replace it with an `IsFromMe` check which is stored on disk.\r\n\r\n> In both places we effectively treat it as `is_mine = IsMine(outputs) || IsFromMe(inputs)`.\r\n\r\nWhile that's true, moving `IsFromMe` into `IsMine` does change `IsMine`'s semantics in other places, so I'm not sure that that would necessarily be correct. I think it would be better to explore that in a different PR.",
          "created_at": "2025-09-01T22:50:40Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/49358785571</sub>\n<sub>LLM reason (âœ¨ experimental): Lint Python code failure: unused variable `fee` in test_wallet_listtransactions.py (F841).</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-09-01T23:06:24Z"
        },
        {
          "user": "achow101",
          "body": "Didn't really like `m_from_me` commits, so switched the implementation to just cache \"from me\" rather than also storing it on disk.",
          "created_at": "2025-09-02T22:28:57Z"
        },
        {
          "user": "instagibbs",
          "body": "needs backport label for 30 as well?",
          "created_at": "2025-09-12T13:49:56Z"
        },
        {
          "user": "fanquake",
          "body": "Putting it into #33356 shortly.",
          "created_at": "2025-09-12T13:50:56Z"
        },
        {
          "user": "fanquake",
          "body": "Backported to `30.x` in #33356.",
          "created_at": "2025-09-12T14:00:51Z"
        },
        {
          "user": "fanquake",
          "body": "Backported to 29.x in #34268.",
          "created_at": "2026-01-13T09:44:45Z"
        }
      ]
    },
    {
      "number": 33264,
      "title": "threading: reduce the scope of lock in getblocktemplate",
      "body": "This change was motivated by https://github.com/bitcoin/bitcoin/pull/32592#discussion_r2294770722\r\n\r\nIt does exactly what is said in the comment. Reducing the scope of the lock by a bit before it is needed",
      "state": "closed",
      "user": "kevkevinpal",
      "created_at": "2025-08-28T01:20:12Z",
      "updated_at": "2025-08-28T18:35:53Z",
      "comments": 4,
      "url": "https://github.com/bitcoin/bitcoin/pull/33264",
      "labels": [],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33264.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [stickies-v](https://github.com/bitcoin/bitcoin/pull/33264#issuecomment-3233506955), [maflcko](https://github.com/bitcoin/bitcoin/pull/33264#issuecomment-3233577995) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-08-28T01:20:16Z"
        },
        {
          "user": "maflcko",
          "body": "lgtm ACK 06ec4809045f5cbe51d54e8eda08db03ca4d5ca1",
          "created_at": "2025-08-28T06:13:16Z"
        },
        {
          "user": "stickies-v",
          "body": "re-ACK 493ba0f688311280056491986068cd4a9ad2be66",
          "created_at": "2025-08-28T13:27:31Z"
        },
        {
          "user": "maflcko",
          "body": "lgtm ACK 493ba0f688311280056491986068cd4a9ad2be66",
          "created_at": "2025-08-28T13:47:24Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 33267,
      "title": "124th peer connection closed every second",
      "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Current behaviour\n\nI'm on Bitcoin Core v29.0.0\n\nI noticed that when at the max number of peers (124 total; 10 outbound; 114 inbound) the most recent peer connection is continually dropped after 1 second and another peer is selected. I can't imagine this is good behavior for the network.\n\nAs you can see, my peer count is very high (basically == number of seconds I've been at 124 peers) and the most recent peer only ever has an age of 1s.\n\n<img width=\"968\" height=\"648\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/eb770a4b-a576-41e6-9d97-13c40fb13ca0\" />\n\n### Expected behaviour\n\nI would expect the program to stop accepting connections when peers == max_peers, instead of accepting the connection and dropping it 1 second later.\n\n### Steps to reproduce\n\nLeave client running on a high speed network long enough to hit 124 peers.\n\n### Relevant log output\n\n_No response_\n\n### How did you obtain Bitcoin Core\n\nPre-built binaries\n\n### What version of Bitcoin Core are you using?\n\nv29.0.0\n\n### Operating system and version\n\nFreeBSD 14.3\n\n### Machine specifications\n\n_No response_",
      "state": "closed",
      "user": "lnxsrt",
      "created_at": "2025-08-28T12:54:28Z",
      "updated_at": "2025-08-28T13:45:54Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/issues/33267",
      "labels": [
        "P2P",
        "Questions and Help"
      ],
      "comment_list": [
        {
          "user": "0xB10C",
          "body": "This is likely normal behavior and not a bug. What you are seeing is Bitcoin Core's inbound connection eviction in action. When a new inbound connection comes in, another connection may be closed in favor of it. This avoids an attacker filling all of your inbound connections in an attempt to eclipse you from the network. The inbound eviction algorithm takes care to protect certain peers from being disconnected - you can find details [here](https://github.com/bitcoin/bitcoin/blob/6ca6f3b37b992591726bd13b494369bee3bd6468/src/node/eviction.cpp#L178). \n\n> the most recent peer connection is continually dropped after 1 second and another peer is selected. I can't imagine this is good behavior for the network.\n\nThe connection that's repeatedly dropped is probably an inbound connection from a network group (a /16 IP address range) with many existing inbound connections to you.\n\nhttps://github.com/bitcoin/bitcoin/blob/6ca6f3b37b992591726bd13b494369bee3bd6468/src/node/eviction.cpp#L238-L239\n\n> As you can see, my peer count is very high\n\nGiven you have already seen 3.2M peers, there's probably someone frequently reconnecting to your node from the same network group(s). Based on what I see at my nodes, my guess is that this is related to [LinkingLion](https://b10c.me/observations/06-linkinglion/). If the IP addresses match, you could consider banning the related subnets to avoid these connections.\n\n\n",
          "created_at": "2025-08-28T13:37:07Z"
        }
      ]
    },
    {
      "number": 33266,
      "title": "signet: disk-space-DoS due to low mining difficulty",
      "body": "Due to low mining difficulty on Signet, an attacker can grind all possible nonces of a block header and create valid[^valid], alternative headers for Signet blocks. Since these have the [same chain work](https://github.com/bitcoin/bitcoin/blob/6ca6f3b37b992591726bd13b494369bee3bd6468/src/validation.cpp#L4416) as the tip, the newly mined headers [can](https://github.com/bitcoin/bitcoin/blob/6ca6f3b37b992591726bd13b494369bee3bd6468/src/validation.cpp#L4435) be submitted along with the original block content via an unsolicited `block` P2P message. Nodes that don't prune will store these blocks indefinitely.\n\nWhen initially reported in April 2025, on average 13208298 work (hash attempts) were required to find a valid nonce on the default Signet. Now, after the difficulty on Signet was increased[^signet-difficulty-increased], [recent signet blocks](https://mempool.space/signet/block/00000012e826e2a7bfc888e43b37969c5b8aafa1bcc2b3a389c238d0ef733500) require 209338421 work on average. This results in 2^32 / 13208298 = ~325 valid headers for each block on average in April and 2^32 / 209338421 = ~20 valid headers for each block at the current Signet difficulty. An attacker can use this to fill up the disk of a Signet node.\n\nAssuming 144 Signet blocks per day and assuming a size of 500kB[^signet-blocks-size] per block, the signet disk usage increases by about 72 MB per day. An attack could have resulted in a disk-usage increase of 325 * 72 MB = 23.4 GB per day in April. With the current difficulty, it could result in a disk-usage increase of 20 * 72 MB = 1.44 GB per day.\n\nA modern laptop can grind the full 2^32 nonce space in less than 30 seconds and an attacker only needs to store the nonces to build and publish the alternative blocks. This makes the attack fairly trivial to exploit. \n\nCredit goes to @stwenhao for initially reporting this in a fork-observer [issue]( https://github.com/0xB10C/fork-observer/issues/61). The attack can be detected via `getchaintips` and e.g. tools like fork-observer. The alternative blocks show up as `valid-headers`. No reorg happens as the original block remains the active tip (since it was seen first).\n\n<img width=\"3169\" height=\"954\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/386d2490-f037-4885-a083-dc2bc3803bba\" />\n\nThe attack is possible on all networks that require less than 2^32 work to find blocks. Pruned nodes are not affected as the alternative blocks are removed at some point. I'm opening this issue is to document this somewhere visible. I don't think there's action required for the default Signet at this point since the difficulty has already been increased and the attack is less effective there now. If this becomes a problem again, the best mitigation is probably to further increase the difficulty. Other public signets (e.g. Mutinynet) might want to consider increasing the mining difficulty too.\n\n[^valid]: Signet blocks commit to the header version, prevhash, merkleroot, and timestamp. These can't be changed. Only the nonce can be changed to produce valid, alternative headers. \n[^signet-blocks-size]:  filling Signet blocks with transactions is possible for *free*, but blocks seem to be limited to 1 MWU. Consistently making 500 kB blocks seems to be possible for an attacker \n[^signet-difficulty-increased]: The Signet difficulty was increased at the end of April 2025 in response to a private report.<img width=\"400\" height=\"150\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/15f1888c-3cd7-4409-a4f0-ff5f53fbc0bd\" />\n\n",
      "state": "open",
      "user": "0xB10C",
      "created_at": "2025-08-28T12:38:43Z",
      "updated_at": "2026-01-14T20:54:08Z",
      "comments": 11,
      "url": "https://github.com/bitcoin/bitcoin/issues/33266",
      "labels": [
        "Bug",
        "Resource usage"
      ],
      "comment_list": [
        {
          "user": "jsarenik",
          "body": "Would such blocks mined by anyone even be considered valid on signet since they would not contain any expected valid signature?\n\nOn signet there's an \"Additional consensus requirement that the coinbase witness commitment contains an extended signet commitment, which is a script satisfying the block script (usually a k-of-n multisig)\" (see [bitcoin.it documentation on Signet Differences](https://en.bitcoin.it/wiki/Signet#Differences)). Maybe the in-repo documentation is not clear?",
          "created_at": "2025-08-29T12:31:05Z"
        },
        {
          "user": "0xB10C",
          "body": "> Would such blocks mined by anyone even be considered valid on signet since they would not contain any expected valid signature?\n\nYes. Just the nonce in the block header changes. The signet commitment commits to the header version, prevhash, merkleroot, and timestamp. It does not commit (and can not commit) to the nonce. The underlying block does not change. The commitment remains valid.",
          "created_at": "2025-08-29T17:42:56Z"
        },
        {
          "user": "stwenhao",
          "body": "> It does not commit (and can not commit) to the nonce.\n\nI agree, that it does not commit to the nonce. But if that would be needed, then it could. An example of a situation, where things are signed, but where nonce is included in signed commitment, is what I deployed as a Proof of Work puzzle: https://bitcointalk.org/index.php?topic=5551080.0\n\nOr, a similar case is recently deployed Optional Hourglass: https://bitcointalk.org/index.php?topic=5557305.0\n\nIn that cases, the signature can sign everything (for example, nSequence and nLockTime is signed, and both can be used as nonces during mining). And also, signatures can sign less things, by using different sighashes, for example here: https://mempool.space/tx/8349df0753e80cce322322f1b76789e1d0fd6693aed2f4de4e49576423081ae7\n\nSo, I can imagine a perfectly valid Signet challenge, where the size of the signature will be restricted somehow, where it would use different sighashes, than SIGHASH_ALL, or where miners would grind DER signatures, instead of grinding regular 80-byte block headers.\n\nTo sum up: the current design of Signet allows attacking, by changing nonces into different values. But that attack can be trivially stopped, just by making sure, that for a given signed header, there is only one nonce, meeting a given difficulty (which means always checking all 2^32 nonces for each submitted header).\n\nBut, future signets can use a different model, where they could entirely avoid such problems, and work with much smaller difficulty. Imagine taking this signet challenge:\n```\n1 <pubkeyAlice> <pubkeyBob> 2 OP_CHECKMULTISIG\n```\nAnd turning it into this instead:\n```\nOP_SIZE 61 70 OP_WITHIN OP_VERIFY\nOP_CODESEPARATOR\n1 <pubkeyAlice> <pubkeyBob> 2 OP_CHECKMULTISIG\n```\nOf course, because the Script from signet challenge can change the signed transaction ID, this is incompatible with currently deployed network. However, I can imagine a soft-fork on top of signet, where signatures would be required to be smaller, than they are, and where Proof of Work will be counted, by checking the signature, rather than by checking the hash in the block header. And then, block headers could have even regtest difficulty, if consensus rules would still require grinding something else (that could commit to the block header nonce, and difficulty as well).\n\nEdit: Also, there are many possible trivial fixes. For example, if each nonce will be restricted by consensus rules to be less than 0x00010000, then it could work, and it would be trivial, to check all 2^16 values, instead of 2^32.",
          "created_at": "2025-08-30T20:51:55Z"
        },
        {
          "user": "jsarenik",
          "body": "What about a safety one-liner fix which would not allow new block to have the same blockheader (except nonce) than an already mined block? Such a local-node \"soft-fork\" would be possible even without telling anyone network-wise.\n\nAn attack block could come only _after_ a new unique mined&signed block header was announced.",
          "created_at": "2025-08-31T04:44:16Z"
        },
        {
          "user": "stwenhao",
          "body": "> What about a safety one-liner fix which would not allow new block to have the same blockheader (except nonce) than an already mined block?\n\nAs long as you know, which block was propagated first, then you can do that. But note that signet block producers can decide to build things on top of any block, including something, which was grinded by some attacker. If you see two or more blocks with different nonces, at the same height N, then you don't know, what block number N+1 will sign (and also, it can sign all versions, and leave it up to the miners).\n\n> Such a local-node \"soft-fork\" would be possible even without telling anyone network-wise.\n\nYes, but if your node joined the network recently, then you don't know, if the block you heard from someone is the earliest one, that was broadcasted. You only know that, if something was created on top of it. Which means, that there is always a risk to see a single block being reorged, if you pick it wrong.\n\nEdit: Also note, that the default signet challenge is 1-of-2 multisig. Which means, that you can have for example two different nodes, making signatures for two different public keys. Both nodes can be connected to the same network, but they don't have to maintain a direct P2P connection. Which means, that if you have one signet miner, and another signet miner, and there are some attackers in the middle, then they can capture the real block, grind it (also with ASICs, because why not), and share different headers with different nodes.",
          "created_at": "2025-08-31T05:01:35Z"
        },
        {
          "user": "0xB10C",
          "body": "My impression is that just increasing the difficulty on a public Signet should be enough and would avoid this issue without needing a (signet only) (consensus) code change. It doesn't even need to be difficulty 1 (i.e. 2^32 work) - similar to the default signet only requiring 5% of work at the risk of 19 alternative blocks per tip. The attack is easily detectable and if exploited over a long period of time, the signet admin can further increase the difficulty at any time. Alternatively, publishing new blocks in batches ensures an attacker doesn't have enough time to mine alternatives for each tip.\n\nIt probably needs some documentation though: Either run your public signet with a high enough difficulty or risk being disk-space DoSed by some script kiddy. After all, it's only a test network. \n\nAFAIK, so far nobody else bothered to mine alternative blocks on the default signet and neither on Mutinynet where it is/was trivial to grow the chain by 100GB per day (https://github.com/MutinyWallet/mutiny-net/pull/4).\n\n ",
          "created_at": "2025-09-05T12:36:38Z"
        },
        {
          "user": "stwenhao",
          "body": "> and would avoid this issue without needing a (signet only) (consensus) code change.\n\nYes, but signet-only consensus code change can be beneficial. If your difficulty requires grinding 2^20 hashes, then I think nonce values should be masked, to make sure, that upper bits are set to zero. Then, if the difficulty will increase, the code can automatically raise that barrier, so that the nonce restrictions will be active only for difficulties requiring less than 2^32 hashes.\n\nBecause if you need to grind for example 2^16 hashes, then it is more realistic, if your nonce is also masked with 0x0000ffff. After all, miners constantly check a lot of different block headers, and they tweak version bits, timestamps, or change merkle roots. Restricting the nonce would mimic that behaviour for signets.",
          "created_at": "2025-09-05T13:33:45Z"
        },
        {
          "user": "benthecarman",
          "body": "@stwenhao i don't think restricting the nonce adds any meaningful protection. The attacker can also use the merkle root as a nonce field because they do not need to actually include txs. If you limit the nonces, they can just change the merkle root until they find a block ",
          "created_at": "2025-09-22T14:21:45Z"
        },
        {
          "user": "0xB10C",
          "body": "> [@stwenhao](https://github.com/stwenhao) i don't think restricting the nonce adds any meaningful protection. The attacker can also use the merkle root as a nonce field because they do not need to actually include txs. If you limit the nonces, they can just change the merkle root until they find a block\n\nThe signet solution commits to the merkleroot. Changing it will produce invalid Signet blocks:\n\nhttps://github.com/bitcoin/bitcoin/blob/953544d0286ba35dd1b07fe1921c573cba4703cf/src/signet.cpp#L112-L117",
          "created_at": "2025-09-22T14:29:11Z"
        },
        {
          "user": "jsarenik",
          "body": "Does this issue relate at all to the fixed CVE-2025-54604 - Disk filling from spoofed self connections in https://github.com/bitcoin/bitcoin/pull/32604 ?\n\nhttps://bitcoincore.org/en/2025/10/24/disclose-cve-2025-54604/",
          "created_at": "2025-12-19T11:32:28Z"
        },
        {
          "user": "maflcko",
          "body": "> Does this issue relate at all to the fixed [CVE-2025-54604](https://github.com/advisories/GHSA-6wcj-m5m4-hw9r) - Disk filling from spoofed self connections in [#32604](https://github.com/bitcoin/bitcoin/pull/32604) ?\n> \n> https://bitcoincore.org/en/2025/10/24/disclose-cve-2025-54604/\n\nI think the two are separate:\n\n* One is about rate limiting all logs, so that the persisted `debug.log` file does not grow in size too fast.\n* This one is about creating and persisting blocks to the `block*.dat` files, and how it can be worked around by a higher difficulty.",
          "created_at": "2025-12-19T11:51:17Z"
        }
      ]
    },
    {
      "number": 33265,
      "title": "Zero output not cleared",
      "body": "I think this relates to https://github.com/bitcoin/bitcoin/issues/27463, fyi @instagibbs \n\nWorking on a clear reproduction script for regtest, but here are some preliminary notes and signet examples:\n\nThe script (network-less) is `51024e73`. It `decode`s to different addresses for mainnet, testnets (including signets) and regtest:\n\n * `bc1pfeessrawgf` - mainnet\n * `tb1pfees9rn5nz` - testnets (incl. signets)\n * `bcrt1pfeesnyr2tx` - regtest\n\nThis LN Anchor address is important because such transactions were noticed on signet. See examples of leftover outputs which were spent:\n\n * [67da00b7e55c249ed338618bf7caea128365c2a35c77da5abb379e8574e537a5](https://mempool.space/signet/tx/67da00b7e55c249ed338618bf7caea128365c2a35c77da5abb379e8574e537a5)\n * [571be0fd823de6bd1c3bc9a7349297aacc7ce73bd99638b53e381aa1651f570c](https://mempool.space/signet/tx/571be0fd823de6bd1c3bc9a7349297aacc7ce73bd99638b53e381aa1651f570c)\n\nThese outputs can be seen as still available on current master (6ca6f3b37b99) on signet network.\nJust import following read-only descriptor wallet:\n\n```sh\n#!/bin/sh\n### start a fresh signet daemon, moving old signet datadir\n#bitcoin-cli -signet stop\n#test -d ~/.bitcoin/signet-old || mv ~/.bitcoin/signet ~/.bitcoin/signet-old\n#mkdir -p ~/bitcoin/signet/wallets\nbitcoind -signet -daemon 2>/dev/null\n\n### adjust or enhance lines above and see also your bitcoin.conf\n\nuntil bitcoin-cli -signet echo hello 2>/dev/null | grep -q .\ndo\n  sleep 1\ndone\n\ncd ~/.bitcoin/signet/wallets\ntest -d lnanchor && cd lnanchor || {\n  bitcoin-cli -signet createwallet lnanchor true true\n  bitcoin-cli -signet -rpcwallet=lnanchor \\\n   importdescriptors '[{\"desc\":\"addr(tb1pfees9rn5nz)#8njps4hg\",\"timestamp\":\"now\"}]'\n}\nph=$(bitcoin-cli -signet getblockchaininfo | grep pruneheight | tr -cd '[0-9]')\nbitcoin-cli -signet loadwallet lnanchor\nbitcoin-cli -signet -rpcwallet=lnanchor rescanblockchain $ph\n\nlist() {\n  bitcoin-cli -signet -rpcwallet=lnanchor \\\n    listunspent ${1:-0} \\\n    | grep -w -e txid -e vout -e amount -e confirmations -e safe \\\n    | tr -d ' ,\"' \\\n    | cut -d: -f2 \\\n    | paste -d \" \" - - - - - \\\n    | sort -nk4\n}\n\nwhile true; do LC_ALL=C date -u; list; sleep 1; done\n```\n\nThe script works both on an already-synced signet and a newly-syncing (uncomment lines in the top) one. Soon something like the following output may be seen and feel free to press `^C` then:\n\n```\n...\nThu Aug 28 15:16:09 UTC 2025\na7b388a8f48350f92f8987d45409723bf329519816eba808de59ad6ebe974628 2 0.00000000 127 true\n571be0fd823de6bd1c3bc9a7349297aacc7ce73bd99638b53e381aa1651f570c 2 0.00000000 128 true\n06df913b8fb0fc39dac875d1b5c4cc948499ed6e3dca6d2867afc59435e66a6f 2 0.00000000 129 true\ne5cf85120935082b14889674d5c4ed66d8bfce3b8e9c0eebc9d4dea079de01d9 1 0.00000000 131 true\n6faa9ecf8b2c0afd657a32f50d5d93d91d33a578bd8fdd2ef4d960dea2a1bfb7 2 0.00000000 221 true\n85518747043d2bf36418f6262b6a8d35593bf8d2419250448f8cb5cbeab0d5d0 2 0.00000000 251 true\n24e532f648b951376f2cef53b8c07d1e0b1fd0652a257a62968988f31c4aca26 2 0.00000000 269 true\n851248a635cb25d00dd39665636a3208c7252f059cfa418d43bf55535c283a5b 1 0.00000000 272 true\na69bdd445aa6f82798c745792268cad4cbb2c2dd2e7a32809ee94bce51c26de5 2 0.00000000 273 true\n82779ab667f82ec42f4a7c561da5fab7952e32bf7215ba6d19a2e4fe22ab44a6 1 0.00000000 579 true\ne67aebeb09f64b1fec0177bc1b1edf336f8a31df7f264a3d83db2c2b1ebd7bb7 2 0.00000000 602 true\n67da00b7e55c249ed338618bf7caea128365c2a35c77da5abb379e8574e537a5 2 0.00000000 673 true\n6acce19b0418360f9e0c1650d2267fad6761dd0e98a2da23739b62ebfaa5cb00 2 0.00000000 675 true\nea0522ba8f4ada4d3770f0d81c212bb0f7da25235e2b8b57c04e90c96b5b598c 2 0.00000000 691 true\nd24a3e60de8ccf95fc4dfa1d6efc9c5f77100d058d1fceccba40d6a54d1a02f2 1 0.00000000 738 true\n0378f0bc23d0cdbc7afe01dbfe77e4b925fa2c426a75509590ccd9f970ca288f 2 0.00000000 817 true\n19b091d8653165fda6ac25f231b6afdaba3a35a4199fa39952ae63de16c08f04 2 0.00000000 818 true\nbcb0311b7d3e78f636319ebb483e36cde5162545b7fc94df7cd4185112d7d712 2 0.00000000 832 true\n13e541ef82d52ca1010b09990f28230cfd57ab54cccd7e7fbf427a05d66d515f 1 0.00000000 833 true\n30f1fcc25b066c63f01b3b0588448bc285713d12c320d0505ac38a2aa96aaa8f 1 0.00000000 834 true\n```\n\nLet's take the [first transaction (...4628)](https://mempool.space/signet/tx/a7b388a8f48350f92f8987d45409723bf329519816eba808de59ad6ebe974628) and its [follow-up which spends the zero output](https://mempool.space/signet/tx/92246e21897116e7e7b9afc62034caaadb75ae61c441c52df4a66dbdd9e234f5). The latter can not be traced from the former on mempool.space other than checking [the LN Anchor address](https://mempool.space/signet/address/tb1pfees9rn5nz).\n\nI would expect the zero output to be cleared in the descriptor wallet no matter if the spending transaction has anything to do with the first transaction in a package other than the zero output itself.",
      "state": "closed",
      "user": "jsarenik",
      "created_at": "2025-08-28T10:35:27Z",
      "updated_at": "2025-09-12T13:42:13Z",
      "comments": 4,
      "url": "https://github.com/bitcoin/bitcoin/issues/33265",
      "labels": [
        "Wallet"
      ],
      "comment_list": [
        {
          "user": "instagibbs",
          "body": "thanks, hit me up when you reproduce it; I am having trouble disintangling if the issue is P2A, TRUC,  ephemeral dust, or something else. ",
          "created_at": "2025-08-28T13:14:09Z"
        },
        {
          "user": "jsarenik",
          "body": "The linked transactions ([...4628](https://mempool.space/signet/tx/a7b388a8f48350f92f8987d45409723bf329519816eba808de59ad6ebe974628) and [...34f5](https://mempool.space/signet/tx/92246e21897116e7e7b9afc62034caaadb75ae61c441c52df4a66dbdd9e234f5)) in annotated raw:\n\n```\nVERSION: 03000000\nFLAG: 0001\nINPUTS: 01\n 0c571f65a11a383eb53896d93be77cccaa979234a7c93b1cbde63d82fde01b57 01000000 00 00000000 #I-0\nOUTPUTS: 03 #0..2\n e803000000000000 22 5120db7b995709b105a12719e1b4d92ab4bb616805fe0e2aee2db4b86efb64041b69 #O-0\n e803000000000000 22 512036a0c6a87cc73eab25ab672af73f4c766c38d3525844c2dca90f57c1308c39f3 #O-1\n 0000000000000000 04 51024e73 #O-2\nWITNESS:\n 01 40 b0d664a1ab0e68ff57a35b2c23008f1bea28143d0be8caf048e69ff6fda633a16d65e2771c2988a3e2fb3ece118ecde205fea3d9f9d8f37e68da4cead332f348 #W-0\nLOCKTIME: 00000000\n```\n\n```\nVERSION: 03000000\nFLAG: 0001\nINPUTS: 02 #0..1\n 284697be6ead59de08a8eb16985129f33b720954d487892ff95083f4a888b3a7 02000000 00 ffffffff #I-0\n f534e2d9bd6da6f42dc541c461ae75dbaaca3420c6afb9e7e7167189216e2492 00000000 00 fdffffff #I-1\nOUTPUTS: 01\n ef04000000000000 22 51202924f1b0e89d6c495cc3334b06d38163e4e6f7fa9a5dc416a92953f6189854fe #O-0\nWITNESS:\n 00 #W-0\n 01 40 47de320ab28aa6fbf0f3a96ae6b425f6b5f8addeb88dde3cd5e2d6a5d2bb58b9935265b34bd700438b2d1889e0d8b9d411f5898a7b1cdc9577da71f8f69bdcaf #W-1\nLOCKTIME: c0120400\n```\n\nThe latter's second input is the `LittleEndian_txid` of the former transaction.\n\nThere just came a most-recent package on [signet LN Anchor](https://mempool.space/signet/address/tb1pfees9rn5nz): [first (zero-fee)](https://mempool.space/signet/tx/e194853f2e62d131fe3fbd46b32c41369a5aebce0253c505746762f236cda6c6) and [second (fee-paying spend)](https://mempool.space/signet/tx/79150ca6cd730f2f68e6b6cd1580bcea36acd4d3295b1505681fb69ab4f4feb7)\n\nEDIT: the most-recent package (see above) seems to not case the same zero output leftover in the wallet. Let's see the main difference:\n\n```\nVERSION: 03000000\nFLAG: 0001\nINPUTS: 01\n 90c251d4a52f62f248511ab090632c0e017b3dab77462070956c6ca6d9dd3c99 00000000 00 00000000 #I-0\nOUTPUTS: 02 #0..1\n a086010000000000 22 5120f9f8a765e492ce7341d639980a3e31e673cd2dee2166efebc8aa400852e1d923 #O-0\n 0000000000000000 04 51024e73 #O-1\nWITNESS:\n 01 40 53debe230b68bc2b708f142fd420de1d4135e08b525ab0ca8e228eaafcf32c579d95dbc69721d918b57dcee4255766af8905fc66ca47902659fcf144f50e670d #W-0\nLOCKTIME: 00000000\n```\n\n```\nVERSION: 03000000\nFLAG: 0001\nINPUTS: 02 #0..1\n c6a6cd36f262677405c55302ceeb5a9a36412cb346bd3ffe31d1622e3f8594e1 01000000 00 ffffffff #I-0\n 5bfda7cab1d363326218186f2d3e391ee1db14200d1b5564e748c52fe5fe3c99 01000000 00 fdffffff #I-1\nOUTPUTS: 01\n 8b85010000000000 22 5120f78d6ea4fd2f5f996867e97ab99c9ca552e3b67caa1e59da328a76f0f5a9bfc1 #O-0\nWITNESS:\n 00 #W-0\n 01 40 f3f2fd33508fc137602da150a4cecf92f9acbb83d6737754abf1b93d26ecd537e41e1c6437766128be6fb585e6fb785ed1a0b7cf79293576ccd948e360694ef1 #W-1\nLOCKTIME: 5b130400\n```",
          "created_at": "2025-08-28T15:12:38Z"
        },
        {
          "user": "jsarenik",
          "body": "From observation the important thing triggering the leftover (but spent, i.e. unusable) zero output inside a read-only descriptor wallet seem to be the two outputs to two different addresses in the final spend transaction. See https://mempool.space/signet/tx/af914f3f337bc84910d1d2d5d14556e5c2b07372ea99078d15c7a74c77c0b0e7?mode=details\n\nAlso see https://signet257.bublina.eu.org/sffrest.txt which may contain such transactions in the end of its output:\n\n<img width=\"1080\" height=\"1674\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/328d753a-5140-4249-beda-44ec9d4977b4\" />\n\nAnt the same snapshot in plain-text:\n\n```\n+ wc -l\n+ safecat.sh /dev/shm/sffrest.txt\n+ ls -1 /tmp/sffrest/\n+ wc -l\n+ myrest=2\n+ ls -1 /tmp/sff-s3/\n+ wc -l\n+ myst=19\n+ echo rest 2 stage3 19\nrest 2 stage3 19\n+ echo finn\nfinn\n+ rmdir /tmp/locksff\n+ exit 0\nThu Aug 28 16:51:27 UTC 2025\n24K\t/dev/shm/wallets-signet/lnanchor\n1.6M\t/dev/shm/wallets-signet/newmy5909\n24K\t/dev/shm/wallets-signet/optrue\nBitcoin Core daemon version v29.99.0-56f7433ded8d\n\nAll current LN Anchor outputs seen by this node:\n# txid vout amt conf safe\n96599c7733f2ac4464707c43b1a9ec3dfccbfbb34a6bc7ff25cde695de43670c 2 0.00000000 7 true\naf914f3f337bc84910d1d2d5d14556e5c2b07372ea99078d15c7a74c77c0b0e7 2 0.00000000 8 true\ne194853f2e62d131fe3fbd46b32c41369a5aebce0253c505746762f236cda6c6 1 0.00000000 9 true\n```",
          "created_at": "2025-08-28T17:03:22Z"
        },
        {
          "user": "achow101",
          "body": "This seems like it's because the check for whether a transaction is \"from\" the wallet is if it a non-zero amount leaves the wallet. Since these outputs are 0 value, they are definitionally do not meet that criteria.",
          "created_at": "2025-08-28T20:29:39Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 2,
    "issues": 3
  }
}