{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T19:26:17.067058+00:00",
  "date": "2025-03-20",
  "pull_requests": [
    {
      "number": 32104,
      "title": "refactor: Enforces Txid and Wtxid types in RelayTransaction",
      "body": "RelayTransaction expects to pass a TxId and Wtxid as arguments, but any uint256 type is really accepted. When calling RelayTransaction, most times we are already passing tx->GetHash() and  tx->GetWitnessHash() to it, and their value are downcasted.\r\n\r\nUpdates RelayTransaction and make sure we are consistent with its arguments",
      "state": "closed",
      "user": "sr-gi",
      "created_at": "2025-03-20T15:12:30Z",
      "updated_at": "2025-04-10T15:54:39Z",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/pull/32104",
      "labels": [
        "Refactoring"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32104.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#32189](https://github.com/bitcoin/bitcoin/pull/32189) (refactor: Txid type safety (parent PR) by marcofleon)\n* [#30277](https://github.com/bitcoin/bitcoin/pull/30277) ([DO NOT MERGE] Erlay: bandwidth-efficient transaction relay protocol (Full implementation) by sr-gi)\n* [#30116](https://github.com/bitcoin/bitcoin/pull/30116) (p2p: Fill reconciliation sets (Erlay) attempt 2 by sr-gi)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n* [#29415](https://github.com/bitcoin/bitcoin/pull/29415) (Broadcast own transactions only via short-lived Tor or I2P connections by vasild)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
          "created_at": "2025-03-20T15:12:34Z"
        },
        {
          "user": "fanquake",
          "body": "cc @marcofleon & #31001.",
          "created_at": "2025-03-21T02:22:44Z"
        },
        {
          "user": "sr-gi",
          "body": "Oh, I didn't realize Marco was already working on this. I saw this when updating the Erlay PR and thought it may be good to standalone fix. I'm happy to close it if you're planning to get it addressed @marcofleon ",
          "created_at": "2025-03-21T02:29:46Z"
        },
        {
          "user": "marcofleon",
          "body": "Lgtm as a standalone change. It's the same change I implement in fa8400494e3c411a55375e71abaaa2637a22e216 as part of the complete refactor. I actually missed all the `tx.GetHash()` and `tx.GetWitnessHash()` in `ProcessMessage` so good catch there.\r\n\r\nMy [final refactor](https://github.com/bitcoin/bitcoin/compare/master...marcofleon:bitcoin:workingtxidtypesafety) does end up altering `RelayTransaction` in a more involved way, but that includes changes (switching `GenTxid` to a variant) that haven't been discussed yet. I'll open a draft PR of that branch this week.",
          "created_at": "2025-03-24T18:49:49Z"
        },
        {
          "user": "sr-gi",
          "body": "Closing in favor of #32189",
          "created_at": "2025-04-10T15:54:38Z"
        }
      ]
    },
    {
      "number": 32103,
      "title": "ci: run test-each-commit on merge to master",
      "body": "Previously this CI job was checking out the head ref, which meant it is **not** being run on the result of merging into master.\r\n\r\nUse the default checkout action `ref` (merge into default branch) to avoid this. Increment the checkout depth to HEAD~~ to compensate for the new merge commit.\r\n\r\nThis would have likely helped avoid both failures reported in #31946, and seems to me to be a more robust way of running this test job in any case.\r\n\r\n(Probably) closes: #31946\r\n\r\ncc @maflcko: Is there a historical reason I'm missing here why a merge-checkout was not chosen for this job in fafcd2e9ef1209d614de5763a2733098537919dd?",
      "state": "closed",
      "user": "willcl-ark",
      "created_at": "2025-03-20T13:13:27Z",
      "updated_at": "2025-04-02T17:21:32Z",
      "comments": 8,
      "url": "https://github.com/bitcoin/bitcoin/pull/32103",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32103.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
          "created_at": "2025-03-20T13:13:30Z"
        },
        {
          "user": "willcl-ark",
          "body": "> It looks like you are trying to change the task to test changes merged into master to avoid running into issues fixed previously.\r\n\r\nCorrect. Whilst we can try to rely on developers keeping up-to-date with rebases on master it seems less error-prone to do it as part of the task.\r\n\r\n> However, you check out the previous commit, so overall this change is a no-op , unless I am missing something?\r\n> \r\n> Maybe you wanted to instead _rebase_ the changes onto master? However, this is not possible in general, as some commits are not possible to rebase. For example, a subtree merge commit is not possible to rebase.\r\n\r\nYes you're right, I think the correct checkout command would in fact be `git checkout HEAD^2` as `HEAD~~` does indeed skip back to the previous merge commit, which is not what was intended here. AFAIK a merge would work with a subtree merge commit?\r\n\r\n> Also, the goal of this check is to find bisect errors early, so the whole point is to run on the original changes, not merged into master.\r\n> \r\n> Thinking about alternative fixes, obviously the best fix would be to not have any intermittent issues. Absent that, it would be good for devs to rebase on latest master if they want to ensure the CI gets all the latest fixes. Alternatively, failures in this task could be ignored or the task could be re-run.\r\n\r\nFair enough. Ignoring failures in this task seems a little sub-optimal to me though.\r\n\r\nAnother alternative could be to auto-prompt a rebase on failure, something like:\r\n\r\n<details>\r\n<summary>Details</summary>\r\n\r\n```diff\r\ndiff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml\r\nindex 4f0ed47b951..9e75bf0a258 100644\r\n--- a/.github/workflows/ci.yml\r\n+++ b/.github/workflows/ci.yml\r\n@@ -69,11 +69,18 @@ jobs:\r\n           sudo apt-get update\r\n           sudo apt-get install clang ccache build-essential cmake pkgconf python3-zmq libevent-dev libboost-dev libsqlite3-dev libdb++-dev systemtap-sdt-dev libzmq3-dev qtbase5-dev qttools5-dev qttools5-dev-tools qtwayland5 libqrencode-dev -y\r\n       - name: Compile and run tests\r\n+        id: run_tests\r\n         run: |\r\n           # Run tests on commits after the last merge commit and before the PR head commit\r\n           # Use clang++, because it is a bit faster and uses less memory than g++\r\n           git rebase --exec \"echo Running test-one-commit on \\$( git log -1 ) && CC=clang CXX=clang++ cmake -B build -DWERROR=ON -DWITH_ZMQ=ON -DBUILD_GUI=ON -DBUILD_BENCH=ON -DBUILD_FUZZ_BINARY=ON -DWITH_BDB=ON -DWITH_USDT=ON -DCMAKE_CXX_FLAGS='-Wno-error=unused-member-function' && cmake --build build -j $(nproc) && ctest --output-on-failure --stop-on-failure --test-dir build -j $(nproc) && ./build/test/functional/test_runner.py -j $(( $(nproc) * 2 )) --combinedlogslen=99999999\" ${{ env.TEST_BASE }}\r\n \r\n+      - name: Suggest rebase\r\n+        if: failure() && steps.run_tests.outcome == 'failure'\r\n+        run: |\r\n+          echo \"If you haven't already, please try rebasing your branch on the latest master\"\r\n+          exit 1\r\n+\r\n   macos-native-arm64:\r\n     name: ${{ matrix.job-name }}\r\n     # Use any image to support the xcode-select below, but hardcode version to avoid silent upgrades (and breaks).\r\n```\r\n\r\n</details>\r\n\r\n\r\nBut it sounds like it would be best to close this (and #31946 ? ) ?\r\n",
          "created_at": "2025-03-20T14:45:04Z"
        },
        {
          "user": "maflcko",
          "body": "> > It looks like you are trying to change the task to test changes merged into master to avoid running into issues fixed previously.\r\n> \r\n> Correct. Whilst we can try to rely on developers keeping up-to-date with rebases on master it seems less error-prone to do it as part of the task.\r\n\r\nIt is possible to write code in a commit that compiles fine on master, but not when compiling the commit itself. (The reverse of a silent merge conflict) Though, there only was one instance of this. More likely would be that devs are wholesale not compiling/testing intermediate commits, which would also be covered if the changes are \"rebased\".\r\n\r\n\r\n\r\n> Yes you're right, I think the correct checkout command would in fact be `git checkout HEAD^2` as `HEAD~~` does indeed skip back to the previous merge commit, which is not what was intended here. AFAIK a merge would work with a subtree merge commit?\r\n\r\nI think what you want is to checkout each old commit and then merge it (inside the CI task) with master. Not sure how to achieve it otherwise. Maybe you can share your steps to reproduce with `git`?\r\n\r\n\r\n\r\n> Fair enough. Ignoring failures in this task seems a little sub-optimal to me though.\r\n> \r\n> Another alternative could be to auto-prompt a rebase on failure, something like:\r\n> Details\r\n> But it sounds like it would be best to close this (and https://github.com/bitcoin/bitcoin/issues/31946 ? ) ?\r\n\r\n\r\nYeah, I meant \"manually ignoring\", not silently ignoring the return code. :sweat_smile: \r\n\r\nOther than that, no strong opinion. I think anything is fine.",
          "created_at": "2025-03-20T14:52:28Z"
        },
        {
          "user": "maflcko",
          "body": "> I think what you want is to checkout each old commit and then merge it (inside the CI task) with master. Not sure how to achieve it otherwise. Maybe you can share your steps to reproduce with `git`?\r\n\r\nTo clarify, my suggestion would be to modify the `git rebase --exec 'run_test' base` into `git rebase --exec 'git log -1 && git merge --no-commit master && echo run_test && git merge --abort' base`. However, I haven't tested this.",
          "created_at": "2025-03-20T16:10:06Z"
        },
        {
          "user": "willcl-ark",
          "body": "> > I think what you want is to checkout each old commit and then merge it (inside the CI task) with master. Not sure how to achieve it otherwise. Maybe you can share your steps to reproduce with `git`?\r\n> \r\n> To clarify, my suggestion would be to modify the `git rebase --exec 'run_test' base` into `git rebase --exec 'git log -1 && git merge --no-commit master && echo run_test && git merge --abort' base`. However, I haven't tested this.\r\n\r\nWould it not in that case be simpler to checkout the PR `HEAD` commit, fetch and rebase onto master, before doing a more \"normal\" rebase from the `MERGE_BASE`? Something like:\r\n\r\n```bash\r\n#!/usr/bin/env bash\r\nset -x\r\n\r\ngit switch master\r\n\r\n# Create a dummy branch with a few empty commits\r\ngit switch -c dummy-branch\r\nfor i in {1..5}; do\r\n    git commit --allow-empty -m \"empty commit $i\"\r\ndone\r\n\r\n# This state we are in here currently is the same as the PR HEAD commit we currently check out\r\n\r\n# Rebase these commits onto latest master (origin in the CI, may be upstream locally)\r\ngit pull --rebase origin master\r\ngit log --oneline -n7\r\n\r\n# This checks out \"empty commit 4\"\r\ngit checkout HEAD~\r\nMERGE_BASE=$(git rev-list -n1 --merges HEAD)\r\nEXCLUDE_MERGE_BASE_ANCESTORS=\r\n\r\n# MERGE_BASE can be empty due to limited fetch-depth\r\nif test -n \"$MERGE_BASE\"; then\r\n    EXCLUDE_MERGE_BASE_ANCESTORS=^${MERGE_BASE}^@\r\nfi\r\nTEST_BASE=$(git rev-list -n7 --reverse HEAD \"$EXCLUDE_MERGE_BASE_ANCESTORS\" | head -1)\r\n\r\necho would run: git rebase --exec \"echo Running test-one-commit on \\$( git log -1 ) && CC=clang CXX=clang++ cmake -B build -DWERROR=ON -DWITH_ZMQ=ON -DBUILD_GUI=ON -DBUILD_BENCH=ON -DBUILD_FUZZ_BINARY=ON -DWITH_BDB=ON -DWITH_USDT=ON -DCMAKE_CXX_FLAGS='-Wno-error=unused-member-function' && cmake --build build -j $(nproc) && ctest --output-on-failure --stop-on-failure --test-dir build -j $(nproc) && ./build/test/functional/test_runner.py -j $(( $(nproc) * 2 )) --combinedlogslen=99999999\" \"$TEST_BASE\"\r\n\r\ngit branch -D dummy-branch\r\n\r\n```\r\n\r\nThis gets the following log output for me, which appears to be at least what I would expect this CI job to be doing:\r\n\r\n<details>\r\n<summary>Details</summary>\r\n\r\n```bash\r\n$ ./checkout.sh\r\n+ git switch master\r\nAlready on 'master'\r\nYour branch is up to date with 'origin/master'.\r\n+ git switch -c dummy-branch\r\nSwitched to a new branch 'dummy-branch'\r\n+ for i in {1..5}\r\n+ git commit --allow-empty -m 'empty commit 1'\r\n[dummy-branch 58ecc5950e8] empty commit 1\r\n\r\n<snip>\r\n\r\n+ git pull --rebase origin master\r\nFrom https://github.com/willcl-ark/bitcoin\r\n * branch                    master     -> FETCH_HEAD\r\nCurrent branch dummy-branch is up to date.\r\n+ git log --oneline -n7\r\naf33d1bef61 (HEAD -> dummy-branch) empty commit 5\r\n82be04b802c empty commit 4\r\n7f0435dc544 empty commit 3\r\nd82729928f9 empty commit 2\r\n58ecc5950e8 empty commit 1\r\n998386d4462 (upstream/master, upstream/HEAD, origin/master, master) Merge bitcoin/bitcoin#31866: test, refactor: Add TestNode.binaries to hold binary paths\r\naa87e0b4460 Merge bitcoin/bitcoin#31519: refactor: Use std::span over Span\r\n+ git checkout HEAD~\r\nHEAD is now at 82be04b802c empty commit 4\r\n++ git rev-list -n1 --merges HEAD\r\n+ MERGE_BASE=998386d4462f5e06412303ba559791da83b913fb\r\n+ EXCLUDE_MERGE_BASE_ANCESTORS=\r\n+ test -n 998386d4462f5e06412303ba559791da83b913fb\r\n+ EXCLUDE_MERGE_BASE_ANCESTORS='^998386d4462f5e06412303ba559791da83b913fb^@'\r\n++ git rev-list -n7 --reverse HEAD '^998386d4462f5e06412303ba559791da83b913fb^@'\r\n++ head -1\r\n+ TEST_BASE=998386d4462f5e06412303ba559791da83b913fb\r\n++ nproc\r\n++ nproc\r\n++ nproc\r\n+ echo would run: git rebase --exec 'echo Running test-one-commit on $( git log -1 ) && CC=clang CXX=clang++ cmake -B build -DWERROR=ON -DWITH_ZMQ=ON -DBUILD_GUI=ON -DBUILD_BENCH=ON -DBUILD_FUZZ_BINARY=ON -DWITH_BDB=ON -DWITH_USDT=ON -DCMAKE_CXX_FLAGS='\\''-Wno-error=unused-member-function'\\'' && cmake --build build -j 16 && ctest --output-on-failure --stop-on-failure --test-dir build -j 16 && ./build/test/functional/test_runner.py -j 32 --combinedlogslen=99999999' 998386d4462f5e06412303ba559791da83b913fb\r\nwould run: git rebase --exec echo Running test-one-commit on $( git log -1 ) && CC=clang CXX=clang++ cmake -B build -DWERROR=ON -DWITH_ZMQ=ON -DBUILD_GUI=ON -DBUILD_BENCH=ON -DBUILD_FUZZ_BINARY=ON -DWITH_BDB=ON -DWITH_USDT=ON -DCMAKE_CXX_FLAGS='-Wno-error=unused-member-function' && cmake --build build -j 16 && ctest --output-on-failure --stop-on-failure --test-dir build -j 16 && ./build/test/functional/test_runner.py -j 32 --combinedlogslen=99999999 998386d4462f5e06412303ba559791da83b913fb\r\n+ git branch -D dummy-branch\r\nDeleted branch dummy-branch (was af33d1bef61).\r\n\r\n```\r\n\r\n</details>",
          "created_at": "2025-03-20T23:24:24Z"
        },
        {
          "user": "maflcko",
          "body": "> Would it not in that case be simpler to checkout the PR `HEAD` commit, fetch and rebase onto master\r\n\r\nAgain, I don't think this is possible.\r\n\r\nIn your example the rebase succeeds, because it is not needed. See:\r\n\r\n```\r\ngit pull --rebase origin master\r\nFrom https://github.com/willcl-ark/bitcoin\r\n * branch                    master     -> FETCH_HEAD\r\nCurrent branch dummy-branch is up to date.\r\n```\r\n\r\nHowever, in the general case, it is not possible to rebase all commits of all pull requests on top of current master, even if the pull request merges fine into current master. For example:\r\n\r\n* One commit in the pull reqeust could be changing a file that was deleted/modified in master and the next commit fully or partially reverts those changes (for whatever reason). A merge with master may succeed, but a rebase may fail.\r\n* Another example would be a subtree merge (or any unclean merge commit) as part of the pull request.\r\n\r\nWith exact steps to reproduce:\r\n\r\n```\r\nsh-5.2$ git fetch origin 0e8254fef9f0d37f88d1f077f0165e7febd3bfa0  # subtree merge\r\n...\r\n * branch                  0e8254fef9f0d37f88d1f077f0165e7febd3bfa0 -> FETCH_HEAD\r\nsh-5.2$ git checkout 0e8254fef9f0d37f88d1f077f0165e7febd3bfa0\r\n...\r\nHEAD is now at 0e8254fef9 Update secp256k1 subtree to latest master\r\nsh-5.2$ git rebase 998386d4462  # master\r\n...\r\nCould not apply dd59896431... Squashed 'src/secp256k1/' changes from 0cdc758a56..70f149b9a1\r\n\r\n\r\n",
          "created_at": "2025-03-21T07:21:42Z"
        },
        {
          "user": "maflcko",
          "body": "Due to lack of activity here, I've implemented a replacement in https://github.com/bitcoin/bitcoin/pull/32203",
          "created_at": "2025-04-02T17:12:48Z"
        },
        {
          "user": "willcl-ark",
          "body": "> Due to lack of activity here, I've implemented a replacement in #32203\r\n\r\nGreat, thanks @maflcko .\r\n\r\nIâ€™ll review that one.",
          "created_at": "2025-04-02T17:21:31Z"
        }
      ]
    },
    {
      "number": 32101,
      "title": "Accept unordered tracepoints in interface_usdt_utxocache.py",
      "body": "We have encountered an instance where the tracepoints were not collected in the same order they were fired (#31951).\r\n\r\nTracepoint ordering is not guaranteed in userspace for a number of reasons.\r\n\r\nAs this test does not require a strict collection/processing order collect `expected` and `actual` events into dicts and compare them.\r\n\r\nThis will gracefully handle both the number of events, and out-of-order events should they reoccur in the future.\r\n\r\nFixes: #31951\r\n",
      "state": "closed",
      "user": "willcl-ark",
      "created_at": "2025-03-20T12:48:34Z",
      "updated_at": "2025-03-27T07:51:05Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/pull/32101",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32101.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [laanwj](https://github.com/bitcoin/bitcoin/pull/32101#pullrequestreview-2717503724), [0xB10C](https://github.com/bitcoin/bitcoin/pull/32101#issuecomment-2755174173) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n",
          "created_at": "2025-03-20T12:48:38Z"
        },
        {
          "user": "0xB10C",
          "body": "ACK 693d1e2f54baa0d5e407153f79b2f98385e6b8d9\r\n\r\nI successfully ran the changed test a couple of times and the code changes look good to me.\r\n\r\nThat this behavior works as intended can be tested with this patch:\r\n\r\n```patch\r\ndiff --git a/test/functional/interface_usdt_utxocache.py b/test/functional/interface_usdt_utxocache.py\r\nindex d4213d5020..94ec23c51a 100755\r\n--- a/test/functional/interface_usdt_utxocache.py\r\n+++ b/test/functional/interface_usdt_utxocache.py\r\n@@ -326,6 +326,7 @@ class UTXOCacheTracepointTest(BitcoinTestFramework):\r\n                 event.is_coinbase\r\n             )\r\n\r\n+        expected_utxocache_adds.reverse()\r\n         expected_add_keys = {(e[\"txid\"], e[\"index\"], e[\"height\"], e[\"value\"], e[\"is_coinbase\"])\r\n                              for e in expected_utxocache_adds}\r\n         expected_spent_keys = {(e[\"txid\"], e[\"index\"], e[\"height\"], e[\"value\"], e[\"is_coinbase\"])\r\n```",
          "created_at": "2025-03-24T15:54:05Z"
        },
        {
          "user": "0xB10C",
          "body": "re-ACK 248fdd88dcf651a0560a3eedfb8af61f38c61400",
          "created_at": "2025-03-26T17:23:59Z"
        }
      ]
    },
    {
      "number": 32100,
      "title": "doc: clarify the documentation of `Assume` assertion",
      "body": "An Expression inside `Assume` may be optimized away in production builds when the compiler proves they are side-effect-free. \r\nThis use case is demonstrated in #31363 and is suggested to be documented in https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2736410023.",
      "state": "closed",
      "user": "ismaelsadeeq",
      "created_at": "2025-03-20T11:20:59Z",
      "updated_at": "2025-03-27T21:45:15Z",
      "comments": 15,
      "url": "https://github.com/bitcoin/bitcoin/pull/32100",
      "labels": [
        "Docs"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32100.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/32100#issuecomment-2748351872), [hodlinator](https://github.com/bitcoin/bitcoin/pull/32100#pullrequestreview-2710762015), [jonatack](https://github.com/bitcoin/bitcoin/pull/32100#pullrequestreview-2711113250), [rkrux](https://github.com/bitcoin/bitcoin/pull/32100#pullrequestreview-2712716044) |\n| Stale ACK | [sipa](https://github.com/bitcoin/bitcoin/pull/32100#issuecomment-2748126948) |\n\nIf your review is incorrectly listed, please react with ðŸ‘Ž to this comment and the bot will ignore it on the next update.\n",
          "created_at": "2025-03-20T11:21:03Z"
        },
        {
          "user": "sipa",
          "body": "Concept ACK, this is largely how I've been using Assume().\r\n\r\nMy thinking is that due to the optimizing-out property of `Assume()`, the concern about potential performance impact is (even) lower than for `Assert()`/`assert()`, and thus one can be even more liberal when using these. Note that even `Assert()`/`assert()` tend to have very low cost for cheap conditions, as they're generally well-predicted by the CPU branch predictor (so the cost tends to be in the nanosecond or less range), but for cheap provably-side-effect-free conditions, for `Assume()` the concern just disappears entirely.\r\n\r\nSo the benefit, I think, isn't directly that `Assume()` is necessarily significantly faster than `Assert()`/`assert()` - in almost all cases in the codebase, the impact of an additional well-predicted conditional isn't going to be measurable. The benefit is that it may, for reviewers, **largely remove the consideration** of whether or not there is any performance impact at all.\r\n\r\nOf course, compared to the others it has the downside of not actually triggering in production builds, so it should be reserved for cases where (a) the code can safely continue when the assumption is violated (that's what's documented already) but also **(b) when there is sufficient test coverage** to give confidence that the assumption actually can't trigger in production.\r\n\r\n---\r\n\r\nSo I think the advice about this kind of usage should be:\r\n* There aren't other reasons to have an `Assert()`/`assert()`; i.e., if it weren't for the possibility of a production-optimized-out `Assume()`, you'd instead have no assertion at all.\r\n* The condition is clearly side-effect free.\r\n* It helps readability/reviewability by making assumptions explicitly verified in fuzz tests. If the code doesn't have good fuzz test coverage, this doesn't achieve much.",
          "created_at": "2025-03-20T14:36:25Z"
        },
        {
          "user": "ismaelsadeeq",
          "body": "\r\n> I find myself agreeing with the points mentioned in this comment [#32100 (comment)](https://github.com/bitcoin/bitcoin/pull/32100#discussion_r2008737842), there is some redundancy in the verbiage currently that can be removed.\r\n\r\nThis is fixed now in [2898a0be..a7c65edc](https://github.com/bitcoin/bitcoin/compare/a880d1bf87817b1e6606c971cbfe98382898a0be..a7c65edc884b0e22aaabd7e725f5f39e60b6e76b)",
          "created_at": "2025-03-24T12:19:12Z"
        },
        {
          "user": "sipa",
          "body": "ACK a7c65edc884b0e22aaabd7e725f5f39e60b6e76b",
          "created_at": "2025-03-24T13:24:37Z"
        },
        {
          "user": "l0rinc",
          "body": "ACK 329a0dcdafe05002f662e8737a76bfdeaba9a3ed",
          "created_at": "2025-03-24T14:37:26Z"
        },
        {
          "user": "yancyribbens",
          "body": "> Of course, compared to the others it has the downside of not actually triggering in production builds, so it should be reserved for cases where (a) the code can safely continue when the assumption is violated (that's what's documented already)\r\n\r\nThis is a good call out, although I don't see it already documented (here), maybe I'm blind\r\n\r\nThe other reason I think this is a good call it is this excerpt from http://fiona.dmcs.p.lodz.pl/oopc/reference/en/cpp/language/attributes/assume.html.\r\n\r\n> If the expression can ever evaluate to false, it will inject [undefined behavior](http://fiona.dmcs.p.lodz.pl/oopc/reference/en/cpp/language/ub.html) into your whole program (not just where the assumption appears). It should never be used in place of an assertion or precondition.\r\n\r\nOther note is I don't see any mention in the docs that this is optimized out in production.  The best I can find is that the expression is not evaluated and converted to a bool, then when the program reaches that bool, if the bool evaluates to true it's basically a noop (has no effect) otherwise boom.\r\n\r\nsee: https://eel.is/c++draft/dcl.attr.assume",
          "created_at": "2025-03-25T19:02:04Z"
        },
        {
          "user": "maflcko",
          "body": "> see: https://eel.is/c++draft/dcl.attr.assume\r\n\r\nThe assume attribute is C++23. However, this codebase is C++20 and this pull request is about the `Assume` macro in the codebase itself.",
          "created_at": "2025-03-25T19:07:47Z"
        },
        {
          "user": "yancyribbens",
          "body": "> The assume attribute is C++23. However, this codebase is C++20 and this pull request is about the Assume macro in the codebase itself.\r\n\r\nGood point.  I did also link the C++23 link above.  I'm just looking for confirmation that this doesn't appear in production which doesn't appear in any reference that I see.",
          "created_at": "2025-03-25T19:11:01Z"
        },
        {
          "user": "sipa",
          "body": ">  I'm just looking for confirmation that this doesn't appear in production which doesn't appear in any reference that I see.\r\n\r\nYou cannot find any reference about it, because `Assume()` is a macro defined **in the Bitcoin Core codebase**, not a C++ language/library feature. It's defined [here](https://github.com/bitcoin/bitcoin/blob/v28.0/src/util/check.h#L89). It is different from, and unrelated to, the `[[assume(...)]]` attribute added in C++23 which you link to.\r\n\r\nAnd you can't find confirmation that it doesn't appear in production, because as far as the language is concerned, it does appear in production. It just happens to be the case that compilers may *always* remove code which they can prove has no effect.",
          "created_at": "2025-03-25T19:36:03Z"
        },
        {
          "user": "yancyribbens",
          "body": "> You cannot find any reference about it, because Assume() is a macro defined in the Bitcoin Core codebase, not a C++ language/library feature. It's defined [here](https://github.com/bitcoin/bitcoin/blob/v28.0/src/util/check.h#L89). It is different from, and unrelated to, the [[assume(...)]] attribute added in C++23 which you link to.\r\n\r\nI see, thanks for the explanation.  Others reading this may also think this is talking about the C++ assume (maybe).\r\n\r\n> And you can't find confirmation that it doesn't appear in production, because as far as the language is concerned, it does appear in production. It just happens to be the case that compilers may always remove code which they can prove has no effect.\r\n\r\nOk.  The wording might be more clear if it said that the compiler will optimize this out if it can prove there is no side-effect and drop the reference to production.",
          "created_at": "2025-03-26T17:10:36Z"
        },
        {
          "user": "sipa",
          "body": "> if it said that the compiler will optimize this out if it can prove there is no side-effect \r\n\r\nThere is no guarantee that the compiler will do that.\r\n\r\n> drop the reference to production\r\n\r\nIn debug builds, it cannot be optimized out, because the statement necessarily has a side-effect (aborting if it detects the condition is false).",
          "created_at": "2025-03-26T17:12:37Z"
        },
        {
          "user": "ryanofsky",
          "body": "Post-merge code review ACK 329a0dcdafe05002f662e8737a76bfdeaba9a3ed. This should be a helpful change since it clarifies how `Assume` works.\r\n\r\nIMO, the `Assume` macro is not very well designed because it is useful for two different things and not good at doing either of them. `Assume` is useful:\r\n\r\n1. To check for states you never expect to occur, but are harmless. It can be used when you want to make sure unexpected states trigger failures during testing, but don't want those states to crash the program in release builds. You may want to handle them instead by logging a warning, returning an error from the current RPC, safely aborting the current operation, or just doing nothing and moving on.\r\n\r\n2. To check for states you never expect to occur, and probably indicate serious bugs, but the checks are slow, or are located in hotspots where they would be too expensive to perform in release builds, so are better to skip.\r\n\r\n`Assume` is suboptimal for the first case because in most of the places where it is called the return value is never checked, so even when the check is performed in release builds, nothing is logged and there's no indication of any problem. For the first case it would make more sense to have an `Assume` function that did the same thing but logged a warning like \"Unexpected condition [...] reached, consider reporting a bug.\" Release builds are run in many more environments than debug builds so if unexpected states that we have explicitly written checks for are being reached, it would be probably better to know about them than not know about them.\r\n\r\n`Assume` is suboptimal for the second case because instead of reliably not performing checks in release builds, checks will only be optimized out if the compiler is able to determine that the check has no side effects. This means the slowest checks may not be optimized out, which is confusing to say the least.\r\n\r\nMy inclination to improve this would be to keep using `Assume` for the first case and improve it, but introduce a new macro like `DCHECK` to be used for the second case that would only execute checks in debug builds. (I previously also suggested a [`SLOWCHECK`](https://github.com/bitcoin/bitcoin/pull/31191#issuecomment-2451865832) macro to try to improve the second case)",
          "created_at": "2025-03-27T14:57:09Z"
        },
        {
          "user": "hodlinator",
          "body": "What I'm missing is a `SLOWCHECK`/`DCHECK` macro that is active in debug and always active in fuzz builds (and fails fuzz-builds on failure even in release). For cases when something very unexpected is happening but it's not worth crashing the node in production over it. Hopefully this need is not due to wanting to make up for sloppy comprehension of the code.\r\n\r\n(It's also unfortunate that `Assume()` uses the same term as the C++23 `[[assume]]` feature with very different semantics).",
          "created_at": "2025-03-27T15:22:57Z"
        },
        {
          "user": "maflcko",
          "body": "> What I'm missing is a `SLOWCHECK`/`DCHECK` macro that is active in debug and always active in fuzz builds (and fails fuzz-builds on failure even in release).\r\n\r\nThe `Assume()` macro does exactly this, albeit the fuzz part is only documented in the code itself.",
          "created_at": "2025-03-27T21:41:33Z"
        },
        {
          "user": "hodlinator",
          "body": "> The `Assume()` macro does exactly this, albeit the fuzz part is only documented in the code itself.\r\n\r\nAh, nice. Was getting thrown off by `ABORT_ON_FAILED_ASSUME` being debug-only, but `G_FUZZING`/`FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION` seems to achieve what I'm after.",
          "created_at": "2025-03-27T21:44:55Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 32105,
      "title": "Add a script for Signet or Regtest to unlock fee estimator",
      "body": "### Please describe the feature you'd like to see added.\n\nCurrently, the fee estimator won't work in a private signet or regtest network, because there are usually not enough transactions being added. This forces clients to hardcode a default fee or have some custom logic for these networks.\nThe proposal is to add a script to /contrib/signet that would simulate a transactions volume just enough to allow `estimatesmartfee` to work.\nIt would be useful to have it in the bitcoin core repo, because:\n - the users will be able to build a container image that includes all the needed scripts from a single repo,\n - the transaction generator could reuse the miner wallet and access credentials.\n\n### Is your feature related to a problem, if so please describe it.\n\n`estimatesmartfee` returns \n```\n{\n  \"errors\": [\n    \"Insufficient data or no feerate found\"\n  ],\n  \"blocks\": 3\n}\n```\n\n### Describe the solution you'd like\n\nA script in python, similar to miner, that will work this way:\n1. generate a pool of addresses,\n2. using `sendtoaddress` broadcast 5-10 transactions with random amount 100-1000 sats and random fee to random addresses from the pool,\n4. wait 2 minutes,\n5. repeat from step 2.\n\n### Describe any alternatives you've considered\n\nUsing a bash script is less effort in the beginning, but can be hard to extend in the future.\nForking bitcoin repo and adding the script to it adds upkeep costs for the maintainer.\n\n### Please leave any additional context\n\nInspired by https://github.com/bitcoin/bitcoin/issues/11500",
      "state": "open",
      "user": "yellowred",
      "created_at": "2025-03-20T22:01:50Z",
      "updated_at": "2025-10-30T18:58:12Z",
      "comments": 2,
      "url": "https://github.com/bitcoin/bitcoin/issues/32105",
      "labels": [
        "Feature",
        "Scripts and tools"
      ],
      "comment_list": [
        {
          "user": "ismaelsadeeq",
          "body": "Reviewers of #32395 can also weigh input here so we donâ€™t keep this open unnecessarily.\nWhat @yellowred suggested can be handled by the client that actually needs this functionality, rather than us having to write and maintain this script in our repository.\n\nI took a pragmatic approach, but it received little to mixed   support (~0 and +1), so it seems the general sentiment is that we donâ€™t want to enable this. Based on the feedback from my previous (now closed) PR, this can be closed as well.\n\n@instagibbs @pinheadmz @polespinasa ",
          "created_at": "2025-10-30T17:33:48Z"
        },
        {
          "user": "pinheadmz",
          "body": "Agree (to close the issue), I have several scripts like this for different use cases anyway. Thanks for putting in the work! This question will definitely come up again and the closed PR can justify a \"wont fix\"",
          "created_at": "2025-10-30T18:58:12Z"
        }
      ]
    },
    {
      "number": 32102,
      "title": "Write access to Testing Guide for 29.0 RC",
      "body": "I am currently working on improving the Testing Guide: Bitcoin Core 29.0 Release Candidate.\nI would like to request permission to edit the Wiki so I can contribute.\nSpecifically, I would like to add a section about the new ephemeral dust feature.\nThank you!",
      "state": "closed",
      "user": "mabu44",
      "created_at": "2025-03-20T12:54:47Z",
      "updated_at": "2025-03-27T01:27:31Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/issues/32102",
      "labels": [],
      "comment_list": [
        {
          "user": "fanquake",
          "body": "Added.",
          "created_at": "2025-03-21T06:21:00Z"
        }
      ]
    },
    {
      "number": 32099,
      "title": "Add a `indexesdir` option to hold the indexes directory",
      "body": "### Please describe the feature you'd like to see added.\n\nAn `indexesdir` option (or whatever you want to call it) to specify an alternative directory to datadir to hold the 'indexes' subdirectory, like the `blocksdir` option for the 'blocks' subdirectory.\n\n### Is your feature related to a problem, if so please describe it.\n\nLike the 'blocks' directory, the 'indexes' directory can grow to a significant size (perhaps not as large as 'blocks' but still significantly large), making it desirable to e.g. offload it onto a separate HDD while keeping the rest of datadir on an SSD for other benefits (like fast access to the chainstate directory). This option is already available for the 'blocks' directory through the `blocksdir` option, so there's adequate precedent to do the same for 'indexes'.\n\n### Describe the solution you'd like\n\nDescribed above\n\n### Describe any alternatives you've considered\n\n[Splitting datadir using symlinks etc](https://en.bitcoin.it/wiki/Splitting_the_data_directory)\n\n### Please leave any additional context\n\n_No response_",
      "state": "open",
      "user": "User087",
      "created_at": "2025-03-20T05:56:36Z",
      "updated_at": "2025-03-24T17:22:45Z",
      "comments": 2,
      "url": "https://github.com/bitcoin/bitcoin/issues/32099",
      "labels": [
        "Feature"
      ],
      "comment_list": [
        {
          "user": "User087",
          "body": "> Do you have `txindex` enabled or disabled?\n\nEnabled - the context of the question is that I think this would be useful for anyone running with `txindex` enabled; I'm not assuming `indexesdir` would be necessary if it's kept disabled (just as someone with a sufficiently pruned blockchain doesn't need to worry about `blocksdir` either).",
          "created_at": "2025-03-21T06:02:11Z"
        },
        {
          "user": "mzumsande",
          "body": "With the current size of indexes this looks like a reasonable option to me  - even if symlinks work too.",
          "created_at": "2025-03-24T17:22:44Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 4,
    "issues": 3
  }
}