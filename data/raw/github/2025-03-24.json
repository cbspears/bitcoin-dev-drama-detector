{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T19:27:19.093224+00:00",
  "date": "2025-03-24",
  "pull_requests": [
    {
      "number": 32133,
      "title": "RFC: Accept non-std transactions in Testnet4 by default again",
      "body": "Feel free to ignore the code, just looking for conceptual discussion for now.\r\n\r\nIt used to be the case that we would accept non-std transactions by default in Testnet3 but this was changed in #28354 because RSK had shot themselves in the foot because of this (see #26348). In discussions on Testnet4 [this came up again as a potential feature](https://github.com/bitcoin/bitcoin/pull/29775#issuecomment-2041139129) but the idea to revert this was rejected then because the 20-min exception rule could be used as a way to get non-std transactions in the chain instead. We now know that the attention the 20-min got from the discussions in that PR and elsewhere has led to an exploitation of the rule that has basically made it unusable. While the frequent re-orgs are interesting to some as a robustness test, the ability to get non-std transactions in the chain does not seem to be there anymore. Recently [darosior has suggested on the ML to remove the 20-min exception rule because of this development](https://groups.google.com/g/bitcoindev/c/iVLHJ1HWhoU/m/ydjeTH6rAwAJ). If we go through with this, the question is why we are not also moving back on this setting, too, so that people can use non-std transactions on Testnet4. The only alternative left would be that they have to go to a different network or get their transaction to a testnet4 miner out of band.\r\n\r\nThe frequent argument I hear/read is that Testnet should behave like Mainnet but the reality is that we don't want it to behave like mainnet in all the ways because that would mean we can't really do all the testing we want. For example, we have introduced the timewarp attack protection as well on Testnet4. We also have kept the `-acceptnonstdtxn` setting around which but it is available on Mainnet. If we really wanted Testnet to always behave like mainnet we should have removed the setting too. Next time RSK could just have a connection to a miner who has set it to true and then they don't detect the error and shoot themselves in the foot yet again.\r\n\r\nAnd we do have `testmempoolaccept`. This is the part that I really don't understand. By taking the stance of \"Testnet should behave like Mainnet\" people will rely on it even more but I don't think it's true that testing on testnet gives people 100% security their stuff will work on mainnet and people should not solely rely on that. The stance should be: If you want to make sure your tx propagates on mainnet then use `testmempoolaccept` on a mainnet node. There is no alternative to that, don't rely only on testnet behavior when it's very important for you.",
      "state": "closed",
      "user": "fjahr",
      "created_at": "2025-03-24T15:46:43Z",
      "updated_at": "2025-05-20T21:01:59Z",
      "comments": 8,
      "url": "https://github.com/bitcoin/bitcoin/pull/32133",
      "labels": [
        "Brainstorming",
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32133.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.\n",
          "created_at": "2025-03-24T15:46:46Z"
        },
        {
          "user": "maflcko",
          "body": "> the question is why we are not also moving back on this setting, too, so that people can use non-std transactions on Testnet4.\r\n\r\nI don't think this is enough. There are many non-std transactions that will still be rejected, even if this is turned on. One example is https://github.com/bitcoin/bitcoin/pull/29843.\r\n\r\n\r\n\r\n> If you want to make sure your tx propagates on mainnet then use `testmempoolaccept` on a mainnet node.\r\n\r\nI don't think this is enough either. There are many transaction topologies that will be rejected as a single package in the mempool, when the mempool accepts the package in smaller bites, with each bite confirming first on the chain. One example is TRUC.",
          "created_at": "2025-03-24T16:02:24Z"
        },
        {
          "user": "Christewart",
          "body": "> > the question is why we are not also moving back on this setting, too, so that people can use non-std transactions on Testnet4.\r\n> \r\n> I don't think this is enough. There are many non-std transactions that will still be rejected, even if this is turned on. One example is #29843.\r\n\r\nAnother example is 64-byte transactions which was surprising behavior to me when working the BIP to disallow them:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/e486597f9a57903600656fb5106858941885852f/src/validation.cpp#L798\r\n\r\nhttps://delvingbitcoin.org/t/great-consensus-cleanup-revival/710/73#p-4382-native-segwit-v0-and-v1-programs-8\r\n\r\n",
          "created_at": "2025-03-28T18:54:15Z"
        },
        {
          "user": "ajtowns",
          "body": "> If we really wanted Testnet to always behave like mainnet we should have removed the setting too. Next time RSK could just have a connection to a miner who has set it to true and then they don't detect the error and shoot themselves in the foot yet again.\r\n\r\nIn that case, the same setup that worked for testnet (getting a direct connection to a miner that is willing to support your consensus-valid but non-standard transactions) also works for mainnet, and they haven't shot themselves in the foot.\r\n\r\n> The stance should be: If you want to make sure your tx propagates on mainnet then use `testmempoolaccept` on a mainnet node.\r\n\r\nIf you want to do your testing in situations where you can and will lose real money, then testing on mainnet is fine. That's not something I'd recommend though.\r\n\r\n> While the frequent re-orgs are interesting to some as a robustness test, the ability to get non-std transactions in the chain does not seem to be there anymore.\r\n\r\nIf someone would like to write up some (robust) support code for proposing custom blocks for a signet miner to validate and sign, I'd be happy to look into running that on my signet miner.",
          "created_at": "2025-04-29T09:01:27Z"
        },
        {
          "user": "fjahr",
          "body": "> In that case, the same setup that worked for testnet (getting a direct connection to a miner that is willing to support your consensus-valid but non-standard transactions) also works for mainnet, and they haven't shot themselves in the foot.\r\n\r\nI didn't mean that they setup this connection to a miner on purpose, I meant that they just happened to be connect to a miner by chance (which I think is much more likely to happend on testnet than on mainnet).\r\n\r\n> If you want to do your testing in situations where you can and will lose real money, then testing on mainnet is fine. That's not something I'd recommend though.\r\n\r\n`testmempoolaccept` tells you if your transaction would be accepted without actually broadcasting it, no? How are you risking real money when you use it on a mainnet node?",
          "created_at": "2025-04-29T14:40:37Z"
        },
        {
          "user": "ajtowns",
          "body": "> I didn't mean that they setup this connection to a miner on purpose, I meant that they just happened to be connect to a miner by chance (which I think is much more likely to happend on testnet than on mainnet).\r\n\r\nEven in that case, they've manually modified their own node to accept non standard transactions so they should have some chance of being aware that something weird is going on. Also, if it is the case that randomly connecting to nodes finds you a testnet miner that accepts non standard transactions, then relaying/mining those transactions is already easy and changing the option to be the default isn't going to be make anything easier.\r\n\r\n> `testmempoolaccept` tells you if your transaction would be accepted without actually broadcasting it, no? How are you risking real money when you use it on a mainnet node?\r\n\r\nOnly after you've signed the transaction in your test environment with a real mainnet key that's protecting real mainnet funds.",
          "created_at": "2025-04-30T10:35:05Z"
        },
        {
          "user": "maflcko",
          "body": "Tend toward -0. As mentioned above in my first comment, it is not sufficient to achieve the goal you are trying to achieve, so it mostly brings the downsides mentioned above with questionable benefits.\r\n\r\nGoing forward, one could say the only way for developers to inject non-standard transactions into testnet_N is to ask a miner or rent some hashrate to do it.\r\n\r\nHowever, injecting test-only non-standard transactions into a test network comes with its own downsides, like requiring more exceptions for future soft forks in consensus code. Also, the demand for it right now seems limited, given that no one is working on creating a set of \"interesting\" transactions, and a method to inject them easily. Finally, I also wonder if it is really the best way to achieve the testing goal. Maybe just better maintenance of https://github.com/bitcoin-core/qa-assets/blob/main/unit_test_data/script_assets_test.json (or similar) and advertising it to be used by other node software seems possibly more worthwhile.",
          "created_at": "2025-04-30T10:51:38Z"
        },
        {
          "user": "fjahr",
          "body": "> Only after you've signed the transaction in your test environment with a real mainnet key that's protecting real mainnet funds.\r\n\r\nI think it's reasonable for a bitcoin company to have a few sats in a mainnet hot wallet to use for testing, they don't need to touch their cold storage for this.\r\n\r\nAnyway, closing for now, my opinion on this hasn't changed much but I think it's better to focus on something else.",
          "created_at": "2025-05-20T21:01:59Z"
        }
      ]
    },
    {
      "number": 32132,
      "title": "build: Remove bitness suffix from Windows installer",
      "body": "Since support for 32-bit Windows has been dropped, the suffix is no longer necessary.",
      "state": "closed",
      "user": "hebasto",
      "created_at": "2025-03-24T14:20:10Z",
      "updated_at": "2025-09-21T06:48:56Z",
      "comments": 8,
      "url": "https://github.com/bitcoin/bitcoin/pull/32132",
      "labels": [
        "Windows",
        "Build system"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32132.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/32132#pullrequestreview-2710614237), [hodlinator](https://github.com/bitcoin/bitcoin/pull/32132#pullrequestreview-2711591169), [laanwj](https://github.com/bitcoin/bitcoin/pull/32132#pullrequestreview-2713794902) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n",
          "created_at": "2025-03-24T14:20:13Z"
        },
        {
          "user": "laanwj",
          "body": "> We still have things like x86_64-w64-mingw32/bitcoin-94967c353ed8-win64-setup-unsigned.exe\r\n\r\ni don't think this is what you mean here,  `win64` could definitely just be `win`, but for completeness's sake: architecture tuples like `x86_64-w64-mingw32` are set in stone, there's no leeway to remove bitness where those are directly included.",
          "created_at": "2025-03-25T13:32:56Z"
        },
        {
          "user": "hodlinator",
          "body": "> i don't think this is what you mean here, `win64` could definitely just be `win`, but for completeness's sake: architecture tuples like `x86_64-w64-mingw32` are set in stone, there's no leeway to remove bitness where those are directly included.\r\n\r\nWas thinking `x86_64-windows-mingw` would be sufficient, and on par with `x86_64-linux-gnu`. What sets them in stone?",
          "created_at": "2025-03-25T13:45:59Z"
        },
        {
          "user": "laanwj",
          "body": "> Was thinking x86_64-windows-mingw would be sufficient, and on par with x86_64-linux-gnu. What sets them in stone?\r\n\r\ngcc (and the mingw project itself, in this case). The idea is that every OS-architecture combination has a unique, unambiguous tuple. In practice there is some ambiguity (this is the magic `config.sub` deals with, to \"normalize\" it) but it's not a good thing to mess with in general.",
          "created_at": "2025-03-25T13:58:28Z"
        },
        {
          "user": "hebasto",
          "body": "This needs to be elaborated in Release Notes.\r\n\r\nWhen upgrading to v30.0, it appears necessary to uninstall first in order to remove the \"... (64-bit)\" Start Menu entries. Otherwise, they remain lingering.",
          "created_at": "2025-09-17T15:11:27Z"
        },
        {
          "user": "hodlinator",
          "body": "> When upgrading to v30.0, it appears necessary to uninstall first in order to remove the \"... (64-bit)\" Start Menu entries. Otherwise, they remain lingering.\r\n\r\nCan confirm, I ended up having to remove the \"... (64-bit)\"-entry in the list of installed programs manually through Regedit - not ideal. :\\",
          "created_at": "2025-09-17T18:10:55Z"
        },
        {
          "user": "hodlinator",
          "body": "Maybe we could amend the .NSI-script to unregister versions with the old name. I plan to take a stab at this tomorrow unless something unexpected comes up or someone else wants to pick it up.",
          "created_at": "2025-09-17T20:45:06Z"
        },
        {
          "user": "hodlinator",
          "body": "My testing shows #33422 does the job. I'd say we should have it in the v30 release or we should do the less risky thing and revert this PR (#32132) from v30.",
          "created_at": "2025-09-18T08:03:42Z"
        }
      ]
    },
    {
      "number": 32129,
      "title": "doc: Update comments for AreInputsStandard to match code",
      "body": "The comment about extra data stuffed in scriptSigs was introduced in #4365 which introduced `ScriptSigArgsExpected()`, and became incorrect after #7387 / #7453 (checks are now performed by `SCRIPT_VERIFY_CLEANSTACK` during script validation and `IsPushOnly()` in `IsStandardTx()`). Drops the details on what a p2sh with many checksigs would look like, which was already done in #4365, but only for main.cpp not the duplicated comment in main.h, which was merged into policy/policy.cpp in #6335 and later moved to the right place in #10682.",
      "state": "closed",
      "user": "ajtowns",
      "created_at": "2025-03-24T09:09:39Z",
      "updated_at": "2025-03-27T07:46:13Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/pull/32129",
      "labels": [
        "Docs"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32129.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [instagibbs](https://github.com/bitcoin/bitcoin/pull/32129#issuecomment-2754427367), [darosior](https://github.com/bitcoin/bitcoin/pull/32129#pullrequestreview-2717220554) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n",
          "created_at": "2025-03-24T09:09:42Z"
        },
        {
          "user": "darosior",
          "body": "Concept ACK",
          "created_at": "2025-03-24T13:54:17Z"
        },
        {
          "user": "instagibbs",
          "body": "ACK 52ede28a8adb2c2d44d7f800bbfbef8aed86070e",
          "created_at": "2025-03-26T13:36:12Z"
        }
      ]
    },
    {
      "number": 32128,
      "title": "Draft: CCoinMap Experiments",
      "body": "This is a draft PR to show various possible optimizations for `CCoinsMap`. In my benchmark, all these changes lead to a statistically significant speed improvement for `-reindex-chainstate`. \r\n\r\n```\r\nBenchmark 1: ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = ac188b573c8)\r\n  Time (mean ¬± œÉ):     2089.253 s ¬± 23.737 s    [User: 2110.111 s, System: 299.197 s]\r\n  Range (min ‚Ä¶ max):   2062.751 s ‚Ä¶ 2108.561 s    3 runs\r\n\r\nBenchmark 2: ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = 7113095b3cd)\r\n  Time (mean ¬± œÉ):     2431.028 s ¬± 17.544 s    [User: 2439.746 s, System: 284.994 s]\r\n  Range (min ‚Ä¶ max):   2415.408 s ‚Ä¶ 2450.009 s    3 runs\r\n\r\nBenchmark 3: ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = 7370e13d93d)\r\n  Time (mean ¬± œÉ):     2530.955 s ¬± 21.575 s    [User: 2539.882 s, System: 285.890 s]\r\n  Range (min ‚Ä¶ max):   2512.525 s ‚Ä¶ 2554.687 s    3 runs\r\n\r\nBenchmark 4: ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = e568c1dd134)\r\n  Time (mean ¬± œÉ):     2839.864 s ¬±  9.993 s    [User: 2850.112 s, System: 287.916 s]\r\n  Range (min ‚Ä¶ max):   2830.073 s ‚Ä¶ 2850.047 s    3 runs\r\n\r\nSummary\r\n  ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = ac188b573c8) ran\r\n    1.16 ¬± 0.02 times faster than ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = 7113095b3cd)\r\n    1.21 ¬± 0.02 times faster than ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = 7370e13d93d)\r\n    1.36 ¬± 0.02 times faster than ./build/bin/bitcoind -stopatheight=600000 -dbcache=5000 -printtoconsole=0 -reindex-chainstate -noconnect -connect=192.168.8.118 (COMMIT = e568c1dd134)\r\n```\r\n\r\n",
      "state": "closed",
      "user": "martinus",
      "created_at": "2025-03-24T06:02:30Z",
      "updated_at": "2025-09-02T05:22:16Z",
      "comments": 7,
      "url": "https://github.com/bitcoin/bitcoin/pull/32128",
      "labels": [
        "Validation",
        "Up for grabs",
        "Needs rebase",
        "CI failed"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32128.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#32313](https://github.com/bitcoin/bitcoin/pull/32313) (coins: fix `cachedCoinsUsage` accounting in `CCoinsViewCache` by l0rinc)\n* [#32043](https://github.com/bitcoin/bitcoin/pull/32043) ([IBD] Tracking PR for speeding up Initial Block Download by l0rinc)\n* [#31895](https://github.com/bitcoin/bitcoin/pull/31895) (doc: Improve `dependencies.md` by NicolaLS)\n* [#30442](https://github.com/bitcoin/bitcoin/pull/30442) ([IBD] precalculate SipHash constant salt calculations by l0rinc)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
          "created_at": "2025-03-24T06:02:33Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nüöß At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/39270918766</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
          "created_at": "2025-03-24T06:51:03Z"
        },
        {
          "user": "martinus",
          "body": "> Welcome back @martinus, we missed you! :) I will measure these changes separately until 890k blocks soon. I have included this change a tracking PR where we have other similar experiments: #32043\r\n\r\nI have not done any programming in half a year, looking forward to getting back :)",
          "created_at": "2025-03-24T15:36:42Z"
        },
        {
          "user": "l0rinc",
          "body": "I have measured these commits separately against a baseline (undoing each commit, to measure them independently).\r\n* 1d281daf86 `Merge bitcoin/bitcoin#32095: doc: clarify that testnet min-difficulty` is the **baseline**\r\n* 1112433318 `SaltedOutpointHasher uses rapidhash` is **5%** faster than 1d281daf86\r\n* e00d828362 `CCoinsViewCache::BatchWrite lookup optimization` is **0.5%** faster than 1d281daf86\r\n* 1630e368d1 `Use boost::unordered_node_map for CCoinsMap` is **7.4%** faster than 1d281daf86\r\n\r\n<details>\r\n<summary>Reindex-chainstate until block 888888</summary>\r\n\r\n```bash\r\n1d281daf86 (HEAD, origin/master, origin/HEAD) Merge bitcoin/bitcoin#32095: doc: clarify that testnet min-difficulty is not optional\r\n1112433318 SaltedOutpointHasher uses rapidhash\r\ne00d828362 CCoinsViewCache::BatchWrite lookup optimization\r\n1630e368d1 (l0rinc/detached186) Use boost::unordered_node_map for CCoinsMap\r\nBenchmark 1: COMPILER=gcc COMMIT=1d281daf8613a3cb7a26759c351ffb34dab0f656 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n  Time (abs ‚â°):        25746.852 s               [User: 24476.673 s, System: 1096.263 s]\r\n \r\nBenchmark 2: COMPILER=gcc COMMIT=1112433318cbb096fec0cc83d2c424db652c126f ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n  Time (abs ‚â°):        24511.624 s               [User: 23046.157 s, System: 1074.909 s]\r\n \r\nBenchmark 3: COMPILER=gcc COMMIT=e00d8283624f3d937f1222cb2c1540655045b095 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n  Time (abs ‚â°):        25616.379 s               [User: 24209.459 s, System: 1088.005 s]\r\n \r\nBenchmark 4: COMPILER=gcc COMMIT=1630e368d190a75870399cc38af3c6023faaf2d9 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n  Time (abs ‚â°):        23966.508 s               [User: 22294.996 s, System: 1082.040 s]\r\n \r\nSummary\r\n  COMPILER=gcc COMMIT=1630e368d190a75870399cc38af3c6023faaf2d9 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0 ran\r\n    1.02 times faster than COMPILER=gcc COMMIT=1112433318cbb096fec0cc83d2c424db652c126f ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n    1.07 times faster than COMPILER=gcc COMMIT=e00d8283624f3d937f1222cb2c1540655045b095 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n    1.07 times faster than COMPILER=gcc COMMIT=1d281daf8613a3cb7a26759c351ffb34dab0f656 ./build/bin/bitcoind -datadir=/mnt/my_storage/BitcoinData -stopatheight=888888 -dbcache=5000 -blocksonly -reindex-chainstate -connect=0 -printtoconsole=0\r\n```\r\n\r\n</details>\r\n",
          "created_at": "2025-03-26T20:26:36Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--cf906140f33d8803c4a75a2196329ecb-->\nüêô This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
          "created_at": "2025-05-15T16:31:20Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--13523179cfe9479db18ec6c5d236f789-->\n‚åõ There hasn't been much activity lately and the patch still needs rebase. What is the status here?\n\n* Is it still relevant? ‚û°Ô∏è Please solve the conflicts to make it ready for review and to ensure the CI passes.\n* Is it no longer relevant? ‚û°Ô∏è Please close.\n* Did the author lose interest or time to work on this? ‚û°Ô∏è Please close it and mark it 'Up for grabs' with the label, so that it can be picked up in the future.\n",
          "created_at": "2025-08-26T01:07:56Z"
        },
        {
          "user": "martinus",
          "body": "Up for grabs, if anyone is interested",
          "created_at": "2025-08-31T12:14:31Z"
        }
      ]
    },
    {
      "number": 32127,
      "title": ".",
      "body": "<!--\r\n*** Please remove the following help text before submitting: ***\r\n\r\nPull requests without a rationale and clear improvement may be closed\r\nimmediately.\r\n\r\nGUI-related pull requests should be opened against\r\nhttps://github.com/bitcoin-core/gui\r\nfirst. See CONTRIBUTING.md\r\n-->\r\n\r\n<!--\r\nPlease provide clear motivation for your patch and explain how it improves\r\nBitcoin Core user experience or Bitcoin Core developer experience\r\nsignificantly:\r\n\r\n* Any test improvements or new tests that improve coverage are always welcome.\r\n* All other changes should have accompanying unit tests (see `src/test/`) or\r\n  functional tests (see `test/`). Contributors should note which tests cover\r\n  modified code. If no tests exist for a region of modified code, new tests\r\n  should accompany the change.\r\n* Bug fixes are most welcome when they come with steps to reproduce or an\r\n  explanation of the potential issue as well as reasoning for the way the bug\r\n  was fixed.\r\n* Features are welcome, but might be rejected due to design or scope issues.\r\n  If a feature is based on a lot of dependencies, contributors should first\r\n  consider building the system outside of Bitcoin Core, if possible.\r\n* Refactoring changes are only accepted if they are required for a feature or\r\n  bug fix or otherwise improve developer experience significantly. For example,\r\n  most \"code style\" refactoring changes require a thorough explanation why they\r\n  are useful, what downsides they have and why they *significantly* improve\r\n  developer experience or avoid serious programming bugs. Note that code style\r\n  is often a subjective matter. Unless they are explicitly mentioned to be\r\n  preferred in the [developer notes](/doc/developer-notes.md), stylistic code\r\n  changes are usually rejected.\r\n-->\r\n\r\n<!--\r\nBitcoin Core has a thorough review process and even the most trivial change\r\nneeds to pass a lot of eyes and requires non-zero or even substantial time\r\neffort to review. There is a huge lack of active reviewers on the project, so\r\npatches often sit for a long time.\r\n-->\r\n",
      "state": "closed",
      "user": "Elmarinero1983",
      "created_at": "2025-03-24T05:21:33Z",
      "updated_at": "2025-03-29T06:56:50Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/pull/32127",
      "labels": [],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32127.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
          "created_at": "2025-03-24T05:21:36Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 32131,
      "title": "RFC: Compact Block Reconstruction Macro Benchmark Suite",
      "body": "### Context and Motivation\n\nCompact blocks significantly improve block propagation efficiency by reducing bandwidth usage and latency during transmission. Precise benchmarking of compact block reconstruction performance is crucial for detecting regressions or improvements across releases, especially when modifying related code paths affecting mempool behavior or block relay performance.\n\nRecent [analysis by `B10C`](https://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052/12) highlights significant variance in compact block reconstruction efficiency depending on mempool conditions. Specifically, during periods of high mempool congestion, reconstruction success rates frequently dropped below 50%, requiring additional transaction requests and significantly increasing reconstruction times. Additionally, enabling `mempoolfullrbf` was found to notably improve reconstruction efficiency, underscoring the importance of consistent mempool policies.\n\n### Proposal: Compact Block Reconstruction Macro Benchmark Suite\n\nThe goal is to create a robust macro benchmark suite measuring the performance of compact block reconstruction across Bitcoin Core releases and different node configurations. This suite would provide consistent and actionable data when reviewing changes to relevant code paths.\n\nAs part of our [macro benchmarking efforts](https://github.com/bitcoin-dev-tools/benchcoin) - and as Gregory Sanders [also outlined](https://gist.github.com/l0rinc/dc8c5e5289de2d801df16f4468b5a58c?permalink_comment_id=5458016#gistcomment-5458016) in recent Benchmarking meeting notes - we propose:\n\n- Setting up a node by syncing up to a known block height (e.g., block 840,000, ideally via quick AssumeUTXO seeding).\n- Fetching the next few blocks from the network (lazy-init from network, caching the blocks locally) and adding their transactions to the local mempool.\n- Replaying compact block announcements and measuring reconstruction performance (multiple times for consistent and statistically meaningful results, given variability compared to stable micro-benchmarks).\n- Testing under different mempool scenarios and configurations (e.g., varying `mempoolfullrbf` settings):\n  - Fully populated mempool (asserting the mempool contains every transaction).\n  - Single transaction missing (note that this will require unreliable network traffic unless we also add a local node that serves these transactions).\n  - Empty mempool.\n\n### RFC / Questions:\n\n- Should this benchmark run periodically (weekly, pre-release), or should it be triggered automatically via GitHub labels on relevant PRs?\n- Are there additional configurations or mempool states worth considering (such as the `mempoolfullrbf` discovery above)?\n- Should we measure performance for arbitrary block heights and varying subsequent block counts?",
      "state": "open",
      "user": "l0rinc",
      "created_at": "2025-03-24T11:27:23Z",
      "updated_at": "2025-03-24T12:18:45Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/issues/32131",
      "labels": [
        "Brainstorming",
        "Tests"
      ],
      "comment_list": [
        {
          "user": "maflcko",
          "body": "> * Setting up a node by syncing up to a known block height (e.g., block 840,000, ideally via quick AssumeUTXO seeding).\n> \n> * Fetching the next few blocks from the network (lazy-init from network, caching the blocks locally) and adding their transactions to the local mempool.\n> \n> * Replaying compact block announcements and measuring reconstruction performance\n\nMaybe I am missing something obvious, but I don't think this is possible to detect the effects of mempoolfullrbf (one motivation for this benchmark). If you linearly replay blocks from the chain into the mempool, there won't be any conflicts, so there can't be any replacements, so any rbf policy settings won't have any effect. I don't think it is possible to benchmark this other than on the live network (the way it was done in https://delvingbitcoin.org/t/stats-on-compact-block-reconstructions/1052). If you really wanted to do it offline, you'd have to take a \"real\" mempool snapshot at the height you are interested in from an online node with the policy settings set you are interested in.",
          "created_at": "2025-03-24T11:50:46Z"
        },
        {
          "user": "0xB10C",
          "body": "> Replaying compact block announcements and measuring reconstruction performance (multiple times for consistent and statistically meaningful results, given variability compared to stable micro-benchmarks)\n\nWhat is the exact metric you are trying to measure? It's not 100% clear to me if you are trying to measure performance as in \"speed\" or performance as in \"reconstructions without a round trip\".\n\n> Fetching the next few blocks from the network (lazy-init from network, caching the blocks locally) and adding their transactions to the local mempool.\n\nAdding multiple future blocks to the mempool is probably not as easy as one might think. Currently about 10% of transactions (https://transactionfee.info/charts/transactions-height-based-locktime/) have a locktime set. This means, you won't be able to add these transactions and their children to your mempool. This will automatically cause transactions to be missing during compact block reconstruction. \n",
          "created_at": "2025-03-24T11:53:17Z"
        },
        {
          "user": "sipa",
          "body": "The discussion at coredev that (I believe) led to this was focused on measuring the runtime of end-to-end block acceptance for 100% reconstructible blocks.",
          "created_at": "2025-03-24T12:18:44Z"
        }
      ]
    },
    {
      "number": 32130,
      "title": "RFC: Macro Regression Test Suite for Historical Reorgs",
      "body": "### Context and Motivation\n\nWhenever we're modifying caching behavior ([optimizations](https://github.com/bitcoin/bitcoin/pull/28280), [refactors](https://github.com/bitcoin/bitcoin/pull/30906), [new features](https://github.com/bitcoin/bitcoin/pull/31553), [calculating additional metrics](https://github.com/bitcoin/bitcoin/pull/31703#discussion_r1925501920)), a common concern is often: \"Sweet, but have you tested it via a reorg?!\"\n\nWe already have tests covering basic reorg scenarios ([feature_block.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/feature_block.py#L186-L200), [p2p_unrequested_blocks.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/p2p_unrequested_blocks.py#L228-L255), [feature_pruning.py](https://github.com/bitcoin/bitcoin/blob/master/test/functional/feature_pruning.py#L181-L269)). However, we're lacking a macro regression test suite that systematically verifies Bitcoin Core behavior against historical mainnet reorg events, especially across releases, different configurations (pruned, txindex, varying memory settings), or with random undo/redo cycles.\n\n### Proposal: Historical Reorg Macro Test Suite\n\nThe goal is to create a robust regression test ensuring the latest Bitcoin Core handles historical reorgs identically to when they originally occurred. This would increase confidence that new versions do not introduce regressions in complex reorg and undo/redo logic, especially when modifying sensitive code paths. While partially covered by existing synthetic tests, this proposal is a more heavyweight alternative, using real historical blocks, performing a full IBD, and explicitly checking for behavior changes related to reorgs.\nMaking sure `mainnet` behavior is retained in critical, but we might as well extend it to making sure `testnet` behavior (which is a lot more volatile anyway) is also covered.\n\n### Dedicated Historical Stale Block Proxy\n\nLeveraging the existing [bitcoin-data/stale-blocks](https://github.com/bitcoin-data/stale-blocks/tree/master/blocks) dataset, which currently contains over 200 real historical stale blocks, we propose:\n\n- A dedicated fake node (\"stale-block proxy\") that replays historical mainnet headers and blocks exactly as originally observed (since we can't have reorgs during IBD otherwise, but this way we can simulate the ones that did actually happen).\n- The node under test would exclusively connect to this proxy node.\n- The proxy sequentially presents each historical stale block as a temporary chain tip (once the stale block is reached, the proxy moves on to the next available stale block, routing real blocks via the network), forcing the test node into realistic mainnet reorg conditions during a full IBD.\n- Once we reach a given height we could validate the resulting UTXO set againt known AssumeUTXO hashes.\n\n### Key Testing Scenarios:\n\n- Perform full initial block download (IBD) against the stale-block proxy, ensuring natural and historically accurate chain reorgs.\n- Test various node configurations explicitly:\n  - Default setup\n  - Pruned nodes\n  - Nodes with small and large dbcache memory allocations\n  - Nodes running with `txindex=1`\n\n### Additional Randomized Undo/Redo Testing:\n\nIn addition to historical scenarios, randomly trigger smaller undo/redo reorg cycles at various block heights to further stress-test UTXO consistency, using `CoinsTip::SanityCheck()` for validation before and after each reorg (confirming that undoing and reapplying a block results in the same state).\n\n### RFC / Questions:\n\n- Should this be an optional functional test (run periodically, monthly, pre-release), or triggered automatically via a GitHub label for relevant PRs?\n- Are there any additional scenarios or configurations we should consider?\n- How could we gather more historical stale blocks for our dataset (do we even have data for >1 reorgs)?",
      "state": "open",
      "user": "l0rinc",
      "created_at": "2025-03-24T10:17:02Z",
      "updated_at": "2025-03-26T08:44:51Z",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/issues/32130",
      "labels": [
        "Brainstorming",
        "Tests"
      ],
      "comment_list": [
        {
          "user": "0xB10C",
          "body": "Instead of using mainnet blocks with a reorg maybe every 1000-3000 blocks, one could consider using testnet4 blocks as it often has multiple reorgs per block and blocks are a lot smaller and faster to load.\n\nSee for example https://fork.observer/?network=4\n![Image](https://github.com/user-attachments/assets/aa1cc9ac-d6d9-493c-afcb-7449344265d9)",
          "created_at": "2025-03-24T11:43:29Z"
        },
        {
          "user": "l0rinc",
          "body": "Nice, we should do that as well!\nI think it's important to be close to the historical behavior - it may not be a tragedy if testnet behavior happens to change accidentally, but it is, if mainnet logic change isn't caught - that's why I insist on making it as realistic as possible.\nAdded it to the description.",
          "created_at": "2025-03-24T11:55:28Z"
        },
        {
          "user": "mzumsande",
          "body": "> since we can't have reorgs during IBD otherwise\n\nI'd say we shouldn't really encounter reorgs during IBD in general - reorgs typically happen when the node is synced to the tip, a new node doing IBD today usually won't experience any of the historical reorgs.\nDo I understand it correctly that what you suggest  is to simulate a situation where the syncing node thinks it is out of IBD to replay these reorgs - by changing `-minchainwork` for the node under test to a lower value, and having some orchestration in the fake node to send incomplete headers?\n\n> I think it's important to be close to the historical behavior\n\nCan you expand on this a bit? I would have thought that historical reorgs weren't particularly deep or complicated, so that synthetic scenarios might be more of a stress test than historical ones.",
          "created_at": "2025-03-25T15:50:39Z"
        },
        {
          "user": "l0rinc",
          "body": "> you suggest is to simulate a situation where the syncing node thinks it is out of IBD to replay these reorgs \n\nExactly!\n\n> historical reorgs weren't particularly deep or complicated\n\nThat's my understanding as well, but they're real, so they don't include our testing biases.\n\n",
          "created_at": "2025-03-26T08:18:58Z"
        },
        {
          "user": "maflcko",
          "body": "I'd say the testing bias should be towards full coverage of the consensus rules via synthetic tests (whether it is a unit, fuzz, or functional test). Obviously it can't hurt to confirm this with real data, but as soon as a shortcoming or lack of testing is seen, it should be added as a \"synthetic\" test.\n\nNot sure if https://github.com/bitcoin-data/stale-blocks includes invalid blocks, but if this test suite is done, it could make sense to include and check invalid blocks as well.",
          "created_at": "2025-03-26T08:44:50Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 5,
    "issues": 2
  }
}