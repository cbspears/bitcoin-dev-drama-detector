{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T20:35:20.504829+00:00",
  "date": "2025-11-27",
  "pull_requests": [
    {
      "number": 33963,
      "title": "test: tighten `V2TransportTester::SendMessage` bounds for GCC 15.2",
      "body": "### Summary\r\n#33840 adjusted `V2TransportTester::SendMessage` to avoid a `-Warray-bounds` false positive with **GCC 13**, but **GCC 15.2** still warns.\r\n\r\n### Fix\r\n\r\nImplemented the suggestion in https://github.com/bitcoin/bitcoin/pull/33840#pullrequestreview-3447477940:\r\n- take `mtype` as `std::string_view`;\r\n- assert `mtype.size() <= CMessageHeader::MESSAGE_TYPE_SIZE`;\r\n- build `[0x00][12-byte type][payload]` via `std::ranges::copy`.\r\n\r\n### Reproducer\r\n\r\nBefore this change, using GCC 15.2 on a Mac\r\n> rm -rfd build && cmake -B build -DENABLE_IPC=OFF -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ && cmake --build build -j$(nproc)\r\n\r\nproduces:\r\n```bash\r\n[100%] Building CXX object src/test/CMakeFiles/test_bitcoin.dir/__/wallet/test/walletload_tests.cpp.o\r\nIn file included from /opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/array:45,\r\n                 from /opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/span:46,\r\n                 from /Users/lorinc/bitcoin/src/span.h:10,\r\n                 from /Users/lorinc/bitcoin/src/uint256.h:10,\r\n                 from /Users/lorinc/bitcoin/src/consensus/params.h:10,\r\n                 from /Users/lorinc/bitcoin/src/kernel/chainparams.h:9,\r\n                 from /Users/lorinc/bitcoin/src/chainparams.h:9,\r\n                 from /Users/lorinc/bitcoin/src/test/net_tests.cpp:5:\r\nIn function 'constexpr _OutIter std::__copy_move_a2(_InIter, _Sent, _OutIter) [with bool _IsMove = false; _InIter = char*; _Sent = char*; _OutIter = unsigned char*]',\r\n    inlined from 'constexpr _OI std::__copy_move_a1(_II, _II, _OI) [with bool _IsMove = false; _II = char*; _OI = unsigned char*]' at /opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/bits/stl_algobase.h:492:42,\r\n    inlined from 'constexpr _OI std::__copy_move_a(_II, _II, _OI) [with bool _IsMove = false; _II = __gnu_cxx::__normal_iterator<char*, __cxx11::basic_string<char> >; _OI = __gnu_cxx::__normal_iterator<unsigned char*, vector<unsigned char> >]' at /opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/bits/stl_algobase.h:500:31,\r\n    inlined from 'constexpr _OI std::copy(_II, _II, _OI) [with _II = __gnu_cxx::__normal_iterator<char*, __cxx11::basic_string<char> >; _OI = __gnu_cxx::__normal_iterator<unsigned char*, vector<unsigned char> >]' at /opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/bits/stl_algobase.h:642:7,\r\n    inlined from 'void net_tests::{anonymous}::V2TransportTester::SendMessage(std::string, std::span<const unsigned char>)' at /Users/lorinc/bitcoin/src/test/net_tests.cpp:1304:18:\r\n/opt/homebrew/Cellar/gcc/15.2.0/include/c++/15/bits/stl_algobase.h:426:32: warning: 'void* __builtin_memmove(void*, const void*, long unsigned int)' offset [0, 1] is out of the bounds [0, 0] [-Warray-bounds=]\r\n  426 |               __builtin_memmove(_GLIBCXX_TO_ADDR(__result),\r\n      |               ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  427 |                                 _GLIBCXX_TO_ADDR(__first),\r\n      |                                 ~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n  428 |                                 __n * sizeof(*__first));\r\n      |                                 ~~~~~~~~~~~~~~~~~~~~~~~\r\n[100%] Linking CXX executable ../../bin/test_bitcoin\r\n```\r\n",
      "state": "closed",
      "user": "l0rinc",
      "created_at": "2025-11-27T18:49:47Z",
      "updated_at": "2025-11-27T20:31:58Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/pull/33963",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33963.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-11-27T18:49:54Z"
        },
        {
          "user": "maflcko",
          "body": "I don't understand this change:\r\n\r\n* The tighter bounds check does not fix the false positive warning: https://godbolt.org/z/bn4sn5ehx\r\n* Using ranges fixes it, but likely only because they break the array-bounds analysis.\r\n* There is no CI task that runs into this warning\r\n* I can't reproduce this on GCC 15.2 on Linux: https://github.com/maflcko/bitcoin-core-nightly/actions/runs/19735442483/job/56546112570#step:5:8\r\n* It reproduces with GCC 16, but there are many more warnings: https://github.com/maflcko/bitcoin-core-nightly/actions/runs/19735442483/job/56546112689#step:9:1188\r\n\r\nNo objection, but it is clear the compiler is at fault here, and fixing one warning and leaving the others around doesn't seem that useful.",
          "created_at": "2025-11-27T20:24:21Z"
        },
        {
          "user": "l0rinc",
          "body": "Thanks for checking, it seems we have to be systematic about this.",
          "created_at": "2025-11-27T20:31:39Z"
        }
      ]
    },
    {
      "number": 33962,
      "title": "refactor: replace manual promise with SyncWithValidationInterfaceQueue",
      "body": "`BroadcastTransaction()` now waits for validation callbacks using the built-in `validation_signals>SyncWithValidationInterfaceQueue()` instead of creating a local `std::promise` and scheduling a lambda. This removes an unnecessary allocation and uses the canonical API.",
      "state": "open",
      "user": "ANtutov",
      "created_at": "2025-11-27T16:12:32Z",
      "updated_at": "2025-12-10T17:35:27Z",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/pull/33962",
      "labels": [
        "Refactoring"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33962.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [rkrux](https://github.com/bitcoin/bitcoin/pull/33962#pullrequestreview-3562305612) |\n| Stale ACK | [maflcko](https://github.com/bitcoin/bitcoin/pull/33962#issuecomment-3586696431), [furszy](https://github.com/bitcoin/bitcoin/pull/33962#pullrequestreview-3520076110) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-11-27T16:12:40Z"
        },
        {
          "user": "maflcko",
          "body": "lgtm ACK d09e9306cab86c0917cc0ae198ef1993d764d106",
          "created_at": "2025-11-27T16:29:09Z"
        },
        {
          "user": "fanquake",
          "body": "You'll need to squash your commits: https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#squashing-commits.",
          "created_at": "2025-11-28T16:22:45Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/actions/runs/19769125602/job/56649201966</sub>\n<sub>LLM reason (âœ¨ experimental): CI failed due to trailing whitespace detected by lint in src/node/transaction.cpp.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-11-28T16:30:35Z"
        },
        {
          "user": "ANtutov",
          "body": "> lgtm ACK [e71c4df](https://github.com/bitcoin/bitcoin/commit/e71c4df1685131f5ab48aac6ccb07ac944e91e9f)\r\n> \r\n> Sorry for causing some confusion earlier.\r\n\r\nI'm grateful to you cause i was confused a bit",
          "created_at": "2025-12-10T17:35:27Z"
        }
      ]
    },
    {
      "number": 33961,
      "title": "script: Add a separate ScriptError for empty pubkeys encountered in Tapscript",
      "body": "We currently have two callsites for `SCRIPT_ERR_PUBKEYTYPE`:\r\n- A pre-tapscript policy error behind the `SCRIPT_VERIFY_STRICTENC` flag: https://github.com/bitcoin/bitcoin/blob/4de26b111f4d9b116d0d4930f8bbd69889b3cf75/src/script/interpreter.cpp#L220\r\n- A [consensus error](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki?plain=1#L93) in Tapscript: https://github.com/bitcoin/bitcoin/blob/4de26b111f4d9b116d0d4930f8bbd69889b3cf75/src/script/interpreter.cpp#L368\r\n\r\nIt would be good for readability and testability to have separate errors for both cases, as they are quite distinct (policy vs. consensus, format vs. emptiness).\r\n\r\n**This PR adds `SCRIPT_ERR_TAPSCRIPT_EMPTY_PUBKEY` for the consensus error path.**\r\n\r\nThis change would make our error handling more consistent. We have more granular errors for other pubkey error paths already: `SCRIPT_ERR_WITNESS_PUBKEYTYPE`,  `SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE`. We also have separate errors for MINIMAL_IF: `SCRIPT_ERR_MINIMALIF` for the policy error pre-tapscript, and `SCRIPT_ERR_TAPSCRIPT_MINIMALIF` for the consensus error post-tapscript.\r\n\r\nTests:\r\n\r\nAdded a test case to `script_tests` and ran `build/bin/test_bitcoin --run_test=script_tests --log_level=success`.\r\n```\r\ntest/script_tests.cpp:144: info: check '[[\"aa\",\"#SCRIPT# 0 CHECKSIG\",\"#CONTROLBLOCK#\",0.00000001],\"\",\"0x51 0x20 #TAPROOTOUTPUT#\",\"P2SH,WITNESS,TAPROOT\",\"TAPSCRIPT_EMPTY_PUBKEY\",\"TAPSCRIPT: OP_CHECKSIG with empty pubkey must fail\"] (with flags 165d5d)' has passed\r\n...\r\n```\r\n\r\nRan `DIR_UNIT_TEST_DATA=\"$(pwd)/../qa-assets/unit_test_data\" build/bin/test_bitcoin --run_test=script_assets_tests --log_level=success`.\r\n\r\nUpdated `feature_taproot.py` and ran `build/test/functional/feature_taproot.py`.\r\n\r\nLooking forward to your feedback.",
      "state": "closed",
      "user": "billymcbip",
      "created_at": "2025-11-27T15:30:47Z",
      "updated_at": "2025-12-10T15:59:45Z",
      "comments": 4,
      "url": "https://github.com/bitcoin/bitcoin/pull/33961",
      "labels": [
        "Consensus"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33961.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [sedited](https://github.com/bitcoin/bitcoin/pull/33961#pullrequestreview-3542392743), [darosior](https://github.com/bitcoin/bitcoin/pull/33961#pullrequestreview-3545098441), [sipa](https://github.com/bitcoin/bitcoin/pull/33961#pullrequestreview-3545113694) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-11-27T15:30:55Z"
        },
        {
          "user": "billymcbip",
          "body": "Also updated`feature_taproot.py` and ran `build/test/functional/feature_taproot.py`. Can we re-run CI?",
          "created_at": "2025-11-27T16:29:48Z"
        },
        {
          "user": "darosior",
          "body": "Force-push gone wrong @billymcbip? Or is this intentional?",
          "created_at": "2025-12-07T15:40:32Z"
        },
        {
          "user": "billymcbip",
          "body": "@darosior that was unintentional, sorry! I still intend to ship 9d5021a.",
          "created_at": "2025-12-07T15:51:23Z"
        }
      ]
    },
    {
      "number": 33960,
      "title": "log: Use more severe log level (warn/err) where appropriate",
      "body": "Logging supports severity levels above info via the legacy `LogPrintf`. So use the more appropriate `LogError` or `LogWarning`, where it applies.\r\n\r\nThis has a few small benefits:\r\n\r\n* It often allows to remove the manual and literal \"error: \", \"Warning:\", ... prefixes. Instead the uniform log level formatting is used.\r\n* It is easier to grep or glance for more severe logs, which indicate some kind of alert.\r\n* `LogPrintf` didn't indicate any severity level, but it is an alias for `LogInfo`. So having the log level explicitly spelled out makes it easier to read the code.\r\n* Also, remove the redundant trailing `\\n` newline, while touching.\r\n* Also, remove the `__func__` formatting in the log string, which is redundant with `-logsourcelocations`. Instead, use a unique log string for each location.",
      "state": "closed",
      "user": "maflcko",
      "created_at": "2025-11-27T10:05:12Z",
      "updated_at": "2025-12-05T10:33:39Z",
      "comments": 7,
      "url": "https://github.com/bitcoin/bitcoin/pull/33960",
      "labels": [
        "Utils/log/libs"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33960.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [l0rinc](https://github.com/bitcoin/bitcoin/pull/33960#issuecomment-3586103150), [rkrux](https://github.com/bitcoin/bitcoin/pull/33960#pullrequestreview-3517968266), [stickies-v](https://github.com/bitcoin/bitcoin/pull/33960#issuecomment-3601835371) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33813](https://github.com/bitcoin/bitcoin/pull/33813) (init: Changing the rpcbind argument being ignored to a pop up warning by Ataraxia009)\n* [#33689](https://github.com/bitcoin/bitcoin/pull/33689) (http: replace WorkQueue and single threads handling for ThreadPool by furszy)\n* [#33680](https://github.com/bitcoin/bitcoin/pull/33680) (validation: do not wipe utxo cache for stats/scans/snapshots by l0rinc)\n* [#33646](https://github.com/bitcoin/bitcoin/pull/33646) (log: check fclose() results and report safely in logging.cpp by cedwies)\n* [#33553](https://github.com/bitcoin/bitcoin/pull/33553) (validation: Improve warnings in case of chain corruption by mzumsande)\n* [#33414](https://github.com/bitcoin/bitcoin/pull/33414) (tor: enable PoW defenses for automatically created hidden services by vasild)\n* [#33192](https://github.com/bitcoin/bitcoin/pull/33192) (refactor: unify container presence checks by l0rinc)\n* [#33034](https://github.com/bitcoin/bitcoin/pull/33034) (wallet: Store transactions in a separate sqlite table by achow101)\n* [#33033](https://github.com/bitcoin/bitcoin/pull/33033) (wallet, sqlite: Encapsulate SQLite statements in a RAII class by achow101)\n* [#32685](https://github.com/bitcoin/bitcoin/pull/32685) (wallet: Allow read-only database access for info and dump commands by PeterWrighten)\n* [#32387](https://github.com/bitcoin/bitcoin/pull/32387) (ipc: add windows support by ryanofsky)\n* [#32317](https://github.com/bitcoin/bitcoin/pull/32317) (kernel: Separate UTXO set access from validation functions by sedited)\n* [#32297](https://github.com/bitcoin/bitcoin/pull/32297) (bitcoin-cli: Add -ipcconnect option by ryanofsky)\n* [#32061](https://github.com/bitcoin/bitcoin/pull/32061) (Replace libevent with our own HTTP and socket-handling implementation by pinheadmz)\n* [#30214](https://github.com/bitcoin/bitcoin/pull/30214) (refactor: Improve assumeutxo state representation by ryanofsky)\n* [#29700](https://github.com/bitcoin/bitcoin/pull/29700) (kernel, refactor: return error status on all fatal errors by ryanofsky)\n* [#29641](https://github.com/bitcoin/bitcoin/pull/29641) (scripted-diff: Use LogInfo over LogPrintf [WIP, NOMERGE, DRAFT] by maflcko)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-11-27T10:05:20Z"
        },
        {
          "user": "maflcko",
          "body": "thx, fixed all, except for those that are dead code anyway (left a reply there in the review thread)",
          "created_at": "2025-11-27T12:39:04Z"
        },
        {
          "user": "rkrux",
          "body": "Maybe can also mention this benefit in the PR description that `LogPrintf` was unconditional logging that was deprecated while `LogError` and `LogWarning` use basic rate limiting to mitigate disk filling attacks.\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/38c8474d0d774b1ed5d6139a9fec9933a6cfc099/src/logging.h#L364-L373",
          "created_at": "2025-11-27T12:52:25Z"
        },
        {
          "user": "maflcko",
          "body": "> Maybe can also mention this benefit in the PR description that `LogPrintf` was unconditional logging that was deprecated while `LogError` and `LogWarning` use basic rate limiting to mitigate disk filling attacks.\r\n\r\nI don't think this is correct. You can see from the code you quoted that the legacy one is just an alias for the one \"modern\" one. Also, all three have `/*should_ratelimit=*/true`.",
          "created_at": "2025-11-27T13:08:04Z"
        },
        {
          "user": "rkrux",
          "body": "Ah, you are correct. I got carried away by the code comment below and assumed the code is like below (`LogPrintLevel` instead of `LogInfo`):\r\n\r\n```cpp\r\n// Deprecated unconditional logging. \r\n#define LogPrintf(...) LogPrintLevel_(__VA_ARGS__) \r\n```",
          "created_at": "2025-11-27T13:18:58Z"
        },
        {
          "user": "l0rinc",
          "body": "Code review ACK fa45a1503eee603059166071857215ea9bd7242a",
          "created_at": "2025-11-27T14:16:58Z"
        },
        {
          "user": "stickies-v",
          "body": "ACK fa45a1503eee603059166071857215ea9bd7242a",
          "created_at": "2025-12-02T12:40:54Z"
        }
      ]
    },
    {
      "number": 33959,
      "title": "test: use ForkGenerator to deduplicate reorg test code",
      "body": "Deduplicate reorg test code by introducing `ForkGenerator` utility class in `blocktools.py`.\r\n\r\n### Changes\r\n  - Add `ForkGenerator` class with `prepare_fork()` / `trigger_reorg()` / `reset()` methods\r\n  - Removes duplicated `trigger_reorg()` methods across tests\r\n  - Update mempool tests to use the new utility\r\n  \r\nFor now I am keeping it as draft as we need to address other tests to eliminate use of `invalidate_block` for reorg scenario. Also, optional args for non-empty forks to test mix-and-match cases of transactions re-entering mempool as suggested by instagibbs in https://github.com/bitcoin/bitcoin/pull/32587#issuecomment-3549356286.",
      "state": "open",
      "user": "yuvicc",
      "created_at": "2025-11-27T05:49:29Z",
      "updated_at": "2025-12-13T11:05:39Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/pull/33959",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33959.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#33616](https://github.com/bitcoin/bitcoin/pull/33616) (policy: don't CheckEphemeralSpends on reorg by instagibbs)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->\n### LLM Linter (âœ¨ experimental)\n\n\n\nPossible typos and grammar issues:\n\n- triggered.. -> triggered. [Double period at end of sentence in the ForkGenerator class docstring makes the sentence look like a typo and may distract; replace with a single period.]\n\n\n\n<sup>2025-12-13</sup>\n",
          "created_at": "2025-11-27T05:49:37Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 33964,
      "title": "Startup crash on macOS with GCC 15.2: `std::source_location::file_name()` is `nullptr`",
      "body": "### Summary\n\n`bitcoind` crashes on startup when built with Homebrew `GCC 15.2.0 `on macOS (arm64).\nThe crash occurs inside `SourceLocationHasher::operator()` when constructing a `std::basic_string_view` from `std::source_location::file_name()`.\n\nThe same commit runs successfully when built with the default `AppleClang` toolchain.\n\n### Versions\n\n* Bitcoin Core: `master` at `808f1d972be35f4c66bdc30ab0f4060dab0c43c0`\n* Platform: macOS 26.1 (25B78), Apple M4 Pro (arm64)\n* CMake: `cmake version 4.2.0`\n* GCC: `gcc (Homebrew GCC 15.2.0) 15.2.0`\n* AppleClang: `AppleClang 17.0.0.17000404`\n\n### Build configuration (GCC 15.2, Debug)\n\n```sh\ngit checkout 808f1d972be35f4c66bdc30ab0f4060dab0c43c0\nrm -rfd build && cmake -B build -DENABLE_IPC=OFF -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++ && cmake --build build -j$(nproc)             \nlldb ./build/bin/bitcoind -- -datadir=\"$HOME/Library/Application Support/Bitcoin\" -stopatheight=21129 -dbcache=1000 -printtoconsole=1\n```\n\n### Crash session\n\n```gdb\n(lldb) run\nProcess 4126 launched: '/Users/lorinc/IdeaProjects/bitcoin/build/bin/bitcoind' (arm64)\n2025-11-27T19:01:48Z Bitcoin Core version v30.99.0-b3e2ae7aaee5 (debug build)\n2025-11-27T19:01:48Z Using the 'arm_shani(1way;2way)' SHA256 implementation\n2025-11-27T19:01:48Z Default data directory /Users/lorinc/Library/Application Support/Bitcoin\n2025-11-27T19:01:48Z Using data directory /Users/lorinc/Library/Application Support/Bitcoin\n2025-11-27T19:01:48Z Config file: /Users/lorinc/Library/Application Support/Bitcoin/bitcoin.conf (not found, skipping)\n2025-11-27T19:01:48Z Command-line arg: datadir=\"/Users/lorinc/Library/Application Support/Bitcoin\"\n2025-11-27T19:01:48Z Command-line arg: dbcache=\"1000\"\n2025-11-27T19:01:48Z Command-line arg: printtoconsole=\"1\"\n2025-11-27T19:01:48Z Command-line arg: stopatheight=\"21129\"\n2025-11-27T19:01:48Z Using at most 125 automatic connections (1024 file descriptors available)\n2025-11-27T19:01:48Z scheduler thread start\n2025-11-27T19:01:48Z Binding RPC on address ::1 port 8332\n2025-11-27T19:01:48Z Binding RPC on address 127.0.0.1 port 8332\n2025-11-27T19:01:48Z Generated RPC authentication cookie /Users/lorinc/Library/Application Support/Bitcoin/.cookie\n2025-11-27T19:01:48Z Permissions used for cookie: rw-------\n2025-11-27T19:01:48Z Using random cookie authentication.\n2025-11-27T19:01:48Z Starting HTTP server with 16 worker threads\nProcess 4126 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n    frame #0: 0x000000019fb3ca84 libsystem_platform.dylib`_platform_strlen + 4\nlibsystem_platform.dylib`_platform_strlen:\n->  0x19fb3ca84 <+4>:  ldr    q0, [x1]\n    0x19fb3ca88 <+8>:  adr    x3, 0x19fb3c9c0 ; ___lldb_unnamed_symbol_1804e09c0\n    0x19fb3ca8c <+12>: ldr    q2, [x3], #0x10\n    0x19fb3ca90 <+16>: and    x2, x0, #0xf\n(lldb) bt\nerror: libbitcoin_util.a(logging.cpp.o) 0x4000ec000000034a: DW_TAG_member '_M_local_buf' refers to type 0x00000000000fed84 which extends beyond the bounds of 0x4000ec0000000340\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=1, address=0x0)\n  * frame #0: 0x000000019fb3ca84 libsystem_platform.dylib`_platform_strlen + 4\n    frame #1: 0x0000000100002600 bitcoind`std::char_traits<char>::length(__s=0x0000000000000000) at char_traits.h:393:25\n    frame #2: 0x00000001000086d0 bitcoind`std::basic_string_view<char, std::char_traits<char>>::basic_string_view(this=0x000000016fdfa1b8, __str=0x0000000000000000) at string_view:145:35\n    frame #3: 0x0000000100f43634 bitcoind`SourceLocationHasher::operator()(this=0x000000081286d8a0, s=0x000000016fdfa820) const at logging.h:52:74\n    frame #4: 0x0000000100f554c0 bitcoind`std::__detail::_Hash_code_base<std::source_location, std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>, std::__detail::_Select1st, SourceLocationHasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, false>::_M_hash_code(this=0x000000081286d8a0, __k=0x000000016fdfa820) const at hashtable_policy.h:1071:23\n    frame #5: 0x0000000100f50a08 bitcoind`std::_Hashtable<std::source_location, std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>, std::allocator<std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>>, std::__detail::_Select1st, SourceLocationEqual, SourceLocationHasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::_M_locate(this=0x000000081286d8a0, __k=0x000000016fdfa820) const at hashtable.h:2279:46\n    frame #6: 0x0000000100f4d3ec bitcoind`std::pair<std::__detail::_Node_iterator<std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>, false, false>, bool> std::_Hashtable<std::source_location, std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>, std::allocator<std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>>, std::__detail::_Select1st, SourceLocationEqual, SourceLocationHasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true>>::try_emplace<std::source_location const&, unsigned long long const&>(this=0x000000081286d8a0, (null)=std::_Hashtable<std::source_location, std::pair<const std::source_location, BCLog::LogRateLimiter::Stats>, std::allocator<std::pair<const std::source_location, BCLog::LogRateLimiter::Stats> >, std::__detail::_Select1st, SourceLocationEqual, SourceLocationHasher, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::const_iterator @ 0x000000016fdfa2a0, __k=0x000000016fdfa820, (null)=0x000000081286d8e0) at hashtable.h:1088:30\n    frame #7: 0x0000000100f4ac1c bitcoind`std::pair<std::__detail::_Node_iterator<std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>, false, false>, bool> std::unordered_map<std::source_location, BCLog::LogRateLimiter::Stats, SourceLocationHasher, SourceLocationEqual, std::allocator<std::pair<std::source_location const, BCLog::LogRateLimiter::Stats>>>::try_emplace<unsigned long long const&>(this=size=0, __k=0x000000016fdfa820, (null)=0x000000081286d8e0) at unordered_map.h:527:27\n    frame #8: 0x0000000100f47510 bitcoind`BCLog::LogRateLimiter::Consume(this=0x000000081286d860, source_loc=0x000000016fdfa820, str=\"2025-11-27T19:01:48Z Using wallet directory /Users/lorinc/Library/Application Support/Bitcoin/wallets\\n\") at logging.cpp:395:47\n    frame #9: 0x0000000100f47e20 bitcoind`BCLog::Logger::LogPrintStr_(this=0x0000000812820c80, str=(_M_len = 80, _M_str = \"Using wallet directory /Users/lorinc/Library/Application Support/Bitcoin/wallets\"), source_loc=0x000000016fdfa820, category=ALL, level=Info, should_ratelimit=true) at logging.cpp:465:39\n    frame #10: 0x0000000100f47a24 bitcoind`BCLog::Logger::LogPrintStr(this=0x0000000812820c80, str=(_M_len = 80, _M_str = \"Using wallet directory /Users/lorinc/Library/Application Support/Bitcoin/wallets\"), source_loc=0x000000016fdfa820, category=ALL, level=Info, should_ratelimit=true) at logging.cpp:426:24\n    frame #11: 0x000000010001daec bitcoind`void LogPrintFormatInternal<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>(source_loc=0x000000016fdfa820, flag=ALL, level=Info, should_ratelimit=true, fmt=(fmt = \"Using wallet directory %s\"), (null)=\"/Users/lorinc/Library/Application Support/Bitcoin/wallets\") at logging.h:358:34\n    frame #12: 0x000000010098b85c bitcoind`wallet::VerifyWallets(context=0x00000008130101c8) at load.cpp:53:5\n    frame #13: 0x0000000100931d4c bitcoind`wallet::(anonymous namespace)::WalletLoaderImpl::verify(this=0x00000008130101c0) const at interfaces.cpp:558:50\n    frame #14: 0x0000000100173c10 bitcoind`AppInitMain(node=0x000000016fdfea08, tip_info=0x0000000000000000) at init.cpp:1523:28\n    frame #15: 0x0000000100009820 bitcoind`AppInit(node=0x000000016fdfea08) at bitcoind.cpp:242:54\n    frame #16: 0x0000000100009c54 bitcoind`main(argc=5, argv=0x000000016fdff1c0) at bitcoind.cpp:283:17\n    frame #17: 0x000000019f76dd54 dyld`start + 7184\n```\n\nOn this toolchain, `file_name()` returns a null pointer, so `std::basic_string_view` calls `std::char_traits<char>::length(__s = 0x0)` â†’ `strlen(nullptr)`, which triggers `EXC_BAD_ACCESS`.\n\n---\n\nAccording to [cppreference for `std::source_location::file_name`](https://en.cppreference.com/w/cpp/utility/source_location/file_name), the function is specified to:\n\n> Return the name of the current source file represented by this object, represented as a null-terminated byte string.",
      "state": "closed",
      "user": "l0rinc",
      "created_at": "2025-11-27T19:44:15Z",
      "updated_at": "2025-12-01T09:53:21Z",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/issues/33964",
      "labels": [
        "macOS",
        "Upstream",
        "Questions and Help"
      ],
      "comment_list": [
        {
          "user": "maflcko",
          "body": "Your toolchain clearly violates the C++ standard (https://eel.is/c++draft/support.srcloc#class.general-2), so you'll have to report this upstream via a minimal reproducer.",
          "created_at": "2025-11-27T20:33:33Z"
        },
        {
          "user": "l0rinc",
          "body": "Tried getting to the bottom of it, something's really off here, two consecutive calls to `std::source_location::current()` return very different and suspicious values:\n<img width=\"902\" height=\"584\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/cbd0798c-c86a-44f2-8874-618a2676dff8\" />\n\nWhat does `BTC` file name and `sat` function name refer to and why do we have millions of lines :/?\n\nThey seem to come from (modifying these strings updates the file and method names):\nhttps://github.com/bitcoin/bitcoin/blob/966666de9a6211b8748f43d682490c924e132e58/src/policy/feerate.h#L18-L19\n\n<details>\n<summary>source_location::current() manual instrumentation</summary>\n\n```patch\ndiff --git a/src/bitcoind.cpp b/src/bitcoind.cpp\nindex 37cacb2a7e..19a9523322 100644\n--- a/src/bitcoind.cpp\n+++ b/src/bitcoind.cpp\n@@ -239,6 +239,10 @@ static bool AppInit(NodeContext& node)\n             // If locking a directory failed, exit immediately\n             return false;\n         }\n+\n+        auto x = std::source_location::current();\n+        std::cout << \"AppInit called from \" << x.file_name() << \":\" << x.line() << \"\\n\";\n+\n         fRet = AppInitInterfaces(node) && AppInitMain(node);\n     }\n     catch (const std::exception& e) {\n@@ -279,6 +283,9 @@ MAIN_FUNCTION\n     // Process early info return commands such as -help or -version\n     if (ProcessInitCommands(*init, args)) return EXIT_SUCCESS;\n \n+    auto x = std::source_location::current();\n+    std::cout << \"main called from \" << x.file_name() << \":\" << x.line() << \"\\n\";\n+\n     // Start application\n     if (!AppInit(node) || !Assert(node.shutdown_signal)->wait()) {\n         node.exit_status = EXIT_FAILURE;\ndiff --git a/src/init.cpp b/src/init.cpp\nindex d1c6a5cad0..2c446785b0 100644\n--- a/src/init.cpp\n+++ b/src/init.cpp\n@@ -1518,6 +1518,10 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             return InitError(_(\"Unable to start HTTP server. See debug log for details.\"));\n     }\n \n+    auto x = std::source_location::current();\n+    std::cout << \"AppInitMain called from \" << x.file_name() << \":\" << x.line() << \"\\n\";\n+\n+\n     // ********************************************************* Step 5: verify wallet database integrity\n     for (const auto& client : node.chain_clients) {\n         if (!client->verify()) {\ndiff --git a/src/wallet/interfaces.cpp b/src/wallet/interfaces.cpp\nindex 2cda1ba299..b353b51f28 100644\n--- a/src/wallet/interfaces.cpp\n+++ b/src/wallet/interfaces.cpp\n@@ -555,7 +555,13 @@ public:\n             m_rpc_handlers.emplace_back(m_context.chain->handleRpc(m_rpc_commands.back()));\n         }\n     }\n-    bool verify() override { return VerifyWallets(m_context); }\n+    bool verify() override\n+    {\n+        auto x = std::source_location::current();\n+        std::cout << \"verify called from \" << x.file_name() << \":\" << x.line() << \"\\n\";\n+\n+        return VerifyWallets(m_context);\n+    }\n     bool load() override { return LoadWallets(m_context); }\n     void start(CScheduler& scheduler) override\n     {\ndiff --git a/src/wallet/load.cpp b/src/wallet/load.cpp\nindex f362064473..8a6a237d1d 100644\n--- a/src/wallet/load.cpp\n+++ b/src/wallet/load.cpp\n@@ -26,6 +26,12 @@ using util::Join;\n namespace wallet {\n bool VerifyWallets(WalletContext& context)\n {\n+    auto x1 = std::source_location::current();\n+    std::cout << \"VerifyWallets1 called from \" << x1.file_name() << \":\" << x1.line() << \"\\n\";\n+\n+    auto x = std::source_location::current();\n+    std::cout << \"VerifyWallets called from \" << x.file_name() << \":\" << x.line() << \"\\n\";\n+\n     interfaces::Chain& chain = *context.chain;\n     ArgsManager& args = *Assert(context.args);\n\n```\n\n</details>\n\nThe stack parents seem to be evaluated correctly, but `VerifyWallets` starts returning weird values from the start:\n```\nmain called from ./bitcoind.cpp:286\nAppInit called from ./bitcoind.cpp:243\nAppInitMain called from ./init.cpp:1521\nverify called from ./wallet/interfaces.cpp:560\nVerifyWallets1 called from BTC:4412482\n```\n\n\n-----\n\nDoing the same with default AppleClang works correctly:\n\n<img width=\"1111\" height=\"585\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/e941f630-ff1e-4c47-9076-a93839912570\" />\n\n-----\n\nI'm not sure how to create a reproducer for this...",
          "created_at": "2025-11-30T11:53:21Z"
        },
        {
          "user": "maflcko",
          "body": "> I'm not sure how to create a reproducer for this...\n\nFor toolchain bugs, it helps to create a minimal reproducer. Often, this is easy to create in one shot, looking at the code that mis-compiled.\n\nSometimes, it is not so easy and you'll have to manually remove chunks from the full software, until you end up with something minimal. This may be tedious, when done manually. You can also use `creduce`, but this may not work in contexts where one can define a unique bug signature (https://github.com/bitcoin/bitcoin/issues/32276#issuecomment-2812024548).\n\nIn theory, it should be possible to move the runtime bug to a compile time bug with a `static_assert(std::string_view{__FILE__}== std::string_view{std::source_location::current().file_name()});`, so that it can be fed into `creduce`, but I have a feeling that the bug disappears at compile time. In that case, I don't see an easier way to reduce it. \n",
          "created_at": "2025-12-01T08:35:22Z"
        },
        {
          "user": "maflcko",
          "body": "Unrelated, you can also try different version of your gcc package, to see if this was introduced recently.",
          "created_at": "2025-12-01T08:35:56Z"
        },
        {
          "user": "l0rinc",
          "body": "Not sure how to create a reliable reproducer for this, closing for now",
          "created_at": "2025-12-01T09:53:21Z"
        }
      ]
    },
    {
      "number": 33958,
      "title": "Net split meta issue",
      "body": "Note: This is just a thought dump for now.. an attempt at a high-level roadmap based on an initial POC and the feedback I've gathered thus far. I will edit this meta issue frequently as a real roadmap takes shape.\n\nThe goal of this project to cleanly separate the net/net_processing layers, so that neither depends on the implementation details of the other.\n\nIn order to achieve that, we'll need to de-tangle the two subsystems (namely `CConnman` and `PeerManager`) and connect them instead via abstract interfaces.\n\nAn (ugly) initial POC can be seen here: https://github.com/theuni/bitcoin/tree/multiprocess_p2p. Note that it will likely not be rebased because it was not intended to be used as-is. Instead, chunks will be extracted and PR'd separately.\n\nThe above POC takes the split even further, moving all p2p logic into a separate binary, and communicating over IPC. This is not a goal of this project, but it does highlight how useful the split is.\n\n## Major Projects:\n\n### Reduce `PeerManager`'s usage of `CNode`\nThe main hurdle for creating a clean separation between `CConnman` and `PeerManager` is the fact that `CNode` is used by both.\n\n`CNode` is an implementation detail of `CConnman`, and its leakage causes (among other things) lifetime and locking issues. The `Peer` structure was created years ago, with the [intention that it would hold the state](https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp#L219) that `PeerManager` cares about. Unfortunately, this work was never complete.\n\n**So the first chunk of work is moving the necessary state from `CNode` to `Peer`**. In many cases, the logic belongs purely at one layer or another. In others (for ex, node id, connection time, etc), both layers will keep copies.\n\nIn order to do that cleanly, some helper functions will move out of `CConnman`/`CNode` and into `PeerManager`/`Peer`, and others will be split into generic helpers used by both layers.\n\n### Move the message handling loop to `PeerManager`\n\nWhen `PeerManager`'s dependency on `CConnman`/`CNode` is reduced to a reasonably small surface, the message handling loop can be move out of `CConnman`.\nRather than iterating all `CNode`s, it will now iterate all `Peer`s. Ugliness like `ForNode`/`ForEachNode` can be removed.\n\n### Dropped usage of `CNode` in `PeerManager`\n\nWith the event loop moved and nascent interfaces beginning to take shape, `PeerManager` should be able to operate without `CNode`. At this point, all of `CConnman`'s public-facing functions will take a `NodeId` rather than `CNode` pointer.\n\n### Virtual interfaces and dropped includes\n\nLastly, the layers will be severed, includes dropped, and they will only communicate via virtual interfaces. `PeerMan`'s `NetEventsInterface` will be filled in, and `CConnman` will implement a new virtual interface.\n\n## Outstanding questions\n\n(This list will expand as the project moves along)\n\n### Unit tests and fuzzers\nIt's not immediately obvious what should happen to tests and fuzzers which rely on:\n- `CNode`'s internals\n- Assumptions about `CConnman`/`PeerManager` behavior\n- Assumptions about layer violations between the two\n\nMANY tests rely on implementation details. Those tests are in conflict with the aim of this project, which is to largely turn those subsystems into black boxes. However, this actually makes the tests _easier_ and _more functional_, because it becomes possible to test a specific behavior without having to resort to hacking the implementation.\n\nAs an example, because `PeerManager`'s `NodeConnected` interface function will now require all of the properties of the connected node, it becomes easier to specify (fake) an exact node configuration without actually creating a node with those properties.\n\nRather than modifying the existing unit tests and fuzzers to work as-is, I think it makes sense to take advantage of the new functionality. Likely as the project progresses and paradigms change, some tests will be modified and others will be dropped/rewritten entirely.",
      "state": "open",
      "user": "theuni",
      "created_at": "2025-11-27T00:17:28Z",
      "updated_at": "2025-12-09T08:53:46Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/issues/33958",
      "labels": [
        "Brainstorming",
        "Refactoring",
        "Tests",
        "P2P",
        "Tracking Issue"
      ],
      "comment_list": [
        {
          "user": "ajtowns",
          "body": "> Reduce `PeerManager`'s usage of `CNode`\n> Move the message handling loop to `PeerManager`\n\nBig fan of these aspects. I like the documentation aspect of NetManagerEvents. Would like to see the PeerManager functions move towards accepting a `Peer&` (vs a `CNode*` and looking up `GetPeerRef`, or an explicit `CNode, Peer` pair) in general too.\n\n> Dropped usage of `CNode` in `PeerManager`\n> \n> With the event loop moved and nascent interfaces beginning to take shape, `PeerManager` should be able to operate without `CNode`. At this point, all of `CConnman`'s public-facing functions will take a `NodeId` rather than `CNode` pointer.\n\nI think this part is going in the wrong direction though.\n\nIn particular, I think good goals to have here are (not in priority order):\n\n 1. simplify the codebase so it's easier to understand and update\n 2. improve robustness of the codebase, so that if there are bugs, they have less impact\n 3. make the code higher performance, so that we can have more peers, and/or run on cheaper hardware\n\nGetting a better division between `Connman` and `PeerManager` is great for the first point. I don't think it's a big improvement in the second point -- that would come if we could separate PeerManager's parsing of random data from the internet and generally complex logic from mempool/block validation.\n\nFor the last point, I think there are two main principles we should aim for: (a) minimising the movement and reparsing of data, and (b) minimising the locking and (potentially) maximising the cache performance when we send/receive data. Currently, when we send data and don't need to block, we:\n\n * encode the message as two byte streams (the msg_type as a string and the data as a byte vector)\n * take the node's `cs_vSend` mutex, move the message into a dequeue and attempt to send the message if the socket seemed idle\n * when sending the message, we do the transport encoding, potentially converting the msg_type to a number, and queue data on the socket\n * after releasing `cs_vSend`, if we actually sent data, briefly take the global lock `m_total_bytes_sent_mutex` to track total bytes sent and bytes sent in cycle  \n\nWith the POC code, we're adding extra steps between the first two points:\n\n * pass the message and the node id to the new p2pinterface\n * if there's process separation, do a capnp encode-decode cycle and moving the data to another process over IPC\n * taking the global `m_nodes_mutex` lock and doing a search for the node id through m_nodes, and getting a shared copy of the CNode\n * doing the same logic as above\n\nSo, like I said, that seems headed in the wrong direction to me. In particular introducing IPC in between the two seems like a misfeature -- it adds complexity and lowers performance (with both extra locks and extra data movement) for not really any benefit.\n\nRather than having net_processing communicate with net via either a full CNode* or just an integer NodeId, I think a better approach would be to give it an opaque handle with a bunch of inlines, something like:\n\n```c++\nclass NodeHandle\n{\nprivate:\n    std::shared_ptr<CNode> node;\npublic:\n    friend CConnman;\n    set_disconnect() { node->fDiscconnect = true; }\n};\n\nclass CConnman\n{\n    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex);\n    inline void PushMessage(NodeHandle& nodehandle, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex)\n    {\n        PushMessage(nodehandle.node.get(), std::move(msg));\n    }\n};\n```\n\nYou've also used `NodeId` internally within net_processing; so eg `ThreadMessageHandler()` takes `node_id = peer->m_id`, then calls `ProcessMessages(node_id)` and `SendMessages(node_id)` with both immediately recovering the peer with `peer = GetPeerRef(node_id)`. Presumably that's just because those are exposed for testing but `Peer` isn't; probably could fix it by just also exposing `GetPeerRef` for testing as well, I think, and calling `if (auto p = GetPeerRef(id); p) ProcessMessages(*p);` instead of `ProcessMessages(id)`?\n\n> Lastly, the layers will be severed, includes dropped, and they will only communicate via virtual interfaces. \n\nAs above, I don't really think severing the layers is a good idea (at least for process separation reasons, maybe for testing harnesses though?), but I think you could make `NodeHandle` a virtual interface fairly reasonably if it were, while still keeping things quite fast when it's implemented as a lightweight handle to a `CNode*`.\n\nWhile thinking about this, I've been looking at two other aspects, which I'd like to mention for possible discussion:\n\n`NetMsgType::ADDR` etc are currently constant strings (with SSO they'll avoid allocations at least though), so as a result, net_processing has to sanitize them when logging, and when tracking message bytes, we use a `map<string,int>` to keep track of them, and likewise have an `unordered_map<string,uint8_t>` for the transport v2 message ids, which seems overly complex when we only actually care about the 30ish messages we know about in almost all situations. Changing this doesn't look like too bad a cleanup to me: https://github.com/ajtowns/bitcoin/commits/202511-enum-netmsgtype/\n\nWe have a lot of locks in the net/netproc subsystem these days  (eg, when I run a debug binary listening on mainnet, I get ~100% CPU usage sustained, mostly due to DEBUG_LOCKORDER; dropping DEBUG_LOCKORDER gets me down ~30% CPU), and it would be nice to work on reducing them, rather than adding more -- ie, having data be accessed by a single thread, rather than shared across threads. I've been looking whether we can change the way `PushMessage` etc works, so that the socket operations all happen in the socket handler thread, rather than also opportunistically from the sending thread. I think the two parts to making that work while still being low latency are (a) having a fast message queue in CNode that PeerMan can push to and Connman can pull from, and (b) a way of cheaply notifying Connman to wake up from its poll() and start sending newly queued data. Feels a fair bit like reinventing the wheel vs libevent/libuv/whatever, but I think as long as we give net_processing some sort of \"handle\" object, it can be made fairly simple/safe as well as being fast.\n\nI'd also like to get some cleanup of the Transport stuff -- even just separating it into its own module as a start maybe. In particular, if we introduce new one-byte BIP324 message-types, and have those negotiated over p2p rather than just decided at connection time, then I don't think we need the conversion between short id and msg_type to happen at the net_processing side of the queue, rather than the net side of the queue where it currently occurs, which probably means it's better to change `CNetMessage` and `CSerializedNetMsg` to contain a ~13 byte `SerializedNetMsgType` where v1 transport has the first byte as always 0, and netproc becomes responsible the short id encoding, rather than V2Transport. Probably should do that before any of the `NetMsgType` stuff above.\n\n(EDIT: concretely, moving the bip324 shortid logic to net_processing also requires moving the bytes{sent,rev}permsg logic to net_processing, which requires rpc/net's sendmsgtopeer to go through net_processing, which would involve additional lock juggling if net_processing were handling the msgproc thread rather than net. EDIT^2: Hey, success after 3 years: https://github.com/bitcoin/bips/pull/1378#discussion_r2585766526 . The locking isn't too bad as is, but would still improve slightly with the msgproc loop having access to PeerManagerImpl, and that could better ensure the std::promise stuff didn't get lost too)",
          "created_at": "2025-12-02T10:18:19Z"
        },
        {
          "user": "theuni",
          "body": "\n> In particular, I think good goals to have here are (not in priority order):\n> \n>     1. simplify the codebase so it's easier to understand and update\n> \n>     2. improve robustness of the codebase, so that if there are bugs, they have less impact\n> \n>     3. make the code higher performance, so that we can have more peers, and/or run on cheaper hardware\n> \n\nGoal #1 is a logical separation of concerns. Today, the many of interactions between `CConnman` and `PeerManager` are subtle and (I'd guess) virtually unknown to all but 2 or 3 people. In particular, issues around lifetime and disconnection.\n\n> \n> Getting a better division between `Connman` and `PeerManager` is great for the first point. I don't think it's a big improvement in the second point -- that would come if we could separate PeerManager's parsing of random data from the internet and generally complex logic from mempool/block validation.\n> \n> For the last point, I think there are two main principles we should aim for: (a) minimising the movement and reparsing of data, and (b) minimising the locking and (potentially) maximising the cache performance when we send/receive data. Currently, when we send data and don't need to block, we:\n> \n>     * encode the message as two byte streams (the msg_type as a string and the data as a byte vector)\n> \n>     * take the node's `cs_vSend` mutex, move the message into a dequeue and attempt to send the message if the socket seemed idle\n> \n>     * when sending the message, we do the transport encoding, potentially converting the msg_type to a number, and queue data on the socket\n> \n>     * after releasing `cs_vSend`, if we actually sent data, briefly take the global lock `m_total_bytes_sent_mutex` to track total bytes sent and bytes sent in cycle\n> \n\nI'm all for these goals, but I consider almost all of those things to be premature optimizations compared to the real-world bottlenecks that we currently see. As two examples, I'd challenge you to demonstrate a meaningful statistical slowdown caused by `cs_vSend` as compared to:\n- the time we take to encrypt/decrypt bip324 messages. ( I have a branch which gives us a ~3x speedup here, PR coming soon)\n- The archaic ProcessMessages/SendMessages loop as compared to multi-threaded event-based message handling\n\nI realize those seem like disjointed/unrelated arguments, but I'm trying to make a larger point: I'd rather not spend time re-factoring to avoid some map/lookup inefficiencies when we have existing massive architectural logjams.\n\n> \n> With the POC code, we're adding extra steps between the first two points:\n> \n>     * pass the message and the node id to the new p2pinterface\n> \n>     * if there's process separation, do a capnp encode-decode cycle and moving the data to another process over IPC\n> \n>     * taking the global `m_nodes_mutex` lock and doing a search for the node id through m_nodes, and getting a shared copy of the CNode\n> \n>     * doing the same logic as above\n> \n> \n> So, like I said, that seems headed in the wrong direction to me. In particular introducing IPC in between the two seems like a misfeature -- it adds complexity and lowers performance (with both extra locks and extra data movement) for not really any benefit.\n\nAgain, I'd ask that you not worry too much about the map lookups and data copies. In principle I completely agree.. if we were rewriting this all from scratch I'd prefer to aim for a zero-copy and non-pipeline-stalling implementation. But the reality is that we have heaps of tech debt that overshadow these inefficiencies.\n\nAs for the process separation.. maybe I shouldn't have even brought that up. It's something that becomes possible with this architecture, but it's a very reasonable argument that it's the wrong split. Please think of it as a toy rather than an end-goal.\n\n\n> \n> Rather than having net_processing communicate with net via either a full CNode* or just an integer NodeId, I think a better approach would be to give it an opaque handle with a bunch of inlines, something like:\n> \n> class NodeHandle\n> {\n> private:\n>     std::shared_ptr<CNode> node;\n> public:\n>     friend CConnman;\n>     set_disconnect() { node->fDiscconnect = true; }\n> };\n> \n> class CConnman\n> {\n>     void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex);\n>     inline void PushMessage(NodeHandle& nodehandle, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex)\n>     {\n>         PushMessage(nodehandle.node.get(), std::move(msg));\n>     }\n> };\n\nThis reintroduces the _exact_ lifetime issues I'm trying to remove :(\n\nAgain, compared to everything else happening in these threads, I consider avoiding an uncontested lock and map lookup to be a premature optimization. Unless it can be demonstrated that these operations even show up in a flamegraph, I don't think reintroducing the complexity of shared ownership is worth the complexity.\n\nRemember that the message handling loop is now happening in `PeerManager`, so the locking of `m_nodes_mutex` is now much less interesting. And even if it does ever show up in benchmarks, because it's only ever modified when nodes are connected/disconnected, it could be made a read/write lock.. that would ensure that it's essentially never contended.\n\nHOWEVER, I did anticipate this argument and came up with a similar solution, but with a tweak to avoid the layer violations. See here for the actual impl: https://github.com/theuni/bitcoin/commit/6a9710417d29e7eab1aa5b515bfb1b1ea0ce5b9c\n\nTl;dr: It's essentially the same thing you're suggesting above, but it looks like this (simplified, missing type safety) instead:\n```c++\nstruct NodeHandle\n{\n    std::weak_ptr<void> m_node;\n    NodeId m_id;\n};\n\nclass CConnman\n{\nprivate:\n    void PushMessage(CNode* pnode, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex);\npublic:\n    inline void PushMessage(const NodeHandle& nodehandle, CSerializedNetMsg&& msg) EXCLUSIVE_LOCKS_REQUIRED(!m_total_bytes_sent_mutex)\n    {\n        if (auto node = std::static_pointer_cast<CNode>(nodehandle.m_node.lock()); node) {\n            PushMessage(node.get(), std::move(msg));\n        }\n    }\n};\n```\n\nIt exploits `std::weak_ptr<void>` as an opaque handle (while keeping CNode's deleter).\n\nThe above has the same benefits you're after:\n- Avoids locking\n- No map lookups\n\nBut without the layer violations:\n- `PeerManager` doesn't influence `CNode` lifetimes (except for the duration of the weak->shared)\n- `PeerManager` sees a 100% opaque type.\n\n\nBut again, I consider this to be a last resort in the (imo incredibly unlikely) event that the read-lock + map lookup causes _any_ meaningful slowdown.\n\n> \n> You've also used `NodeId` internally within net_processing; so eg `ThreadMessageHandler()` takes `node_id = peer->m_id`, then calls `ProcessMessages(node_id)` and `SendMessages(node_id)` with both immediately recovering the peer with `peer = GetPeerRef(node_id)`. Presumably that's just because those are exposed for testing but `Peer` isn't; probably could fix it by just also exposing `GetPeerRef` for testing as well, I think, and calling `if (auto p = GetPeerRef(id); p) ProcessMessages(*p);` instead of `ProcessMessages(id)`?\n> \n\nI stopped short of optimizing these things in my branch. But sure, there's lots of room for optimizing things like that.\n\n> I'd also like to get some cleanup of the Transport stuff -- even just separating it into its own module as a start maybe. In particular, if we introduce new one-byte BIP324 message-types, and have those negotiated over p2p rather than just decided at connection time, then I don't think we need the conversion between short id and msg_type to happen at the net_processing side of the queue, rather than the net side of the queue where it currently occurs, which probably means it's better to change `CNetMessage` and `CSerializedNetMsg` to contain a ~13 byte `SerializedNetMsgType` where v1 transport has the first byte as always 0, and netproc becomes responsible the short id encoding, rather than V2Transport. Probably should do that before any of the `NetMsgType` stuff above.\n\nSure, this seems great. Seems to me it's 3 distinct layers anyway :)",
          "created_at": "2025-12-08T17:51:02Z"
        },
        {
          "user": "ajtowns",
          "body": "> > For the last point, I think there are two main principles we should aim for: (a) minimising the movement and reparsing of data, and (b) minimising the locking and (potentially) maximising the cache performance when we send/receive data. Currently, when we send data and don't need to block, we:\n\n> I'm all for these goals, but I consider almost all of those things to be premature optimizations compared to the real-world bottlenecks that we currently see.\n\nThe single biggest bottleneck I see today is due to `DEBUG_LOCKORDER` which takes a dev build from using ~10%-40% of a VPS core to ~100%.\n\nOtherwise, we waste a fair bit of time in `NodeSnapshot` (1.98% - mostly shuffle()), `CNodeState` lookups (1.97%), `GetPeerRef` lookups (1.01%), `GenerateWaitSockets` (3.61%), and, at least for what it does, `AccountForSentBytes` (0.11%),\n\nWe spend a lot of time doing `ProcessTransaction` (20%), `TxDownloadManager` (12.27%),`CompareInvMempoolOrder` heap ops (2.7%), `RollingBloomFilter` stuff (5.8%), and serialization and v2 en/decryption (3.06%), but at least they're all things we're actively trying to do. \n\n> As two examples, I'd challenge you to demonstrate a meaningful statistical slowdown caused by `cs_vSend` as compared to:\n\n`cs_vSend` is a per-peer lock, so I don't think it's very problematic. The main reason to look at removing it is that it's about protecting \"net\" internals and the only purpose of having the lock is to allow those internals to be touched by the msghand thread (and perhaps the rpc threads for sendmsgtopeer), rather than just the net thread, because queuing data for 50ms while waiting for the net thread to wakeup, when it could just be sent immediately is pretty lame.\n\n>     * the time we take to encrypt/decrypt bip324 messages. ( I have a branch which gives us a ~3x speedup here, PR coming soon)\n\nPresuming my percentages aren't just due to being a dev build, wow!\n \n>     * The archaic ProcessMessages/SendMessages loop as compared to multi-threaded event-based message handling\n\nI don't think ProcessMessages or SendMessages is particularly bad at present; though the NodeSnapshot and GenerateWaitSockets stuff isn't great, and maybe that's just a question of where in the stack you're assigning the blame.\n\nSwitching to a \"multi-threaded\" model is a big ask, that I think's better treated as a separate project (making tx and block processing happen async in another thread, while msg handling continues for other peers? making it possible to process multiple txs/blocks simultaneously?). But outside of changing the way we interact with validation / `cs_main`, I don't think there's a big win for the multithreaded part here, when we're only dealing with 100s of peers and maybe a few MB/s of data.\n\nMaking ProcessMessages more event oriented seems pretty plausible. :+1:\n\nMaking SendMessages more event based otoh seems somewhat more difficult; I'd like to be able to think more about that after `ThreadMessageHandler` is moved. We've got lots of `if (current_time > peer.m_next_send_feefilter)` tests which might translate well to something event based, but it seems like a lot of code movement, and doesn't seem that bad as-is, so I'm not sure.\n \n> I realize those seem like disjointed/unrelated arguments, but I'm trying to make a larger point: I'd rather not spend time re-factoring to avoid some map/lookup inefficiencies when we have existing massive architectural logjams.\n\nI look at it more the other way: it's simpler and easier to understand when functions are directly given the data they're supposed to operate on. `ProcessMessage` is meant to take a message from the wire (ie, a type and a payload) from a logical peer (ie, `Peer`) and do whatever's necessary to deal with that message. Its signature should be `ProcessMessage(Peer&, string_view, DataStream&&)` with `Peer&` giving it immediate access to everything it needs, without having to look data up, and deal with errors if that data is mysteriously unavailable.\n\nIf we're trying to simplify our net layers, we shouldn't be adding abstractions that we constantly switch between.\n\nIf we can get `ThreadMessageHandler` moved into net_processing, I think we'd be pretty close to being able make `Peer` objects private to the msghand thread -- where we currently have other threads accessing `Peer` directly (eg `UpdatedBlockTip`), I think we could change to adding to an event queue that msghand multiplexes to each (relevant) peer. (Or have the events first get multiplexed to per-msghand event queues if there are multiple msghand threads), which I think would clear up a huge bunch of locks and simplify a huge bunch of thread safety considerations, eg.\n\n> Again, I'd ask that you not worry too much about the map lookups and data copies. In principle I completely agree.. if we were rewriting this all from scratch I'd prefer to aim for a zero-copy and non-pipeline-stalling implementation. But the reality is that we have heaps of tech debt that overshadow these inefficiencies.\n> As for the process separation.. maybe I shouldn't have even brought that up. It's something that becomes possible with this architecture, but it's a very reasonable argument that it's the wrong split. Please think of it as a toy rather than an end-goal.\n\nI think passing around NodeIds instead of the actual data structures we want is adding more tech debt, and putting IPC in between message generation and sending the message on the socket would also be adding more tech debt. (Outside of the IPC POC, I think the only data copy issues are in NodeSnapshot and WaitMany, which I expect this project will improve anyway, or at least not make any worse)\n \n> > Rather than having net_processing communicate with net via either a full CNode* or just an integer NodeId, I think a better approach would be to give it an opaque handle with a bunch of inlines, something like:\n> > class NodeHandle\n> > {\n> > private:\n> > std::shared_ptr node;\n\n> This reintroduces the _exact_ lifetime issues I'm trying to remove :(\n\nI'm pretty sure if you're reworking CConnman, CNode, Peer and PeerManager you can make that arrangement work okay.\n\nWhat I was loosely thinking of is that when either PeerMan or CConnman decides it doesn't want that CNode anymore (because it's been misbehaving, or because the socket closed, eg) they set an `fDisconnect`-like flag, and when they next notice the node (whether that's due to a timeout or triggers an event), whichever hasn't already dropped it drops it now, so that the shared_ptr is freed, and CNode's various queues are released. (The socket is already closed prior to CConnman abandoning the shared_ptr)\n\nIn particular, CConnman is not invoking `NetEventsInterface::FinalizeNode(cnode)` or `m_msgproc->markNodeDisconnected(node->GetId())` in this arrangement, peerman is doing that directly when it next gets around to checking what's going on with that node, and finding that connman's already abandoned the node, and concludes it should too. It's only possible to do things that way after PeerManager has its own thread in order to iterate over its peers of course.\n\n> HOWEVER, I did anticipate this argument and came up with a similar solution, but with a tweak to avoid the layer violations. See here for the actual impl: [theuni@6a97104](https://github.com/theuni/bitcoin/commit/6a9710417d29e7eab1aa5b515bfb1b1ea0ce5b9c)\n\nI mean, that's fine, I guess, but having the `CNode` object available but closed seems better than having to check if a weak_ptr is expired. It also allows the msgproc thread to deal with any messages that were received but unprocessed at the time the socket closed. (It's especially fine if it's just an intermediate step while connman is still calling peerman's FinalizeNode)\n\n> > You've also used `NodeId` internally within net_processing; so eg `ThreadMessageHandler()` takes `node_id = peer->m_id`, then calls `ProcessMessages(node_id)` and `SendMessages(node_id)` with both immediately recovering the peer with `peer = GetPeerRef(node_id)`. Presumably that's just because those are exposed for testing but `Peer` isn't; probably could fix it by just also exposing `GetPeerRef` for testing as well, I think, and calling `if (auto p = GetPeerRef(id); p) ProcessMessages(*p);` instead of `ProcessMessages(id)`?\n> \n> I stopped short of optimizing these things in my branch. But sure, there's lots of room for optimizing things like that.\n\nDo you understand where I'm coming from when I say I don't think of that as an optimisation, but rather the natural way to write the code? If `FooClass::FuncA()` has an object `Bar b`, and `FooClass::FuncB()` wants to use that object, it should just pass it directly by calling `FuncB(b)`, rather than calling `FuncB(b.id)` and having `FuncB` have to recover it with `auto b = GetByById(id); if (!b) return;`.\n\n> > I'd also like to get some cleanup of the Transport stuff -- even just separating it into its own module as a start maybe. In particular, if we introduce new one-byte BIP324 message-types, and have those negotiated over p2p rather than just decided at connection time, then I don't think we need the conversion between short id and msg_type to happen at the net_processing side of the queue, rather than the net side of the queue where it currently occurs, which probably means it's better to change `CNetMessage` and `CSerializedNetMsg` to contain a ~13 byte `SerializedNetMsgType` where v1 transport has the first byte as always 0, and netproc becomes responsible the short id encoding, rather than V2Transport. Probably should do that before any of the `NetMsgType` stuff above.\n> \n> Sure, this seems great. Seems to me it's 3 distinct layers anyway :)\n\nI think I count five layers, fwiw:\n\n 1. socket handling: util/sock.h, b-net thread, net.h, net.cpp\n 2. wire encoding: V1Transport, V2Transport, protocol.h\n 3. message protocol: ProcessMessage / SendMessages\n 4. connection preference: ThreadOpenConnections, eviction handling\n 5. sharing policy: header/block download/announcements, TxRequestTracker, address relay\n\nMaybe 4 and 5 are both just a \"policy layer\"? I left them separate since (4) is managed by net.cpp, while (5) is exclusively net_processing.cpp; but maybe the openconnections logic should move to net_processing as well as the evictions logic? I think doing that might allow connman to stop needing NetEventsInterface entirely, and instead just use flags on CNode to communicate `markNodeDisconnected` and `markSendBufferFull(bool)`.",
          "created_at": "2025-12-08T21:29:54Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 5,
    "issues": 2
  }
}