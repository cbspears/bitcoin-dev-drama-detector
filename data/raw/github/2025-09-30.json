{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T20:18:57.948187+00:00",
  "date": "2025-09-30",
  "pull_requests": [
    {
      "number": 33511,
      "title": "init: Fix Ctrl-C shutdown hangs during wait calls",
      "body": "Signal `m_tip_block_cv` when Ctrl-C is pressed or `SIGTERM` is received, the same way it is currently signaled when the `stop` RPC is called. This lets RPC calls like `waitforblockheight` and IPC calls like `waitTipChanged` be interrupted, instead of waiting for their original timeouts and delaying shutdown.\r\n\r\nThis issue was reported by plebhash in #33463. These hangs have been present since #30409. A similar bug was also fixed previously in Qt in #18452 and this PR simplifies that fix.",
      "state": "closed",
      "user": "ryanofsky",
      "created_at": "2025-09-30T19:14:54Z",
      "updated_at": "2026-01-05T12:10:21Z",
      "comments": 11,
      "url": "https://github.com/bitcoin/bitcoin/pull/33511",
      "labels": [],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33511.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [Sjors](https://github.com/bitcoin/bitcoin/pull/33511#issuecomment-3368056941), [TheCharlatan](https://github.com/bitcoin/bitcoin/pull/33511#pullrequestreview-3302308582) |\n| Concept ACK | [enirox001](https://github.com/bitcoin/bitcoin/pull/33511#pullrequestreview-3327587204) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#29770](https://github.com/bitcoin/bitcoin/pull/29770) (index: Check all necessary block data is available before starting to sync by fjahr)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-09-30T19:15:01Z"
        },
        {
          "user": "ryanofsky",
          "body": "I'm confused by windows CI failures: [1](https://github.com/bitcoin/bitcoin/actions/runs/18140884308/job/51631167802?pr=33511) [2](https://github.com/bitcoin/bitcoin/actions/runs/18140884308/job/51631960886?pr=33511)\r\n\r\nThey seem to show py -3 test_runner.py being called, and this just with failing with no output after around 10 minutes, with CI reporting `Process completed with exit code -1073741510.` where -1073741510 is 0xc000013a or [STATUS_CONTROL_C_EXIT](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55). So it seems like sending ctrl-c to the node might be killing the whole test?\r\n\r\nEDIT:  Turns out this is expected, the test needs to start the node with creationflags=subprocess.CREATE_NEW_PROCESS_GROUP on windows, otherwise ctrl-c does kill all processes.",
          "created_at": "2025-10-01T15:12:43Z"
        },
        {
          "user": "ryanofsky",
          "body": "<!-- begin push-2 -->\r\nUpdated 4ee8e2248e54a33f0a3a2e808d46a7b0b8ea7bc3 -> 68cad90dace40f7a015ca4ff81b878fc8fdc1dd5 ([`pr/sigwait.1`](https://github.com/ryanofsky/bitcoin/commits/pr/sigwait.1) -> [`pr/sigwait.2`](https://github.com/ryanofsky/bitcoin/commits/pr/sigwait.2), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/sigwait.1..pr/sigwait.2))<!-- end --> to fix CI failures, also added more documentation and explanation in commit description\r\n",
          "created_at": "2025-10-01T17:36:15Z"
        },
        {
          "user": "Sjors",
          "body": "~ACK 68cad90dace40f7a015ca4ff81b878fc8fdc1dd5~ (see below)",
          "created_at": "2025-10-02T08:45:03Z"
        },
        {
          "user": "Sjors",
          "body": "Mmm, the GUI experience is less great (testnet4, ctrl + c from the terminal where I launched it):\r\n\r\n<img width=\"760\" height=\"558\" alt=\"Scherm¬≠afbeelding 2025-10-02 om 11 55 50\" src=\"https://github.com/user-attachments/assets/78eaf83c-b598-4fd1-abae-86aac2c47f24\" />\r\n\r\nThis seems to stay stuck.\r\n\r\nDoesn't happen on the first commit, so might be a regression.",
          "created_at": "2025-10-02T09:57:30Z"
        },
        {
          "user": "ryanofsky",
          "body": "> Mmm, the GUI experience is less great (testnet4, ctrl + c from the terminal where I launched it):\r\n> [...]\r\n> Doesn't happen on the first commit, so might be a regression.\r\n\r\nOh, thanks for testing. That does sound like a regression. Will mark as draft until this is debugged",
          "created_at": "2025-10-02T10:19:19Z"
        },
        {
          "user": "fanquake",
          "body": "> This should be backported in my opinion.\r\n\r\nNot going to block `30.0` if it's not ready, but marked for backport.",
          "created_at": "2025-10-02T15:30:46Z"
        },
        {
          "user": "ryanofsky",
          "body": "<!-- begin push-3 -->\nUpdated 68cad90dace40f7a015ca4ff81b878fc8fdc1dd5 -> c25a5e670b27d3b6eb958ce437dbe89678bd1511 ([`pr/sigwait.2`](https://github.com/ryanofsky/bitcoin/commits/pr/sigwait.2) -> [`pr/sigwait.3`](https://github.com/ryanofsky/bitcoin/commits/pr/sigwait.3), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/sigwait.2..pr/sigwait.3))<!-- end --> fixing regression in previous version that caused Qt shutdown to hang during wait calls from the GUI console",
          "created_at": "2025-10-03T20:46:14Z"
        },
        {
          "user": "Sjors",
          "body": "tACK c25a5e670b27d3b6eb958ce437dbe89678bd1511\r\n\r\nIt's also a nice simplification.",
          "created_at": "2025-10-04T09:08:18Z"
        },
        {
          "user": "sedited",
          "body": "rfm?",
          "created_at": "2025-10-31T12:07:16Z"
        },
        {
          "user": "fanquake",
          "body": "Backported to 30.x in #34192.",
          "created_at": "2026-01-05T12:10:18Z"
        }
      ]
    },
    {
      "number": 33509,
      "title": "ci: Check macos-cross executables on macOS",
      "body": "Currently, the cross-compiled exe files for Windows are tested in CI on a native Windows VM. However, the same is not done for the cross-compiled macOS executables.\r\n\r\nThis will add about 17 minutes of additional sequential CI delay, and I am not sure if it will ever catch an issue.\r\n\r\nSo leaving as draft for now.",
      "state": "closed",
      "user": "maflcko",
      "created_at": "2025-09-30T11:19:54Z",
      "updated_at": "2025-10-09T10:06:31Z",
      "comments": 6,
      "url": "https://github.com/bitcoin/bitcoin/pull/33509",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33509.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Concept ACK | [katesalazar](https://github.com/bitcoin/bitcoin/pull/33509#issuecomment-3352353279), [hodlinator](https://github.com/bitcoin/bitcoin/pull/33509#pullrequestreview-3288065733) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#32380](https://github.com/bitcoin/bitcoin/pull/32380) (Modernize use of UTF-8 in Windows code by hebasto)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-09-30T11:20:02Z"
        },
        {
          "user": "katesalazar",
          "body": "Concept ACK\r\n",
          "created_at": "2025-09-30T14:04:08Z"
        },
        {
          "user": "maflcko",
          "body": "> Since we don't have high hopes of this actually detecting any issues that the rest of the CI would not have found, seems to make more sense as a nightly job?\r\n\r\nThx, done in https://github.com/bitcoin/bitcoin/pull/33549 and https://github.com/maflcko/b-c-nightly/actions/runs/18282485376/job/52056370818",
          "created_at": "2025-10-06T15:06:17Z"
        },
        {
          "user": "fanquake",
          "body": "It's not completely clear to me why we should have cross tests for Windows, but not for macOS, regardless of how-likely we think they are to find issues (or the runtime). Putting things in nightly repos also increases the likelyhood of double-handling changes, to fix things later (also assuming they are reported).\r\n\r\n> Since we don't have high hopes of this actually detecting any issues that the rest of the CI would not have found, seems to make more sense as a nightly job?\r\n\r\n@hodlinator could you elaborate on this? Why do we think the rest of the CI would detect issues in the cross-compiled binaries, if the other macOS CIs are using a different compiler, dependencies, build logic, SDK etc?",
          "created_at": "2025-10-08T10:03:38Z"
        },
        {
          "user": "maflcko",
          "body": "I just wonder if there ever was a single issue found if this was run in the CI in the past.\r\n\r\nIf this has never found an issue, the overhead doesn't seem worth it:\r\n\r\n* It adds a 17 minute sequential spinner to the CI\r\n* The new code requires maintenance\r\n* The new task requires occasional manual re-runs due to https://github.com/bitcoin/bitcoin/pull/33303#discussion_r2391749840\r\n* GHA macOS VM provisioning may fail (seen twice in the last week), which requires even more manual re-runs\r\n* Intermittent network issues may occur (https://github.com/bitcoin/bitcoin/actions/runs/18354969551/job/52284525147?pr=32606#step:9:447), which requires even more manual re-runs\r\n\r\nI can understand the desire to test as much as possible, but it will never be possible to test everything, so we'll have to accept and decide where to stop.\r\n\r\nI'd say any platform config that exposes less than 1 issue per year should not be added to the main CI, but I am happy to hear other thoughts.",
          "created_at": "2025-10-08T10:51:57Z"
        },
        {
          "user": "hodlinator",
          "body": "Broadly agree with maflcko. Despite WSL (not sure of the status of that on CI), Windows is overall less similar to Linux than macOS is to Linux, so it is probably more likely to uncover issues.\r\n\r\nI guess the downside of nightly is that figuring out which commit introduces a failure lands on build-oriented people. Until we learn CI to git bisect. So assuming that CI-cost is low, I can see how this PR may be preferable. Maybe there's a middle ground of only running upon merge into master?",
          "created_at": "2025-10-08T14:10:18Z"
        }
      ]
    },
    {
      "number": 33508,
      "title": "ci: fix buildx gha cache authentication on forks",
      "body": "When using `docker buildx build` in conjunction with the `gha` backend cache type (as we do in our CI) it's important to specify the URL and TOKEN needed to authenticate.\r\n\r\nOn Cirrus runners this is working with only `ACTIONS_CACHE_URL` and `ACTIONS_RUNTIME_TOKEN`, but this is not enough for the GitHub backend.\r\n\r\nFix this by exporting all `ACTIONS_*` variables.\r\n\r\nThis fixes docker build layer cache restore/save on forks or where GH-hosted runners are being used, and addresses https://github.com/bitcoin/bitcoin/issues/31965#issuecomment-3324707093",
      "state": "closed",
      "user": "willcl-ark",
      "created_at": "2025-09-30T10:32:58Z",
      "updated_at": "2025-10-14T09:03:50Z",
      "comments": 15,
      "url": "https://github.com/bitcoin/bitcoin/pull/33508",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33508.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [m3dwards](https://github.com/bitcoin/bitcoin/pull/33508#issuecomment-3352975826), [maflcko](https://github.com/bitcoin/bitcoin/pull/33508#issuecomment-3400597071) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-09-30T10:33:05Z"
        },
        {
          "user": "willcl-ark",
          "body": "Fork run ongoing at: https://github.com/willcl-ark/bitcoin/actions/runs/18126864863",
          "created_at": "2025-09-30T10:33:21Z"
        },
        {
          "user": "m3dwards",
          "body": "ACK bc706955d740f8a59bec78e44d33e80d1cca373b\r\n\r\n> Fork run ongoing at: https://github.com/willcl-ark/bitcoin/actions/runs/18126864863\r\n\r\nAs it wasn't master, I've also pushed to my master to also check writing to the cache: https://github.com/m3dwards/bitcoin/actions/runs/18136688725/job/51617223612\r\n\r\nAnd I can see all is well:\r\n\r\n```shell\r\n#12 exporting to GitHub Actions Cache\r\n#12 preparing build cache for export\r\n#12 writing layer sha256:a671ea418149154b4e0f1d5670be077da1a48f411402479d8fc137a1c67bf6d2 0.1s done\r\n#12 writing layer sha256:c6b11972fd12973831818babf60f1ffc1c4047507943d132dffc612884022858\r\n#12 writing layer sha256:c6b11972fd12973831818babf60f1ffc1c4047507943d132dffc612884022858 1.7s done\r\n#12 writing layer sha256:e572ff1033a9e16138dc22bcb7ccb2463e043b2cb29700b21c9db933feafdb9b\r\n#12 writing layer sha256:e572ff1033a9e16138dc22bcb7ccb2463e043b2cb29700b21c9db933feafdb9b 15.9s done\r\n#12 writing layer sha256:eefa9acb78356a6be0df6f74b1383e98e423a8fd57122267c361d82f0e8e4a4b 0.1s done\r\n#12 preparing build cache for export 18.0s done\r\n#12 DONE 18.0s\r\n```\r\n\r\nHaven't seen it write the cache to Cirrus's cache but I can't see why adding these extra env vars would change that (famous last words) so it's probably best to double check that the cache writing isn't broken on Cirrus after merging this.\r\n",
          "created_at": "2025-09-30T16:32:44Z"
        },
        {
          "user": "willcl-ark",
          "body": "One possible \"tightening\" could be to only export the [exact variables needed](https://github.com/bitcoin/bitcoin/actions/runs/18126966670/job/51584371561?pr=33508#step:6:333):\r\n\r\n```\r\nExporting ACTIONS_RUNNER_HOOK_JOB_STARTED # <-- likely not required for buildx gha cache\r\nExporting ACTIONS_RUNTIME_URL\r\nExporting ACTIONS_RUNTIME_TOKEN\r\nExporting ACTIONS_CACHE_URL\r\nExporting ACTIONS_RESULTS_URL\r\nExporting ACTIONS_CACHE_SERVICE_V2\r\n```\r\n\r\nBut IMO exporting all variables prefixed with `ACTIONS_` to the CI env should not ever be problematic (and my insulate us a little in case new variables are introduced).",
          "created_at": "2025-10-01T08:32:33Z"
        },
        {
          "user": "m3dwards",
          "body": "> But IMO exporting all variables prefixed with `ACTIONS_` to the CI env should not ever be problematic (and my insulate us a little in case new variables are introduced).\r\n\r\nWhich is what I think happened here to make this break in the first place so I'd support exporting all `ACTIONS_` vars.",
          "created_at": "2025-10-01T13:31:24Z"
        },
        {
          "user": "maflcko",
          "body": "Hmm, is the GHA cache even large enough to hold them? https://github.com/m3dwards/bitcoin/actions/caches says \" Approaching total cache storage limit (9.41 GB of 10 GB Used) \"\r\n\r\nSo I wonder, while this may fix the auth issue, the cache will still not be more useful.\r\n\r\nIt could be useful to know what is the sum of the size of all \"normal\" caches (ccache, depends, ...), and then the sum of the size of all docker caches.\r\n\r\n",
          "created_at": "2025-10-02T08:38:53Z"
        },
        {
          "user": "willcl-ark",
          "body": "Yes you are correct, the GHA cache is very tiny, and we have the worst type of docker caching due to our ineffcient layering in the images. So whilst we could fit many ccache entries in there, when we start adding the docker build cache blobs (which can be 0.5GB each) into the mix we quickly run out of space...\r\n\r\nAnd I agree this change will not make the GHA particularly more useful. I suppose the question to ask is \"would we prefer ccache hits or docker build layer hits\" (i.e. does building the image or compilation take longer)?\r\n\r\nIf we want to improve on this situation we would be looking at ideally (IMO) making the CI a \"docker-first\" design, but I had a look at this previously and it felt like a lot of work, so I gave up before making much progress.\r\n\r\n(You can see an outline here if you're interested https://github.com/bitcoin/bitcoin/compare/master...willcl-ark:bitcoin:docker-ci-containers from march. This attempt tried to preserve the ability to run on bare metal too, but if we didn't want that then most of the scripts could be moved into dockerfiles too, further simplifying/locking us in to docker üòã .)\r\n\r\nWith our current main repo setup on Cirrus, none of this is an issue for bitcoin/bitcoin.",
          "created_at": "2025-10-02T10:31:04Z"
        },
        {
          "user": "m3dwards",
          "body": "Right now, it seems to all just squeeze in for one run on master (I think that 9.4gb is just from one CI run on master). Pushes to forks won't write to the cache but could benefit from that.\r\n\r\n> would we prefer ccache hits or docker build layer hits\r\n\r\nI would say ccache hits. The docker build times aren't too bad?\r\n\r\nI still think merging this PR is fine but would also support us just disabling docker build layer caching on forks in support of a lot more space for ccache. Or just caching msan if it's adding a lot of time, which I don't think it is anymore.",
          "created_at": "2025-10-02T10:51:00Z"
        },
        {
          "user": "maflcko",
          "body": "> (You can see an outline here if you're interested [master...willcl-ark:bitcoin:docker-ci-containers](https://github.com/bitcoin/bitcoin/compare/master...willcl-ark:bitcoin:docker-ci-containers) from march. This attempt tried to preserve the ability to run on bare metal too, but if we didn't want that then most of the scripts could be moved into dockerfiles too, further simplifying/locking us in to docker üòã .)\r\n\r\nbare metal is required for the macOS CI, so I don't think we can go pure docker. Looking at the diff, it is a bit large, but i presume the savings are coming from sharing the base package install on the 24.04LTS ubuntu? If yes, the same savings can be achieved with a tiny patch on top of current master:\r\n\r\n* Unconditionally(?), build a special ci-base-common image before building the CI images\r\n* This way, CI configs can choose to pick the ci-base-common instead of the plain 24.04\r\n\r\nThough, i haven't tried this and i am not sure if it works with gha, or is worth it at all.\r\n\r\n\r\n\r\n> > would we prefer ccache hits or docker build layer hits\r\n> \r\n> I would say ccache hits. The docker build times aren't too bad?\r\n\r\nAgree, especially now that llvm+clang  is no longer compiled for msan.\r\n\r\n\r\n\r\n> Right now, it seems to all just squeeze in for one run on master (I think that 9.4gb is just from one CI run on master).\r\n\r\nAh ok. I guess one full cache should be enough. Reminds me that we may want to enable CI runs in the GUI repo on the main branch. Otherwise it will never cache anything.\r\n\r\n\r\n\r\n> I still think merging this PR is fine\r\n\r\nYes, sounds good. I am not familar with docker/GHA though, so I can't review it closely.",
          "created_at": "2025-10-02T11:10:54Z"
        },
        {
          "user": "maflcko",
          "body": "> > (You can see an outline here if you're interested [master...willcl-ark:bitcoin:docker-ci-containers](https://github.com/bitcoin/bitcoin/compare/master...willcl-ark:bitcoin:docker-ci-containers) from march. This attempt tried to preserve the ability to run on bare metal too, but if we didn't want that then most of the scripts could be moved into dockerfiles too, further simplifying/locking us in to docker üòã .)\r\n> \r\n> bare metal is required for the macOS CI, so I don't think we can go pure docker. Looking at the diff, it is a bit large, but i presume the savings are coming from sharing the base package install on the 24.04LTS ubuntu? If yes, the same savings can be achieved with a tiny patch on top of current master:\r\n> \r\n>     * Unconditionally(?), build a special ci-base-common image before building the CI images\r\n> \r\n>     * This way, CI configs can choose to pick the ci-base-common instead of the plain 24.04\r\n> \r\n> \r\n> Though, i haven't tried this and i am not sure if it works with gha, or is worth it at all.\r\n\r\nWent ahead and tried this in https://github.com/maflcko/bitcoin-core-with-ci/commit/28833017f8897b16a362bb81cc74d08263aac8d1\r\n\r\nHowever, there seems to be a problem with the docker buildx driver builder finding the local image. Maybe a docker person can take a look and try to figure it out?",
          "created_at": "2025-10-13T10:30:37Z"
        },
        {
          "user": "m3dwards",
          "body": "@maflcko hopefully this should sort it: https://github.com/m3dwards/bitcoin-core-with-ci/commit/5131564636ae971fb1ab68aeb980824af432fdf4",
          "created_at": "2025-10-13T16:23:50Z"
        },
        {
          "user": "maflcko",
          "body": "Thanks! That works. Docker truly couldn't be more confusing. Neither `build`, nor `BUILDKIT=1` work and the docker build driver for buildx is called `default`, but apparently it is not used by default, so it doesn't work either. I went ahead and set `os.environ[\"BUILDX_BUILDER\"] = \"default\"`, which should hopefully work with both docker and podman.",
          "created_at": "2025-10-14T08:06:14Z"
        },
        {
          "user": "maflcko",
          "body": "> > I still think merging this PR is fine\r\n> \r\n> Yes, sounds good. I am not familiar with docker/GHA though, so I can't review it closely.\r\n\r\nfwiw\r\n\r\nlgtm ACK bc706955d740f8a59bec78e44d33e80d1cca373b",
          "created_at": "2025-10-14T08:08:09Z"
        },
        {
          "user": "fanquake",
          "body": "Backported to `30.x` in #33609.",
          "created_at": "2025-10-14T08:56:51Z"
        },
        {
          "user": "fanquake",
          "body": "Backported to `29.x` in #33611.",
          "created_at": "2025-10-14T09:03:50Z"
        }
      ]
    },
    {
      "number": 33507,
      "title": "RPC: add sendrawtransactiontopeer",
      "body": "Adds a new RPC `sendrawtransactiontopeer`, which sends a single tx to a specific peer.\r\nAfter the transaction is sent to the peer it is forgotten and not stored in the local mempool.\r\n\r\nThis rpc can serve several purposes. For example, it allows you to ‚Äúspoof‚Äù an initial retransmission from a different \"trusted\" peer, making it appear as if the original participant was never aware of the transaction. It can also be useful in testing and simulation environments.\r\n\r\n\r\n\r\nSolves #28636 and #21876 (Partially - see https://github.com/bitcoin/bitcoin/pull/33507#discussion_r2389659427)\r\n\r\n",
      "state": "closed",
      "user": "polespinasa",
      "created_at": "2025-09-30T01:58:10Z",
      "updated_at": "2025-10-07T10:00:32Z",
      "comments": 11,
      "url": "https://github.com/bitcoin/bitcoin/pull/33507",
      "labels": [
        "RPC/REST/ZMQ"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/33507.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-09-30T01:58:15Z"
        },
        {
          "user": "andrewtoth",
          "body": "Have you seen https://github.com/bitcoin/bitcoin/pull/29415? Is there a reason you would want this if we had private broadcast?",
          "created_at": "2025-09-30T02:04:35Z"
        },
        {
          "user": "polespinasa",
          "body": "> Have you seen #29415? Is there a reason you would want this if we had private broadcast?\r\n\r\nYes! I saw it while reviewing the issues; it is a really nice privacy solution, but still I think this can have some use-cases.\r\n\r\nApart from testing/simulating network stuff, it can be used in an environment where your tx may be dropped/filtered by some of your peers. In that case, the ability to manually select one peer that you know will accept it and route it can be useful while preserving some privacy. #29415 handles this by re-sending the transaction to one new peer after ~15 min, which can be slow; this rpc could speed up the propagation.\r\nEg. If you have 10 peers and `NUM_PRIVATE_BROADCAST_PER_TX=2` and 8 of your peers will drop your tx, in the worst case you will wait 1-1.30h for your transaction to be broadcast. Which could lead to your tx fees not being enough or could be a problem for time-sensitive txs.\r\n\r\nThis is just an extreme case, but works as an example.",
          "created_at": "2025-09-30T18:10:13Z"
        },
        {
          "user": "theuni",
          "body": "I don't understand why this is necessary. Why not use `sendmsgtopeer` if you're just sending dumb bytes that don't affect our state?",
          "created_at": "2025-10-01T22:53:31Z"
        },
        {
          "user": "polespinasa",
          "body": "> I don't understand why this is necessary. Why not use `sendmsgtopeer` if you're just sending dumb bytes that don't affect our state?\r\n\r\nWe don't want to send invalid txs or txs that we would not broadcast,. We want to validates the txs before sending it to a peer.\r\nAdditionally, `peer_id` argument could take an array of ids and send the tx to multiple peers. (this is not implemented, but shouldn't be difficult to) ",
          "created_at": "2025-10-01T23:06:21Z"
        },
        {
          "user": "luke-jr",
          "body": ">We don't want to send invalid txs or txs that we would not broadcast,. We want to validates the txs before sending it to a peer.\r\n\r\nMaybe it should just do validation then, and can be followed up by the raw send?\r\n\r\n>Additionally, peer_id argument could take an array of ids and send the tx to multiple peers. (this is not implemented, but shouldn't be difficult to)\r\n\r\nSounds like a job for batching.\r\n\r\n(But maybe it's enough complexity to be worth a simplified RPC like this)",
          "created_at": "2025-10-02T12:39:06Z"
        },
        {
          "user": "polespinasa",
          "body": "> Maybe it should just do validation then, and can be followed up by the raw send?\r\n\r\nIf this is the flow we want to follow then this PR is not necessary at all. We can already do that with `testmempoolaccept` and then `sendmsgtopeer`\r\n\r\n> > Additionally, peer_id argument could take an array of ids and send the tx to multiple peers. (this is not implemented, but shouldn't be difficult to)\r\n> \r\n> Sounds like a job for batching.\r\n\r\nYeah that's why I didn't implement it in the first place, but it's easy to implement here.\r\n\r\n> (But maybe it's enough complexity to be worth a simplified RPC like this)\r\n\r\nOverall sending a tx to multiple desired peers can be already done with `testmempoolaccept` + N * (`sendmsgtopeer`). IMHO is worth having it all with one RPC.",
          "created_at": "2025-10-02T18:50:58Z"
        },
        {
          "user": "theuni",
          "body": " > Overall sending a tx to multiple desired peers can be already done with `testmempoolaccept` + N * (`sendmsgtopeer`). IMHO is worth having it all with one RPC.\r\n\r\nStrongly disagree. This seems like a case of feature creep to me. RPCs are easy to add and very tough to remove. If there were an issue with atomicity between calls or something, I might agree. But otherwise, chaining rpc calls sounds like the reasonable thing to do.\r\n\r\n> Additionally, peer_id argument could take an array of ids and send the tx to multiple peers. (this is not implemented, but shouldn't be difficult to)\r\n\r\n...and this is a good example of why. Allowing `sendmsgtopeer` to send to multiple peers (or a new rpc call to do so) would fill in the missing functionality without catering to a single use-case. `testmempoolaccept` + `sendmsgtopeer[M..N]` would be composable, and the multi-send may be useful for sending other data as well.",
          "created_at": "2025-10-02T19:50:01Z"
        },
        {
          "user": "polespinasa",
          "body": "I'm closing the PR for lack of support. Thank you all for your time commenting and reviewing :)\r\n\r\n> Allowing `sendmsgtopeer` to send to multiple peers (or a new rpc call to do so) would fill in the missing functionality without catering to a single use-case.\r\n\r\nThis approach makes sense to me as long as there are more network messages that might be worth sending to multiple peers. I might investigate that and if so open a PR with `sendmsgtopeer[M..N]` (probably a new rpc to keep backward compatibility on the original one).",
          "created_at": "2025-10-02T20:02:33Z"
        },
        {
          "user": "polespinasa",
          "body": "@mzumsande true.\r\n\r\nAlso I got some comments on X about it, proposing the new RPC call to recreate the whole `INV - GETDATA - TX` flow and not just send a `tx` message.",
          "created_at": "2025-10-02T23:59:28Z"
        },
        {
          "user": "vasild",
          "body": "This looked like an easy way for users to unintentionally dox themselves. Why would one want to send their transaction to a given peer(s) only and not to all like `sendrawtransaction` RPC?\r\n\r\n1. To obfuscate the transaction origin? Doing this properly is more involved, see [#29415](https://github.com/bitcoin/bitcoin/pull/29415) which does exactly that. If we would add an assumption that there is a known trusted peer which is ok to know the transaction origin, then one might as well connect just to them using `-connect`. Further, even in that scenario, if this is used repeatedly for many transactions, then an outside observer could link those transactions between themselves and link them to that trusted peer, who seems to be the originator. I.e. the trusted peer is kind of doxed.\r\n\r\n2. [#29415](https://github.com/bitcoin/bitcoin/pull/29415) is too slow with retries? That is easy to tweak, see commit `net_processing: retry private broadcast` in that PR (+85/-7 lines). Suggestions are welcome.\r\n\r\n3. We know somehow that a given peer will accept the transaction (e.g. they accept transactions with low fees)? In this case one might as well just add them with `addnode` to keep a connection with them and then use the regular `sendrawtransaction` RPC. Then the transaction will be send to that peer as well as to everybody else.\r\n\r\nIn general, improved transaction propagation speed and/or privacy of the originator would better be done automatically for everybody and not require manual user intervention or involve trusted peers.",
          "created_at": "2025-10-07T10:00:32Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 33510,
      "title": "Mempool Expiry eviction might remove txs that could be mined in the next block",
      "body": "`LimitMempoolSize` always try to remove transactions from the mempool whose age has passed the mempool expiry time limit, which is 336 hours (i.e., two weeks) by default.\n\nThere might be a case where you evict something that might be mined next. For example, the mempool was cleared and some low feerate transaction that has been in the mempool and has not confirmed in a long time due to having a low feerate is now at the top of the mempool.\nHowever, when we want to limit the mempool size, we will evict such transactions.\n\nWe can limit the harm of this by only expiring when the mempool is full now then post Cluster mempool, in addition to the transaction entry time, it would be possible to keep track of how many times you expect the transaction to confirm and it has not. If it has reached some threshold and the expiry time of the tx has been reached, then drop the transaction from the mempool because you know the transaction is likely deliberately ignored by miners (On the assumption that the node policy rules is sane and miners use tx fee as incentive for selection of transaction into their block template) hence no need to save it in the nodes mempool.\n",
      "state": "open",
      "user": "ismaelsadeeq",
      "created_at": "2025-09-30T16:15:15Z",
      "updated_at": "2025-10-08T19:20:03Z",
      "comments": 7,
      "url": "https://github.com/bitcoin/bitcoin/issues/33510",
      "labels": [
        "Mempool"
      ],
      "comment_list": [
        {
          "user": "polespinasa",
          "body": "How about we make the expiration time dynamic based on the position (computer by fee rate) in the mempool?\n\nTxs more likely to be mined have a bigger expiry time. If the mempool clears a bit, txs with low feerate will be on top of the mempool and their expiry time can be re-calculated to increase and avoid evicting txs that will be mined.\n\nThis way transactions more likely to be mined will not be evicted while the txs less likely to be mined will be evicted and only kept if the mempool clears a bit and they change their \"likely grade\".",
          "created_at": "2025-09-30T19:59:08Z"
        },
        {
          "user": "sipa",
          "body": "I don't know if this is really a concern in practice, because it's already compensated for by the fact that after a long time, transactions near the top of the mempool have had many chances of being mined already.\n\nWe could just get rid of expiration entirely if a time-based limit wasn't valuable, and just rely on eviction due to fullness. But if time-based expiration is valuable, then it's inevitable that a chance exists that a soon-to-be mined transaction expires.\n\n",
          "created_at": "2025-09-30T21:29:19Z"
        },
        {
          "user": "polespinasa",
          "body": "> We could just get rid of expiration entirely if a time-based limit wasn't valuable\n\nI might agree with this.\n\n@sipa do you know the reason why this was implemented in the first place?",
          "created_at": "2025-09-30T21:32:26Z"
        },
        {
          "user": "davidgumberg",
          "body": "### Archeology\n\nTime-based mempool expiry was added here: https://github.com/bitcoin/bitcoin/commit/49b6fd5663dfe081d127cd1eb11407c4d3eaf93d as part of #6722, from what I found, the most relevant discussion for time expiry was in https://github.com/bitcoin/bitcoin/pull/6455, e.g. this comment (https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122580009)): \n\n> I do understand the worry about mempools becoming filled with high-fee but unconfirming transactions, leading to (ever) increasing fees until the mempool clears. I've thought about using fees actually in the mempool, or time-based experation.\n\nThere are also two relevant irc discussions: [here](https://web.archive.org/web/20151016174215/http://bitcoinstats.com/irc/bitcoin-dev/logs/2015/09/28#l1443480600.0) and [here](https://bitcoin-irc.chaincode.com/bitcoin-core-dev/2015-10-02#1443822540-1443822720;)\n\n<details><summary>Mempool Expiry PR History Diagram</summary>\n\n```mermaid\nflowchart TD\n    A[#6331] --> D(#6421)\n    B[#6410] --> D\n    C[#6281] --> D\n    D --> |time expiry added| G[#6455]\n    E[#6452] --> G\n    F[#6453] --> G\n    G --> H[#6470]\n    H --> I[#6557]\n    I --> J[#6722]\n    J --> |merged| K[master]\n    \n    click A \"https://github.com/bitcoin/bitcoin/pull/6331\" _blank\n    click B \"https://github.com/bitcoin/bitcoin/pull/6410\" _blank\n    click C \"https://github.com/bitcoin/bitcoin/pull/6281\" _blank\n    click D \"https://github.com/bitcoin/bitcoin/pull/6421\" _blank\n    click E \"https://github.com/bitcoin/bitcoin/pull/6452\" _blank\n    click F \"https://github.com/bitcoin/bitcoin/pull/6453\" _blank\n    click G \"https://github.com/bitcoin/bitcoin/pull/6455\" _blank\n    click H \"https://github.com/bitcoin/bitcoin/pull/6470\" _blank\n    click I \"https://github.com/bitcoin/bitcoin/pull/6557\" _blank\n    click J \"https://github.com/bitcoin/bitcoin/pull/6722\" _blank\n    click K \"https://github.com/bitcoin/bitcoin/commit/49b6fd5663dfe081d127cd1eb11407c4d3eaf93d\" _blank\n```\n\n\n</details>\n\n\n----\nFrom this and my own assumptions, I gather that the time-based expiry is generally intended to evict transactions that a node believes are likely to be mined but empirical evidence has shown miners are not including for a long enough period of time that we think those transactions will never be included, maybe because miners:\n\n- Are censoring these transactions\n- Have a different estimation of their feerate\n- Have a soft-fork activated that your node doesn't that makes the high feerate transactions consensus invalid\n\n> How about we make the expiration time dynamic based on the position (computer by fee rate) in the mempool?\n>\n> Txs more likely to be mined have a bigger expiry time\n\nI think this should be the opposite, the transactions that are the best candidates for time-based expiry, are the ones that are at the top of our mempool, but block after block remain unconfirmed.\n\n> We could just get rid of expiration entirely if a time-based limit wasn't valuable, and just rely on eviction due to fullness.\n\nMy gut reaction is that time-based expiry isn't helpful, but without it, it seems like it would be easy to break the mempools of nodes that are missing a soft fork, since you could broadcast a mempool's worth of post-soft-fork-invalid high-fee transactions for \"free\" to pre-soft-fork nodes, and they will never let go of them, but I suppose the current behavior where an attacker has to periodically rebroadcast is not that big of a barrier.\n",
          "created_at": "2025-09-30T22:06:39Z"
        },
        {
          "user": "polespinasa",
          "body": "Thanks for the context @davidgumberg \n\n> > How about we make the expiration time dynamic based on the position (computer by fee rate) in the mempool?\n> > Txs more likely to be mined have a bigger expiry time\n> \n> I think this should be the opposite, the transactions that are the best candidates for time-based expiry, are the ones that are at the top of our mempool, but block after block remain unconfirmed.\n\nYep, you are right, makes more sense in the opposite üòÖ\n\n> but I suppose the current behavior where an attacker has to periodically rebroadcast is not that big of a barrier.\n\nIt's not a big barrier but still more uncomfortable; you have to be connected to the victim node and re-rebroadcast every default `expiry_time`, and eventually, if the attacker gets tired, the node will go run normal again. Without the expiry time, you can dos a mempool with 1 single attack.",
          "created_at": "2025-09-30T22:40:48Z"
        },
        {
          "user": "sipa",
          "body": "@davidgumberg I like the idea of expiring based on how many times a transaction was expected to be mined, but wasn't. E.g. every block, or every 10 minutes, or on a Poisson timer, run the block building code and increase a counter in the mempool for every transaction in the template. Whenever the counter reaches a certain configurable value, expire. Note that that may well mean that nothing ever expires, if everything gets mined once it's spent enough time near the top of the mempool - but that may be ok, if it's a sign there is no persistent policy difference between your mempool and miners'.\n\nOne potential issue I see that whenever we expire, we also need to expire all descendants. What if you have a very old transaction that isn't confirming (for whatever reason) but it has a very recent child? Should the child be permitted to keep its parent alive longer? This might matter in CPFP settings, if the child somehow helps the parent getting confirmed.\n\nAlso thanks for digging up the history for expiration; I was wondering if it predated RBF, eviction, and CPFP, but it looks like all those things were added roughly around the same time. I can imagine one other reason for expiration, which probably didn't exist at the time it was added: allowing transactions to be replaced for free (e.g. without the incremental relay fee, as a counter to the pinning that's caused by that). But I'm guessing that the 2-week timeout currently doesn't really help with that anyway.",
          "created_at": "2025-10-01T13:01:57Z"
        },
        {
          "user": "glozow",
          "body": "> Also thanks for digging up the history for expiration; I was wondering if it predated RBF, eviction, and CPFP, but it looks like all those things were added roughly around the same time. I can imagine one other reason for expiration, which probably didn't exist at the time it was added: allowing transactions to be replaced for free (e.g. without the incremental relay fee, as a counter to the pinning that's caused by that).\n\nI'll add that, back in the day, expiry would have been the only way to \"replace\" (i.e. get rid of) a non-signaling transaction that wasn't confirming.",
          "created_at": "2025-10-08T19:19:18Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 4,
    "issues": 1
  }
}