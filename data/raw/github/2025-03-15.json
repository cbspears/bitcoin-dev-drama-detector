{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T19:25:07.078245+00:00",
  "date": "2025-03-15",
  "pull_requests": [
    {
      "number": 32077,
      "title": "style: Fix spacing in script.h for OP_TRUE definition",
      "body": "This pull request fixes a spacing issue in `script.h` where the definition for `OP_TRUE` was formatted without a space before the assignment operator. The only modification is changing:\r\n\r\n```diff\r\n-    OP_TRUE=OP_1,\r\n+    OP_TRUE = OP_1,\r\n```\r\n\r\nThis update improves the code's readability and adheres to the project's style guidelines without affecting functionality.",
      "state": "closed",
      "user": "sekomer",
      "created_at": "2025-03-15T14:03:31Z",
      "updated_at": "2025-03-15T19:38:53Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/pull/32077",
      "labels": [],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32077.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
          "created_at": "2025-03-15T14:03:34Z"
        }
      ]
    },
    {
      "number": 32074,
      "title": "contrib: Make deterministic-coverage error messages more readable",
      "body": "This is almost a \"refactor\" to tidy up the error messages. Apart from the messages, the behavior of the tools is identical.\r\n\r\nThis was requested in https://github.com/bitcoin/bitcoin/pull/31901#discussion_r1969502508.\r\n\r\nPreviously, the tool would abort the program early on some errors. Now, the tool propagates an `std::result::Result::Err` up to `main` via an early return. Getting rid of the aborts also allows to drop the `RUST_BACKTRACE` env setting.",
      "state": "closed",
      "user": "maflcko",
      "created_at": "2025-03-15T08:07:31Z",
      "updated_at": "2025-03-28T14:16:01Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/pull/32074",
      "labels": [
        "Scripts and tools"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/32074.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| ACK | [hodlinator](https://github.com/bitcoin/bitcoin/pull/32074#pullrequestreview-2703119042), [janb84](https://github.com/bitcoin/bitcoin/pull/32074#pullrequestreview-2705873894) |\n\nIf your review is incorrectly listed, please react with üëé to this comment and the bot will ignore it on the next update.\n",
          "created_at": "2025-03-15T08:07:34Z"
        },
        {
          "user": "maflcko",
          "body": "@hodlinator I'll wait for you to give the ack/review on this, and once you are happy that your feedback is fully addressed, I'll move it out of draft",
          "created_at": "2025-03-18T08:49:35Z"
        },
        {
          "user": "hodlinator",
          "body": "> @hodlinator I'll wait for you to give the ack/review on this, and once you are happy that your feedback is fully addressed, I'll move it out of draft\r\n\r\nCan't promise I won't find any more issues, but this turned out surprisingly well IMO. Thanks for taking the time to work on it!",
          "created_at": "2025-03-18T20:41:14Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 32078,
      "title": "listdescriptors true fails with 'Can't get descriptor string' in non-watch-only descriptor wallet",
      "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Current behaviour\n\nWhen running the command:\n```\nbitcoin-cli listdescriptors true\n```\nit fails with the error:\n```\nerror code: -4\nerror message:\nCan't get descriptor string.\n```\neven though the wallet is not watch-only and is a descriptor wallet.\n\nHowever, when running:\n```\nbitcoin-cli listdescriptors false\n\n```\nthe command works fine and returns descriptor information, but without private keys.\n\n\n\n### Expected behaviour\n\nSince the wallet is not watch-only and is a descriptor wallet, the command should succeed, just like listdescriptors false, but with the private key information included.\n\n### Steps to reproduce\n\nVerify that the wallet is a descriptor wallet:\n\n```\n{\n  \"walletname\": \"BTC\",\n  \"walletversion\": 169900,\n  \"format\": \"sqlite\",\n  \"keypoolsize_hd_internal\": 4000,\n  \"private_keys_enabled\": true,\n  \"descriptors\": true,\n  \"external_signer\": false,\n  \"blank\": false,\n}\n```\n\n### Relevant log output\n\nI didn't find any related errors in the debug file, but I listed my descriptor for reference\n\n```\n{\n  \"descriptors\": [\n    {\n      \"desc\": \"pkh([761f1ef4/44h/1h/0h]tpubDDeGeaPE1STPq4dQFhc5grg8pn6pqyttBtX6Pkw8cAVKesnJr7wYFF7LKy2ysifbPSKDyBT3hHjAg9rftJdPVKLUrGgan7pmML9CFeDuua6/0/*)#cnspa9u5\"\n    },\n    {\n      \"desc\": \"pkh([761f1ef4/44h/1h/0h]tpubDDeGeaPE1STPq4dQFhc5grg8pn6pqyttBtX6Pkw8cAVKesnJr7wYFF7LKy2ysifbPSKDyBT3hHjAg9rftJdPVKLUrGgan7pmML9CFeDuua6/1/*)#f84qqsvv\"\n    },\n    {\n      \"desc\": \"pkh([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/100)#t96q85nr\"\n    },\n    {\n      \"desc\": \"sh(wpkh([761f1ef4/49h/1h/0h]tpubDDohgQvP57jvmvVzmKFo1JjZjwWRAaYyL7aPG4ZPiiNjnbSDKBHxgPSBmBx9Esjf4HxxeEeRVdkiGRaJmVRofHBMLtQzHxKmRbAg9oMxEmw/0/*))#h40wmz6r\"\n    },\n    {\n      \"desc\": \"sh(wpkh([761f1ef4/49h/1h/0h]tpubDDohgQvP57jvmvVzmKFo1JjZjwWRAaYyL7aPG4ZPiiNjnbSDKBHxgPSBmBx9Esjf4HxxeEeRVdkiGRaJmVRofHBMLtQzHxKmRbAg9oMxEmw/1/*))#z5pcra0u\"\n    },\n    {\n      \"desc\": \"sh(wsh(multi(2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/3)))#3455mcsd\"\n    },\n    {\n      \"desc\": \"tr([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/*)#rrrwmyl6\"\n    },\n    {\n      \"desc\": \"tr([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/1,multi_a(2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/3))#teu9thwc\"\n    },\n    {\n      \"desc\": \"tr([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/1,{pk([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/2),pk([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/1)})#597an7jq\"\n    },\n    {\n      \"desc\": \"tr([761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/1/*)#jhx0x30z\"\n    },\n    {\n      \"desc\": \"tr(ca46e9fad132afe73c7efcc02039225d2f4626cf476f6ca91ab56ad2d1956029,multi_a(2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/2,[761f1ef4/86h/1h/0h]tpubDDRksBabSitMWcvdvWwVzhEvwFC9Bf77ASZRGHtoMhYr6AFDChuQtNxEvWqtjNy5Vqmd7DKwh5b41NM1oT3YfNRWBMrbcw53da4NwmJ12Td/0/3))#guq2rvkj\"\n    },\n    {\n      \"desc\": \"wpkh([761f1ef4/84h/1h/0h]tpubDCSU3vbXvSzLszkaX4dBv5bsovXH5JqoR6rpCToEJZJ8kiZb3VZkWpoKnf5Sr5aGjxCqbDhfR6Z8JtT5rT3CLj7aC8NfLUjEtxhZB9PNHxs/0/*)#lf9s05rn\"\n    },\n    {\n      \"desc\": \"wpkh([761f1ef4/84h/1h/0h]tpubDCSU3vbXvSzLszkaX4dBv5bsovXH5JqoR6rpCToEJZJ8kiZb3VZkWpoKnf5Sr5aGjxCqbDhfR6Z8JtT5rT3CLj7aC8NfLUjEtxhZB9PNHxs/1/*)#waq3jpnt\"\n    }\n  ]\n}\n\n```\n\n### How did you obtain Bitcoin Core\n\nPre-built binaries\n\n### What version of Bitcoin Core are you using?\n\nBitcoin Core RPC client version v28.1.0\n\n### Operating system and version\n\nWindows 11 Home 26100.3476\n\n### Machine specifications\n\n_No response_",
      "state": "open",
      "user": "mrtnetwork",
      "created_at": "2025-03-15T18:40:24Z",
      "updated_at": "2025-04-07T17:04:52Z",
      "comments": 9,
      "url": "https://github.com/bitcoin/bitcoin/issues/32078",
      "labels": [
        "Wallet",
        "RPC/REST/ZMQ"
      ],
      "comment_list": [
        {
          "user": "furszy",
          "body": "This occurs when the wallet does not contain all key/script paths key material (e.g. taproot descriptor with an internal pubkey). Test exercising the behavior and explaining the issue further: https://github.com/furszy/bitcoin-core/commit/970efeb0fb2632d714e0f444b4ac89278eb80b28.",
          "created_at": "2025-03-17T13:58:18Z"
        },
        {
          "user": "rkrux",
          "body": "Were the descriptors mentioned in the description collected using `listdescriptors false`?  \n\nI'm asking because all these descriptors seem to be using public keys, at least all the taproot ones because I get the following error when I try to import them in my wallet.\n\n```\n[\n  {\n    \"success\": false,\n    \"error\": {\n      \"code\": -4,\n      \"message\": \"Cannot import descriptor without private keys to a wallet with private keys enabled\"\n    }\n  }\n]\n```\n\nThis PR https://github.com/bitcoin/bitcoin/pull/32186 attempts to fix the issue where the private keys are not present for all the taproot spending paths as mentioned in the comment https://github.com/bitcoin/bitcoin/issues/32078#issuecomment-2729618600. For example: the descriptor may have the private key for the keypath spend and none for the script path spend, or the descriptor could have at least one private key for any of the scripts in the scriptpath spend but not have the private key for the keypath spend.\n\n@mrtnetwork By chance, do you remember having any such^ descriptor in your wallet?",
          "created_at": "2025-04-03T12:47:00Z"
        },
        {
          "user": "mrtnetwork",
          "body": "> This PR [#32186](https://github.com/bitcoin/bitcoin/pull/32186) attempts to fix the issue where the private keys are not present for all the taproot spending paths as mentioned in the comment [#32078 (comment)](https://github.com/bitcoin/bitcoin/issues/32078#issuecomment-2729618600). For example: the descriptor may have the private key for the keypath spend and none for the script path spend, or the descriptor could have at least one private key for any of the scripts in the scriptpath spend but not have the private key for the keypath spend.\n> \n> [@mrtnetwork](https://github.com/mrtnetwork) By chance, do you remember having any such^ descriptor in your wallet?\n\nFor Taproot, I have 3‚Äì4 addresses that use x-only pubkeys with no script path. However, one of them is a 2-of-2 Taproot multisig. All private keys are available in the wallet. I'm working only on the testnet network. If you need more details, I can upload the wallet backup for you.",
          "created_at": "2025-04-04T04:36:37Z"
        },
        {
          "user": "Randy808",
          "body": "`listdescriptors` will also fail for any sh or wsh descriptors.:\n```\nbitcoin-cli importdescriptors '[{\"desc\": \"wsh(thresh(2,pk(tprv8ZgxMBicQKsPdzuc344mDaeUk5zseMcRK9Hst8xodskNu3YbQG5NxLa2X17PUU5yXQhptiBE7F5W5cgEmsfQg4Y21Y18w4DJhLxSb8CurDf),s:pk(tpubD6NzVbkrYhZ4YiCvExLvH4yh1k3jFGf5irm6TsrArY8GYdEhYVdztQTBtTirmRc6XfSJpH9tayUdnngaJZKDaa2zbqEY29DfcGZW8iRVGUY),sln:older(2)))#jgkkfj86\", \"timestamp\": \"now\"}]'\n\nbitcoin-cli listdescriptors true\n```\n\n`ToStringHelper` will fail the serialization [if any of the keys in the expression are missing a private key](https://github.com/bitcoin/bitcoin/blob/d42e82d65069a8b5f58de354beab5249c7203542/src/script/descriptor.cpp#L653-L661). @rkrux's [PR](https://github.com/bitcoin/bitcoin/pull/32186) handles the taproot case, but I think a general solution is needed. If there's even one private key available, it needs to be visible in `listdescriptors true` so users can make complete backups.",
          "created_at": "2025-04-06T13:35:53Z"
        },
        {
          "user": "rkrux",
          "body": "Interesting, tried these^ keys in a `wsh` descriptor that causes the `listdescriptors` to throw as well.\n\n```\n‚ûú  bitcoin git:(master) ‚úó bitcoinclireg importdescriptors '[{\"desc\": \"wsh(multi(2,tprv8ZgxMBicQKsPdzuc344mDaeUk5zseMcRK9Hst8xodskNu3YbQG5NxLa2X17PUU5yXQhptiBE7F5W5cgEmsfQg4Y21Y18w4DJhLxSb8CurDf,tpubD6NzVbkrYhZ4YiCvExLvH4yh1k3jFGf5irm6TsrArY8GYdEhYVdztQTBtTirmRc6XfSJpH9tayUdnngaJZKDaa2zbqEY29DfcGZW8iRVGUY))#a0tl2jdn\", \"timestamp\": \"now\"}]'\n[\n  {\n    \"success\": true,\n    \"warnings\": [\n      \"Not all private keys provided. Some wallet functionality may return unexpected errors\"\n    ]\n  }\n]\n‚ûú  bitcoin git:(master) ‚úó bitcoinclireg listdescriptors true                      \nerror code: -4\nerror message:\nCan't get descriptor string.\n```\n\nI'm digging into this for a solution.",
          "created_at": "2025-04-07T14:49:10Z"
        },
        {
          "user": "rkrux",
          "body": "> If there's even one private key available, it needs to be visible in listdescriptors true so users can make complete backups.\n\nEven though `listdescriptors true` should work correctly ideally, I don't suppose only this RPC throwing an error would lead to the user being unable to make complete backups? ",
          "created_at": "2025-04-07T14:54:07Z"
        },
        {
          "user": "Randy808",
          "body": "If I export that descriptor from another wallet, import it into Bitcoin Core, delete my old wallet, and later try to export that descriptor with the same information, I won't be able to. As a user `listdescriptors true` [is the way I would be expecting to backup all the descriptors in my wallet](https://bitcoin.stackexchange.com/questions/107216/how-do-i-get-the-private-key-of-an-address-in-descriptor-wallets-how-to-dumppri?rq=1#comment132566_107956). Without this, there is no other mechanism besides me tinkering with the code. Having this one \"problem\" descriptor prevent the other descriptors in my wallet from being displayed is also something I think should be changed. \n\nI didn't want to derail your PR, this was just something I've noticed for a while and was going to make my own issue/fix for. I think the PR to address the problem for taproot descriptors is a step in the right direction but I wanted to mention the broader issue that needs to be solved.",
          "created_at": "2025-04-07T15:41:25Z"
        },
        {
          "user": "sipa",
          "body": "> `ToStringHelper` will fail the serialization [if any of the keys in the expression are missing a private key](https://github.com/bitcoin/bitcoin/blob/d42e82d65069a8b5f58de354beab5249c7203542/src/script/descriptor.cpp#L653-L661). [@rkrux](https://github.com/rkrux)'s [PR](https://github.com/bitcoin/bitcoin/pull/32186) handles the taproot case, but I think a general solution is needed. If there's even one private key available, it needs to be visible in `listdescriptors true` so users can make complete backups.\n\nI agree. See my comment on #32186.",
          "created_at": "2025-04-07T15:52:00Z"
        },
        {
          "user": "rkrux",
          "body": "Thank you for sharing more details.\n\nI've put my PR #32186 in draft while I work on a more generic solution.",
          "created_at": "2025-04-07T17:04:51Z"
        }
      ]
    },
    {
      "number": 32076,
      "title": "Feature Request: Forking Bitcoin for Native gRPC/dRPC Integration",
      "body": "### Please describe the feature you'd like to see added.\n\nSo I noticed on mintscan that we have bitcoin API, but... we don't have gRPC/dRPC hooking in bitcore,  which is causing a lot of wacky stuff to occur on Coinbase. \n\nThen again, if we're going to introduce this feature we to be careful of this following bug vulnerability \n\ninterface ProviderRpcError {\n  message: string;\n  code: number;\n  data?: { method?: string };\n  stack?: string;\n}\n\nBecause we all know what that does. Coinbase, the cryptocurrency exchange, announced a security bug in their API that would have allowed an attacker to take over user accounts. Coinbase halted all trading and withdrawals while they investigated the issue. The bug has since been fixed, and Coinbase has resumed trading. I mean, I'm grateful that bitcore has deprecated the private key generation function for a legac wallet, becausr if you combine that RPC error within the API with bitcore's... unique console commands, well, let's just say you get more than a misconfigured graph going the opposite direction, while your  crypto wallet is showing the inverse of the graph (my friend James told me about this issue with his crypto and... it's jarring, I hope to God y'all didn't put an AI model without persistent stateful memory like I ahve been telling you all to do time and time again... \n\nSo yeah, there are going to be hurdles with this developing this feature, yes I deserve to get paid for bringing this problem up because I will be the one coming to a solution with dRPC.org so that interchain.io has a better bitcoin cryptocurrency that isn't as easily hackable. \n\nBecause you all realize that's why bitcoin is going down? I mean sure, there's the political drama and bullshit, but it's because the network is not secure in the trenches, in those data mines. \n\n\n@coderabbitai can you provide some solutions for us?\n\n\n....\nfor now, this is our proposal and we will provide code examples of current vulnerabilities still found via RPC hooking in coinbase that have not been addressed\n\n1. Introduction\nObjective\nFork the Bitcoin Core repository to add a native gRPC (or dRPC) interface to bitcoind, enabling direct streaming and RPC calls without relying solely on JSON-RPC proxies or wrappers.\nWhy gRPC or dRPC?\nModern Capabilities\n\ngRPC offers bidirectional streaming, a standardized protocol buffer (protobuf) approach, and improved performance compared to REST/JSON-RPC in many cases.\nMulti-Chain Interoperability\n\nMany Cosmos-based chains expose gRPC endpoints, making Bitcoin a ‚Äúspecial case‚Äù on cross-chain platforms like Mintscan or interchain.io. Currently, Mintscan/interchain.io only have a limited HTTP ‚ÄúAPI‚Äù for Bitcoin and no standard RPC, introducing unnecessary complexity and potential security gaps.\nFuture Alignment with Bitcore\n\nTools like Bitcore (JavaScript/TypeScript with optional C/C++ bindings) integrate more smoothly when there is a native gRPC or dRPC server available, reducing friction for multi-chain solutions.\nImpact on Bitcoin‚Äôs Price\n\nAlthough external factors (political, economic) influence Bitcoin‚Äôs valuation, technical weaknesses‚Äîsuch as lacking robust cross-chain interfaces‚Äîcan erode confidence and adoption. This perceived security and integration gap can contribute to negative market sentiment. The downward pressure on Bitcoin‚Äôs price has been partly attributed to concerns over network security ‚Äúin the trenches,‚Äù especially as institutional and retail users demand more reliable, modern tools.\nCosmos SDK Roadblocks\n\nThe Cosmos SDK team has historically been protective of its own ecosystem, causing difficulties for third-party or cross-chain solutions (particularly around interchain queries). Julien‚Äôs involvement (cited in multiple issue threads) has introduced major bugs or blocked proposals aimed at bridging Bitcoin more seamlessly into the Cosmos ecosystem. This friction exacerbates multi-chain fragmentation, impacting both Bitcoin and Cosmos-based projects.\n2. Repository Structure and File Changes\n2.1 New Files\nCreate three new core files in src/grpc/:\n\ngRPC.h ‚Äì The header file defining your main gRPC server class and public methods.\ngRPC.c ‚Äì (Optional) C-based scaffolding if bridging with lower-level libraries or external dependencies.\ngRPC.cpp ‚Äì The main implementation of your gRPC server logic, method stubs, and request handlers.\ncss\nCopy\nEdit\nbitcoin/\n  ‚îú‚îÄ src/\n  ‚îÇ   ‚îú‚îÄ grpc/\n  ‚îÇ   ‚îÇ   ‚îú‚îÄ gRPC.h\n  ‚îÇ   ‚îÇ   ‚îú‚îÄ gRPC.cpp\n  ‚îÇ   ‚îÇ   ‚îî‚îÄ gRPC.c\n  ‚îÇ   ‚îú‚îÄ rpc/  # Existing JSON-RPC logic\n  ‚îÇ   ‚îî‚îÄ ... other Bitcoin Core files\n  ‚îî‚îÄ ... rest of repo\n2.2 Protobuf Definitions\nPlace your .proto files (e.g., bitcoin_service.proto, messages.proto) in a directory such as proto/:\n\nplaintext\nCopy\nEdit\nproto/\n  bitcoin_service.proto\n  messages.proto\nAn example bitcoin_service.proto:\n\nprotobuf\nCopy\nEdit\nsyntax = \"proto3\";\n\npackage bitcoin;\n\n// Basic gRPC service for Bitcoin\nservice BitcoinRPC {\n  // Get the current block height\n  rpc GetBlockHeight (EmptyRequest) returns (BlockHeightResponse);\n\n  // Get the balance for a given address\n  rpc GetBalance (BalanceRequest) returns (BalanceResponse);\n}\n\nmessage EmptyRequest {}\nmessage BlockHeightResponse { int64 height = 1; }\nmessage BalanceRequest { string address = 1; }\nmessage BalanceResponse { double balance = 1; }\n3. Implementation Outline\n3.1 gRPC Dependencies\nAdd gRPC and Protocol Buffers to your depends/ folder or build system.\nUpdate configure.ac or CMakeLists.txt to detect and link against gRPC.\nOptionally introduce a build flag (e.g., --enable-grpc).\n3.2 gRPC.h ‚Äî Header Example\ncpp\nCopy\nEdit\n#ifndef BITCOIN_GRPC_H\n#define BITCOIN_GRPC_H\n\n#include <memory>\n#include <string>\n\nnamespace grpc {\n    class Server;\n    class Service;\n    class ServerBuilder;\n}\n\nclass BitcoinGrpcServer {\npublic:\n    BitcoinGrpcServer(const std::string& server_address);\n    ~BitcoinGrpcServer();\n\n    // Start and stop the server\n    void Start();\n    void Shutdown();\n\nprivate:\n    std::unique_ptr<grpc::ServerBuilder> builder;\n    std::unique_ptr<grpc::Server> server;\n\n    // e.g., std::unique_ptr<BitcoinServiceImpl> service;\n};\n\n#endif // BITCOIN_GRPC_H\n3.3 gRPC.cpp ‚Äî Implementation Example\ncpp\nCopy\nEdit\n#include \"gRPC.h\"\n#include <grpcpp/grpcpp.h>\n// #include \"bitcoin_service.grpc.pb.h\" // generated from your .proto\n\n// Example stub for the gRPC service\nclass BitcoinServiceImpl final /* : public bitcoin::BitcoinRPC::Service */ {\npublic:\n    /*\n    // e.g., Implementation of GetBlockHeight\n    grpc::Status GetBlockHeight(\n        grpc::ServerContext* context,\n        const bitcoin::EmptyRequest* request,\n        bitcoin::BlockHeightResponse* response\n    ) override {\n        int64_t height = GetActiveChainHeight();\n        response->set_height(height);\n        return grpc::Status::OK;\n    }\n    */\n};\n\nBitcoinGrpcServer::BitcoinGrpcServer(const std::string& server_address) {\n    builder = std::make_unique<grpc::ServerBuilder>();\n    builder->AddListeningPort(server_address, grpc::InsecureServerCredentials());\n\n    // auto service = std::make_unique<BitcoinServiceImpl>();\n    // builder->RegisterService(service.get());\n\n    server = builder->BuildAndStart();\n}\n\nBitcoinGrpcServer::~BitcoinGrpcServer() {\n    if (server) {\n        server->Shutdown();\n    }\n}\n\nvoid BitcoinGrpcServer::Start() {\n    if (server) {\n        // Typically run in a separate thread; demonstration uses a blocking Wait()\n        server->Wait();\n    }\n}\n\nvoid BitcoinGrpcServer::Shutdown() {\n    if (server) {\n        server->Shutdown();\n    }\n}\n3.4 gRPC.c ‚Äî C Fallback or Bridge Example\nc\nCopy\nEdit\n#include \"gRPC.h\"\n#include <stdio.h>\n\nvoid initialize_grpc_module() {\n    printf(\"Initializing gRPC module...\\n\");\n    // Specialized C logic or bridging if needed\n}\n4. Bitcore Alignment\nNode.js Native Addons: Bitcore-based apps (JavaScript/TypeScript) can load your C/C++ gRPC server via native addons.\nJSON-like I/O: Although gRPC uses protobuf, you can create helper utilities to convert requests/responses to JSON for existing Bitcore workflows.\nPerformance Focus: Keep bridging overhead minimal so gRPC‚Äôs speed advantage is preserved.\n5. Integration with Bitcoin Core\nFork the Repo\n\nCreate a new branch, e.g., feature/grpc-integration.\nAdd Build Options\n\nIn configure.ac or CMakeLists.txt, insert logic to detect gRPC libraries:\nbash\nCopy\nEdit\n./configure --enable-grpc\nConditional Compilation\n\nWrap gRPC code with #ifdef ENABLE_GRPC to make it optional.\nInitialization (init.cpp)\n\ncpp\nCopy\nEdit\n#ifdef ENABLE_GRPC\n#include \"gRPC.h\"\n\nstatic std::unique_ptr<BitcoinGrpcServer> g_grpcServer;\n\nbool AppInitServers(...) {\n    if (gArgs.GetBoolArg(\"-grpcenabled\", false)) {\n        g_grpcServer = std::make_unique<BitcoinGrpcServer>(\"0.0.0.0:50051\");\n        g_grpcServer->Start();\n    }\n    ...\n}\n#endif\nShutdown (shutdown.cpp)\n\ncpp\nCopy\nEdit\n#ifdef ENABLE_GRPC\nif (g_grpcServer) {\n    g_grpcServer->Shutdown();\n}\n#endif\n6. Code Vulnerabilities & Security Considerations\nExpanding Bitcoin‚Äôs API surface with gRPC/dRPC can open new attack vectors. This is especially relevant since Mintscan and interchain.io only see Bitcoin through a limited HTTP ‚ÄúAPI,‚Äù lacking a formal, secured RPC approach.\n\nProviderRpcError Leaks\n\nPotentially exposing internal stack traces or method data (interface ProviderRpcError { ... }) can reveal node internals.\nMitigation: Sanitize error messages and avoid sending debug info in production.\nUnauthenticated gRPC Endpoints\n\nIf gRPC runs on an open port without TLS or token-based auth, attackers might invoke critical node methods.\nMitigation: Use TLS certificates, IP allowlists, or replicate JSON-RPC‚Äôs cookie-based approach.\nStreaming Overflows\n\ngRPC streams can exceed normal message sizes, risking DoS or memory exhaustion.\nMitigation: Enforce maximum message size; monitor streaming traffic.\nConcurrency & Race Conditions\n\ngRPC typically handles multiple requests in parallel. If wallet or UTXO data isn‚Äôt thread-safe, you risk race conditions.\nMitigation: Add concurrency controls, locks, or thread-safe data structures.\nReplay/Signature Attacks (for dRPC)\n\nA dRPC system might allow cross-chain transactions or custom signing. Without robust replay protection, signatures can be reused.\nMitigation: Use nonces/timestamps, domain separation, and strict validation.\n7. Proposed Solutions & Best Practices\nWrapper Approach (Short-Term)\n\nA standalone ‚Äúbridge‚Äù service that proxies between the existing JSON-RPC and gRPC/dRPC.\nPros: Quick to prototype, no changes to Bitcoin Core required.\nCons: Additional maintenance overhead; potential single point of failure.\nNative Integration (Long-Term)\n\nIntegrate gRPC/dRPC directly within bitcoind.\nPros: Single source of truth, minimal overhead.\nCons: Requires consensus from Bitcoin Core devs (notoriously conservative), adds complexity.\nSecurity Best Practices\n\nAuthentication: TLS, tokens, IP filtering.\nGranular Permissions: Restrict sensitive wallet commands.\nError Sanitization: Strip stack traces in production.\nIncremental Rollout: Thorough testing on testnet/regtest, security audits, then mainnet.\n8. Potential Hurdles\nConservative Bitcoin Community: The project‚Äôs maintainers may be hesitant to include a new interface like gRPC/dRPC.\nMaintenance Overhead: A fork must be continuously updated to sync with upstream security patches.\nAdoption & Ecosystem: Exchanges, wallets, and node operators would need to adopt the new interface for it to become widely used.\nCosmos SDK Conflicts: Cosmos‚Äôs SDK team, along with devs like Julien, have historically introduced obstacles or bugs that limit certain bridging or cross-chain proposals. This tension may hinder cross-chain synergy if not addressed collaboratively.\n9. Conclusion\nBy adding a native gRPC/dRPC interface to Bitcoin, we modernize the network‚Äôs developer experience and reduce vulnerabilities introduced by ad-hoc HTTP APIs on platforms like Mintscan and interchain.io. While other factors (e.g., political, economic) drive Bitcoin‚Äôs price, technological confidence plays a critical role‚Äîcontinuing to rely on inconsistent integrations can undermine market trust, contributing to downward price trends.\n\nA short-term wrapper can confirm feasibility, but a carefully reviewed, optional build flag for native gRPC/dRPC might be the long-term path if it gains acceptance in the Bitcoin ecosystem. Collaboration with or awareness of the Cosmos SDK team‚Äôs (and developers like Julien‚Äôs) stance is also crucial, as friction there can reverberate across multiple chains and hamper stable cross-chain functionality.\n\ndRPC gRPC Hooking Alongside the API That Bitcoin Uses\n\n### Is your feature related to a problem, if so please describe it.\n\nyes, RPC and AAPI vulnerability hacking in the millions because there is no gRPC.\n\n### Describe the solution you'd like\n\nBelow is a concise, solution-focused summary of the proposal, describing the ideal approach to implementing a native gRPC/dRPC interface in a Bitcoin Core fork. It highlights the most critical steps, benefits, and security considerations:\n\nSolution Overview\nFork Bitcoin Core & Introduce gRPC/dRPC\n\nCreate a specialized branch (e.g., feature/grpc-integration) in the Bitcoin Core repository.\nAdd gRPC/dRPC functionality as optional via a build flag (--enable-grpc or similar).\nMaintain the existing JSON-RPC interface for backward compatibility, so developers can choose between the old and new interfaces.\nFile & Code Structure\n\nAdd a src/grpc/ directory containing:\ngRPC.h / gRPC.cpp for core gRPC server classes and methods.\ngRPC.c if lower-level or C-based bridging code is needed.\nDefine .proto files (e.g., bitcoin_service.proto) in a proto/ folder, describing request/response structures (e.g., GetBlockHeight, GetBalance).\nInitialization & Compilation\n\nExtend Bitcoin Core‚Äôs build system (Autotools/CMake) to detect and link against gRPC and protobuf libraries.\nWrap all new gRPC/dRPC code with #ifdef ENABLE_GRPC guards to ensure the core remains minimal if the feature is disabled.\nModify init.cpp and shutdown.cpp to start and stop the gRPC/dRPC server (e.g., listening on 0.0.0.0:50051).\nCore Functionality\n\nBitcoinServiceImpl: Implement necessary Bitcoin RPC calls in gRPC form, such as:\nGetBlockHeight() to retrieve chain height,\nGetBalance() or more advanced features for multi-chain queries and wallet management.\nEnsure each gRPC handler carefully validates user inputs (to prevent injection or tampering).\nSecurity & Best Practices\n\nAuthentication: Support TLS for secure connections; use token/cookie-based auth mirroring the existing JSON-RPC approach.\nError Handling: Sanitize all error messages (avoid leaking stack traces, method details, or sensitive data).\nConcurrency Controls: gRPC is multi-threaded by default. Add locks around wallet or UTXO data to prevent race conditions.\nReplay Protection (for dRPC): If integrating signing/cross-chain bridging, enforce nonces and domain checks.\nIncremental Rollout: Test thoroughly on regtest or testnet environments before any mainnet release.\nMulti-Chain & Ecosystem Alignment\n\nIntegrate with Bitcore via Node.js ‚Äúnative addons,‚Äù allowing JavaScript/TypeScript apps to call the new gRPC services seamlessly.\nProvide optional JSON bridging for developers already reliant on JSON-formatted inputs/outputs.\nCoordinate with cross-chain platforms (e.g., Mintscan, interchain.io) to standardize calls, reduce custom bridging hacks, and bolster security across the ecosystem.\nAddressing Bitcoin‚Äôs Price & Cosmos SDK Friction\n\nBy demonstrably improving Bitcoin‚Äôs developer experience and cross-chain readiness, user confidence may rise‚Äîalleviating some negative market sentiment and reinforcing Bitcoin‚Äôs position in multi-chain solutions.\nCollaboration or at least dialogue with the Cosmos SDK team‚Äîespecially regarding repeated issues or ‚Äúblocking‚Äù behaviors‚Äîwill help ensure stable, robust interoperability across ecosystems.\nWhat This Solution Achieves\nModernizes Bitcoin‚Äôs Developer API: gRPC or dRPC can provide streaming, structured messaging, and higher throughput compared to JSON-RPC.\nStrengthens Cross-Chain Reliability: A clear, well-secured gRPC/dRPC interface prevents ad-hoc or insecure bridging, reducing vulnerabilities.\nRetains Bitcoin‚Äôs Core Ethos: Making it an optional build feature respects Bitcoin‚Äôs minimal, consensus-driven philosophy while allowing progressive adoption.\nAddresses Ecosystem Tensions: Transparent, standardized interfaces reduce friction with Cosmos-based chains, minimize duplication, and build trust‚Äîpotentially improving Bitcoin‚Äôs market perception.\nThis solution‚Äôs end goal: a smoother, more secure interaction model for Bitcoin, delivering improved multi-chain support without compromising the stability and consensus processes that the Bitcoin community holds dear.\n\n### Describe any alternatives you've considered\n\nBNB bridging is still vulnerable as a bridge because of the lack of gRPC hooking within the API\n\nBelow is a brief overview of alternative approaches considered (beyond forking Bitcoin Core to natively integrate gRPC/dRPC). Each has distinct pros and cons regarding security, performance, and maintainability.\n\n1. External ‚ÄúBridge‚Äù or Proxy Service\nWhat It Entails\n\nDevelop a standalone daemon (or microservice) that runs alongside bitcoind. This service communicates with Bitcoin Core over the existing JSON-RPC interface, then exposes a gRPC/dRPC endpoint externally.\nPros\n\nNo Upstream Changes: Avoids modifying Bitcoin Core directly, so there‚Äôs no need for a dedicated fork or consensus from Bitcoin Core maintainers.\nQuick Prototyping: Faster to build and iterate upon since you‚Äôre simply layering a new service over the existing JSON-RPC.\nCons\n\nMaintenance Overhead: Yet another moving piece to install, update, and secure‚Äîpotentially duplicating logic.\nPotential Desynchronization: Must keep the external proxy‚Äôs code and endpoint definitions in sync with any changes to Bitcoin Core JSON-RPC.\nPerformance Bottleneck: Additional network hops (gRPC/dRPC ‚Üí Bridge ‚Üí JSON-RPC ‚Üí bitcoind) might reduce efficiency.\n2. Retrofitting btcd or Other Bitcoin Implementations\nWhat It Entails\n\nInstead of modifying ‚ÄúBitcoin Core‚Äù itself, implement gRPC/dRPC in alternative full-node implementations such as btcd (written in Go) or bcoin (JavaScript-based). These projects have different architectures and may be more open to additional services.\nPros\n\nCommunity-Friendlier: Smaller dev communities can be more receptive to changes.\nRapid Iteration: Generally, alt-implementations move faster than Bitcoin Core in adding features.\nCons\n\nLess Adoption: Bitcoin Core remains the de facto standard client; many exchanges, wallet providers, and node operators only trust or support ‚ÄúCore.‚Äù\nFragmentation: Splitting development efforts across multiple Bitcoin implementations can create inconsistencies and compatibility challenges.\n3. Relying on Cosmos or Bitcore to Solve It\nWhat It Entails\n\nWaiting for Cosmos SDK or Bitcore teams to develop bridging modules or wrappers that handle Bitcoin‚Äôs JSON-RPC internally and unify it under a new or existing gRPC/dRPC interface.\nPros\n\nNo Direct Bitcoin Changes: Offloads development and maintenance efforts to third-party ecosystems.\nPotential Ecosystem Standards: If Cosmos and Bitcore unify around a single bridging interface, multi-chain devs might benefit from a standardized solution.\nCons\n\nDependency on External Roadmaps: Cosmos/Bitcore maintainers may have other priorities or be blocked by internal disagreements (e.g., issues caused by ‚ÄúJulien‚Äù in Cosmos).\nUnpredictable Timelines: No guarantee if or when they‚Äôll deliver a robust, secure bridging solution.\nLimited Control: You‚Äôre reliant on external teams for critical security and feature decisions, which can hamper timely fixes or customizations.\n4. Staying With JSON-RPC Only\nWhat It Entails\n\nContinue using the existing JSON-RPC interface for all Bitcoin operations, possibly augmenting with improved documentation or partial bridging solutions.\nPros\n\nNo Changes Needed: Zero modification to Bitcoin Core or external dependencies.\nWidely Understood: JSON-RPC has been in place for years, so tooling and documentation already exist.\nCons\n\nNo Streaming: Lacks the real-time streaming or efficient chunked data transfers that gRPC can offer.\nLess Interoperable: Multi-chain solutions often use gRPC/dRPC, making Bitcoin the ‚Äúodd one out‚Äù and requiring special-case handling.\nPotential Security Gaps: If bridging scripts remain ad hoc, they may not follow best security practices or might inadvertently leak sensitive data.\n5. Using REST Endpoints for Partial Functionality\nWhat It Entails\n\nExposing more advanced REST endpoints in Bitcoin Core (similar to the ‚ÄúREST interface‚Äù that already exists for some data), but not adopting full gRPC/dRPC.\nPros\n\nMinimal Code Changes: Expanding the existing REST capabilities requires less structural alteration than a wholly new gRPC server.\nFamiliar to Web Developers: REST is widely used, so devs might find it straightforward.\nCons\n\nNo Real-Time/Streaming: REST generally lacks native streaming and requires multiple polling requests for updates.\nStill Not gRPC: Cross-chain and advanced tooling typically leverage protocol buffers for efficient data transfer and wide language support; REST remains a less efficient fallback.\nSummary of Alternatives\nExternal Bridge: Simplifies short-term implementation but increases operational complexity.\nAlternate Implementations (btcd, bcoin, etc.): Potentially more open to feature additions, but lacks mainstream adoption.\nRely on Cosmos/Bitcore: Offloads effort but surrenders control to external roadmaps and priorities.\nStick to JSON-RPC: Zero changes but perpetuates multi-chain friction and security workarounds.\nEnhanced REST Endpoints: Minor expansion but still not a full replacement for real-time gRPC/dRPC features.\nEach approach addresses different constraints, but none offers the same performance, flexibility, and direct cross-chain compatibility as a native gRPC/dRPC fork of Bitcoin Core.\n\n\n\n### Please leave any additional context\n\nIf you have any new or follow-up questions about these alternatives‚Äîsuch as how to implement a specific one, how to mitigate certain security issues, or how to align the solution with existing tooling‚Äîfeel free to let me know, and I‚Äôll be happy to help.\n\n\n\n\n\n\n\n",
      "state": "closed",
      "user": "ghost",
      "created_at": "2025-03-15T12:53:06Z",
      "updated_at": "2025-03-15T13:18:43Z",
      "comments": 2,
      "url": "https://github.com/bitcoin/bitcoin/issues/32076",
      "labels": [
        "Feature"
      ],
      "comment_list": [
        {
          "user": "ghost",
          "body": "as for the coinbase SDK with the AI model causing further mayhem because I'm quite sure they didn't even look at my repos and just let the thing  loose.... yeah that's another problem and bug we will need to resolvde-- I mean if you all just used Dr. Steve Scargal's and my adaptive persistent memory architecture, we wouldn't be having these issues with bugwatcher.c/.h and custodian.c/h,\n\nAlso the Github Staff needs to get off their butts and approve me so I can get sponsored and paid for this stuff guys.\n\nThis getting ridculous I haven't gottten paid for 7 months of hard iterative code work with you all, and it's still this fraudently buggy?\n\nLet's not even go over the incorrect handling that TRM Labs did by not hiring me because I didn't spin in kuberenetes yet when I interviewed with this. This is what happens, guys, next time stop being holier than thou, pay me, and maybe coinbase wouldn't have such a catastrophic failure that causes everyone to potentially be hackable and loose millions of crypto like this is QuadrigaCX all over again.",
          "created_at": "2025-03-15T13:07:16Z"
        },
        {
          "user": "pinheadmz",
          "body": "gRPC is a reasonable feature request and has been discussed before:\nhttps://github.com/bitcoin/bitcoin/issues/29912\nhttps://github.com/bitcoin/bitcoin/issues/16719\n\nThis issue was closed due to the personal information involved. It is reasonable to have a discussion on github about this techincal topic as long as it stays techincal.",
          "created_at": "2025-03-15T13:18:42Z"
        }
      ]
    },
    {
      "number": 32075,
      "title": ".",
      "body": ".",
      "state": "closed",
      "user": "farrelA",
      "created_at": "2025-03-15T11:10:15Z",
      "updated_at": "2025-03-22T04:24:16Z",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/issues/32075",
      "labels": []
    }
  ],
  "summary": {
    "pull_requests": 2,
    "issues": 3
  }
}