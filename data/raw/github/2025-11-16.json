{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T20:32:02.508870+00:00",
  "date": "2025-11-16",
  "pull_requests": [],
  "issues": [
    {
      "number": 33885,
      "title": "Improve Bitcoin’s resilience to large-scale power grid failures and Carrington-type solar storms",
      "body": "### Please describe the feature you'd like to see added.\n\nHi,\nThis is a feature request to explore options for improving Bitcoin’s resilience during large-scale, long-duration power or network outages (e.g., Carrington-type solar storms).\nSuch events could isolate regions for days or weeks, causing separate chain histories that later need reconciliation.\n\nThe request is to consider small, consensus-compatible improvements in documentation, defaults, or optional tools to help nodes operate on degraded communication channels (radio, mesh, intermittent links) and safely resync after long partitions.\n\nThis is not a consensus change proposal, just a request to evaluate whether these resilience tools should be better supported or documented.\n\nThanks for any feedback.\n\n### Is your feature related to a problem, if so please describe it.\n\nHi,\nI’m submitting this feature request to explore how Bitcoin could better withstand extreme, long-lasting infrastructure failures caused by major solar events. Before explaining the request itself, I want to provide a brief overview of what these events are, because their scale matters.\n\nA large solar storm occurs when the Sun emits an intense burst of charged particles and electromagnetic energy. When this material reaches Earth, it can disturb the magnetic field and induce strong electric currents in long conductors such as power lines. In extreme cases, this can damage transformers, overload electrical grids, interrupt satellite operations, and disrupt long-distance communication systems. The most famous historical example is the Carrington Event of 1859, the largest geomagnetic storm ever recorded. It triggered worldwide telegraph failures, fires in equipment, and intense auroras seen far from polar regions. Modern research suggests that a Carrington-level event striking today could cause regional or continental power grid failures lasting days to months, as well as major internet and satellite disruptions.\n\nThe issue for Bitcoin is that these types of events could fragment the network into isolated regions unable to communicate for extended periods. Each region might continue mining independently, creating separate versions of the chain. When connectivity eventually returns, deep chain splits and long reorgs could occur. Although Bitcoin’s consensus rules can handle this mechanically, the practical impact on users, operators, and services would be significant.\n\nThe purpose of this feature request is not to propose consensus changes, but to explore whether Bitcoin Core could improve resilience and operational clarity in such extreme scenarios. Specifically:\n\n1. Degraded communication support\nConsider improving documentation or optional tooling for running nodes over degraded or intermittent communication channels such as HF/VHF radio links, mesh networks, or intermittent satellite reception. These channels exist today in experimental form but may benefit from more formal guidance or optional integration.\n\n\n2. Partition detection and recovery\nProvide tools or clearer operational instructions for node operators to detect long-lived network partitions, understand their implications, and safely resynchronize after extended isolation periods without risking accidental unsafe behavior.\n\n\n3. Operator guidance\nDocument best practices for wallets, miners, and node operators during extreme, high-latency, or partitioned network conditions to minimize user disruption during future reconnection events.\n\n\n\nThis request is simply to consider whether these improvements fall within Bitcoin Core’s scope, or whether they should be handled entirely by external projects. If this discussion belongs on the mailing list first, I’m willing to move it there.\n\nThanks for your time and any feedback.\n\n### Describe the solution you'd like\n\n_No response_\n\n### Describe any alternatives you've considered\n\n_No response_\n\n### Please leave any additional context\n\n_No response_",
      "state": "closed",
      "user": "alexandre-leng",
      "created_at": "2025-11-16T18:50:10Z",
      "updated_at": "2025-11-16T22:09:58Z",
      "comments": 2,
      "url": "https://github.com/bitcoin/bitcoin/issues/33885",
      "labels": [
        "Feature"
      ],
      "comment_list": [
        {
          "user": "alexandre-leng",
          "body": "This is just a starting point to spark some thought.",
          "created_at": "2025-11-16T18:51:03Z"
        },
        {
          "user": "pinheadmz",
          "body": "This should be posted on the [bitcoin-dev mailing list](https://groups.google.com/g/bitcoindev), the [Delving Bitcoin forum](https://delvingbitcoin.org/) or some other platform where broad, protocol-level concepts are discussed. Conceptual questions and most usage questions can be posted on [Stack Exchange](https://bitcoin.stackexchange.com/). The Bitcoin Core issue tracker is reserved for discussion about this specific software project only, its implementation and usage.",
          "created_at": "2025-11-16T22:09:58Z"
        }
      ]
    },
    {
      "number": 33884,
      "title": "interface_ipc functional test failing in CI",
      "body": "## Summary\n\nThe `interface_ipc` functional test is failing in CI but passes when run locally.\n\nAffected PR's: #33856 and #33878 ",
      "state": "closed",
      "user": "yuvicc",
      "created_at": "2025-11-16T08:32:04Z",
      "updated_at": "2025-11-20T17:19:30Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/issues/33884",
      "labels": [
        "Tests",
        "CI failed"
      ],
      "comment_list": [
        {
          "user": "fjahr",
          "body": "I have opened #33880 to address this.",
          "created_at": "2025-11-16T21:48:20Z"
        }
      ]
    },
    {
      "number": 33883,
      "title": "\"Send\" text field has too little amount",
      "body": "### Is there an existing issue for this?\n\n- [x] I have searched the existing issues\n\n### Current behaviour\n\nThe \"Amount\" input field on the \"Send\" tab is too narrow; the user can only see a single digit.\n\nThe screenshot is below:\n\n<img width=\"1280\" height=\"1024\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/2c75a951-609d-4c87-b62e-8aa3d31494cc\" />\n\n### Expected behaviour\n\nUser should see all digits on payment amount.\n\n### Steps to reproduce\n\n1. Download latest release from https://bitcoincore.org/en/download/\n2. Open the program.\n3. After wallet sync completes, go to \"Send\" tab.\n\n### Relevant log output\n\n_No response_\n\n### How did you obtain Bitcoin Core\n\nPre-built binaries\n\n### What version of Bitcoin Core are you using?\n\nv30.0.0\n\n### Operating system and version\n\nWindows 11 Enterprise (26200.7171)\n\n### Machine specifications\n\n_No response_",
      "state": "closed",
      "user": "ofry",
      "created_at": "2025-11-16T04:39:50Z",
      "updated_at": "2025-11-19T12:30:02Z",
      "comments": 3,
      "url": "https://github.com/bitcoin/bitcoin/issues/33883",
      "labels": [],
      "comment_list": [
        {
          "user": "pinheadmz",
          "body": "Weird! Would you mind moving this issue to the GUI repo?\n\nhttps://github.com/bitcoin-core/gui",
          "created_at": "2025-11-16T12:37:42Z"
        },
        {
          "user": "ofry",
          "body": "Ah, it's already created by another user. https://github.com/bitcoin-core/gui/issues/906",
          "created_at": "2025-11-16T13:20:23Z"
        },
        {
          "user": "pinheadmz",
          "body": "Ok thanks, closing this as duplicate",
          "created_at": "2025-11-16T15:12:29Z"
        }
      ]
    },
    {
      "number": 33882,
      "title": "Standardness policy rules for legacy Multisig script is incoherent",
      "body": "Over the years policy surrounding multisig scripts, particularly for legacy multisig scripts, has evolved in a haphazard way with various PRs affecting  legacy multisig script policy without considering the ramifications.\n\nThe current status of legacy multisig script policy is as follows:\n\n* Legacy multisig outputs in transactions can be at most *m*-of-3.  All pubkeys in such outputs must be of the form of a compressed pubkey, or uncompressed pubkey, or a hybrid pubkey.\n* Legacy multisig inputs being redeemed in transaction can be *m*-of-*n* with *m* and *n* 20 or less.  Any public keys processed by OP_CHECKMULTISIG must be compressed or uncompressed pubkeys.  hybrid or other data blobs are only allowed in the unprocessed part of the public key list.\n\nWhile it is acceptable for legacy multisig output creation policy to be stricter than redemption policy, it makes no sense to allow hybrid keys in outputs by policy, but then to disallow them as inputs by policy.\n\nHowever, there are further issues. Legacy multisig policy has evolved over time.  In the beginning when legacy multisig outputs were introduced as standard by BIP 11, \"pubkeys\" were allowed by policy to be any value between 33 and 120 bytes.  Some Bitcoin users have taken advantage of those liberal policies and created legacy multisig script UTXOs that were redeemable by policy at the time they were created, but are no longer redeemable by policy today.  The UTXO 4dacd03d73cb497229dbfe2e7209adc4221540efe0e4c57f408b09b2fd36ece6:1 from 2014-01-12 is but one example.  @ajtowns's analysis in #33755 suggests there are at least 147,470 such UTXOs that have become *soft-confiscated* over time, meaning that when they were created they were redeemable by policy, but become no longer redeemable by policy and would require direct miner assistance to be spent.\n\nBased on my research, I believe there are 4 tasks that need to be done to make legacy Multisig policy coherent again.\n\n### 1. Ban hybrid keys in legacy outputs\n\nWe should strengthen the rules surrounding creating legacy multisig (and legacy single sig) to ban the use of hybrid keys.  Such keys are nearly irredeemable.  However, we should only strengthen policy around the creating new legacy script outputs without further restricting policy around redeeming legacy script UTXOs.\n\n### 2. Bring legacy script redemption policy in line with P2SH redeem script policy.\n\nP2SH redeem script policy has also evolved over time.  Current policy for P2SH redemption allow any scripts so long as they have a limited number of CHECKSIG related operations.  I see no reason why legacy script should be subject to significantly more stringent constraints than P2SH redeem scripts are.\n\n### 3. Relax `SCRIPT_VERIFY_STRICTENC` policy to only ban hybrid keys.\n\nPR #5247 went unnecessarily overboard in its quest to stomp out uses of hybrid keys and made UTXOs that already existed at the time unspendable.  PR #33755 partially reverts this change so that only hybrid keys are excluded from processing in  CHECKMULTISIG.\n\n### 4. Bring `SCRIPT_VERIFY_WITNESS_PUBKEYTYPE` policy in line with BIP 143 requirements.\n\nThis task is technically unrelated to legacy multisig policy, being instead about Segwit V0 multisig policy.  However the policy implemented in Bitcoin Core does not match the policy stated in BIP 143, and they ought to be brought into agreement. Either by implementing the policy correctly (as #33759 does), or by amending BIP 143 to describe the current policy as implemented.\n\nIn particular, both tasks 2 and 3 need to be completed in order to make stuck UTXOs, such as 4dacd03d73cb497229dbfe2e7209adc4221540efe0e4c57f408b09b2fd36ece6:1 spendable by policy again.\n\nI want to make it clear that UTXOs such as the above are not particularly abusive.  They were simply caught up incidentally in the policy changes of PR #5247, which was only about banning the use of hybrid keys.  4dacd03d73cb497229dbfe2e7209adc4221540efe0e4c57f408b09b2fd36ece6:1 has no hybrid nor hybrid looking pubkeys in it.\n\n```\t\nOP_PUSHNUM_1\nOP_PUSHBYTES_33 035bceeb417f25beaa28d133ee7b28faa1e4f5c2f76b8daf12c3fab18261718790\nOP_PUSHBYTES_33 1c434e545250525459000000000000000000000001000000004190ab0000000000\nOP_PUSHNUM_2\nOP_CHECKMULTISIG\n```\n*The script from UTXO 4dacd03d73cb497229dbfe2e7209adc4221540efe0e4c57f408b09b2fd36ece6:1*",
      "state": "open",
      "user": "roconnor-blockstream",
      "created_at": "2025-11-16T02:09:46Z",
      "updated_at": "2026-01-13T00:50:47Z",
      "comments": 13,
      "url": "https://github.com/bitcoin/bitcoin/issues/33882",
      "labels": [
        "Brainstorming",
        "TX fees and policy"
      ],
      "comment_list": [
        {
          "user": "roconnor-blockstream",
          "body": "## How did we get here\n\nI've compiled a list of what I believe are all the relevant PRs related to policy surrounding multisig scripts, listed in chronological order. This work is based on previous work done by @ajtowns \n\n### PR #669; merged 2011-12-20\nThis PR introduces *m*-of-*n* checkmultisig as a solvable script for the first time. Solvability requires *m* and *n* to be at most 16. Per BIP 11, standardness requires solvable MULTISIG tx outputs to be at most *m*-of-3 and *m* to be ~less than~ less than or equal to *n*.\n\nAny data between 33 and 120 bytes is considered a \"pubkey\" for solvability purposes.\n\nThis PR also introduces a new standardness rule requiring redeemed legacy scripts to be solvable. This is done because the solver needs to be run to determine if the UTXO's scriptpubkey being redeemed is an OP_EVAL (later P2SH) script.\n\nBoth legacy scripts redeemed and OP_EVAL/P2SH redeem scripts are required to be solvable at redemption time. Additionally  EVAL/P2SH redeem scripts are required to be standard.\n\nBe aware of the difference between a solvable script and a standard script. Standard scripts are limited to *m*-of-3 multisig, but solvability allows up to 16.  Standardness is stronger than solvability.\n\nBecause the scriptpubkey for legacy UTXOs are now checked for solvability, any subsequent strengthening of standardness rules via `Solver` becomes a vector for soft-confiscation of UTXOs.\n\n\n### PR #769; merged 2012-02-07\nUnexpected stack items are banned using `ScriptSigArgsExpected` counting when redeeming legacy script and P2SH script. This seems to be done to prevent data stuffing in scriptsigs. It is unclear if the data stuffing is a concern or the malleability is a concern. (Later code comments in PR #4365 suggests malleability isn't actually a concern, but PR comments in PR #7387 suggests it was.)\n\nThe relevance here is that `Solver`'s output is now also being used to help count the number of expected stack items. Later `ScriptSigArgsExpected` will be removed.\n\nUnless I'm mistaken, this PR also no longer requires P2SH scripts to be standard and now merely requires them to be solvable.  This enables larger P2SH multisig scripts beyond *m*-of-3. This change seems to be a violation of BIP 16 standardness rules, but it passes without comment.\n\n### PR #1742; merged 2012-10-20\n`CHECKSIG` and `CHECKMULTISIG` operations are modified to check pubkeys to see if they are in canonical form, which must begin with `0x02`, `0x03` or `0x04`, and be of suitable lengths.\n\nAt this point non-canonical pubkey stack items are not yet banned from OP_CHECKMULTISIG. Instead, mempool policy diverges from consensus policy as all non-canonical pubkey stack items immediately count as a signature failure, with OP_CHECKSIG pushing a 0 in these cases and OP_CHECKMULISIG moving to the next pubkey. While non-pubkey would always fail the CHECKSIG anyways, this is a problem for valid hybrid keys where script execution for mempool policy could cause execution to diverge from consensus rule execution.\n\nThis counts as a slight tightening of policy around the redemption (but not creation) of scripts using hybrid keys and applies both to P2SH and legacy scripts.\n\n### PR #3718; merged 2014-02-14\n\nSolvability (and hence standardness) for script is tightened so that for script standardness purposes pubkey data must be between 33 and 65 bytes rather than 33 and 120 bytes.\n\nDue to the fact that solvability rules are checked upon UTXO redemption means that some funds, both P2SH and legacy, could have been soft-confiscated here.\n\n::TODO:: see if any such UTXOs exist.\n\n### PR #4365; merged 2014-06-27;\nP2SH rules are relaxed so non-solvable redeem scripts are allowed if sigop count is less than 15(?). Clean stack not required for redeeming such non-standard P2SH redeem scripts. I don't know why this is considered okay.\n\nThis is the beginning of the divergence of policy between redeeming legacy script and redeeming P2SH script.\n\n### PR #5247; merged 2014-11-21\n\nThe inconsistency between mempool policy execution of script and consensus execution of script is resolved by failing `SCRIPT_VERIFY_STRICTENC` standardness whenever a pubkeys processed by `CHECK*SIG` is non-canonical.\n\nThis accidently causes in-use pre-counterparty-1.0-like legacy multiscript UTXO's to be soft-confiscated. e.g. 4dacd03d73cb497229dbfe2e7209adc4221540efe0e4c57f408b09b2fd36ece6:1 from 2014-01-12. The effect of soft-confiscating existing UTXO seems to have been inadvertent and wasn't contemplated in this PR.\n\nThis policy only applies to redemption, not creation of outputs. Standardness rules still allow creating transactions with legacy script outputs with non-canonical keys.\n\n### PR #7387; merged 2016-01-22;\nScriptSigArgsExpected is removed since now SCRIPT_VERIFY_CLEANSTACK is robustly checking for a clean stack.\n\nFurther divergence between redeeming legacy script and redeeming P2SH occurs as now as P2SH redeem scripts are themselves no longer checked for solvability. So long as the P2SH redeem scripts have a low enough `GetSigOpCount` they are allowed here. Legacy script redemptions still must be solvable scripts.\n\nIn particular, P2SH multisig redeem scripts with 66-120 byte \"pubkeys\" occurring at the end of their list that may have been soft-confiscated in PR #3718 are now, once again, redeemable.\n\n### PR #8499; merged 2016-10-17;\nFor the new P2WSH script, this PR attempts to implement the policy mandated by BIP 143:\n\n> As a default policy, only compressed public keys are accepted in P2WPKH and\n> P2WSH. Each public key passed to a sigop inside version 0 witness program must\n> be a compressed key: the first byte MUST be either 0x02 or 0x03, and the size\n> MUST be 33 bytes. Transactions that break this rule will not be relayed or mined\n> by default.\n\nHowever, the implementation fails to adhere to the policy written above and only checks that, for P2WSH, the pubkeys processed by CHECKMULTISIG are compressed public key, rather than checking that all keys passed to CHECKMULTISIG are compressed public keys.\n\n### PR #12460; merged 2018-04-04;\nSolvability rules for scripts are tightened to require pubkeys in them to be well-formed, but not-necessarily canonical.\n\nNow the creation of legacy script UTXOs are, by standardness, required to be canonical or hybrid pubkeys.\nIt is still the case that if script evaluation encounters a hybrid pubkey it is a violation of `SCRIPT_VERIFY_STRICTENC` standardness rules to redeem.\n\nHowever because scriptpubkeys still are checked during redemption for solvability for legacy script (but not P2SH script), this PR likely soft-confiscates even more UTXOs.\n\nPre-counterparty-1.0-like legacy multiscript UTXO are now in violation of two redemption rules:  They are neither solvable, and if they were executed the OP_CHECKMULTISIG would fail when trying to process non-canonical keys.\n\n::TODO:: Find examples of UTXOs newly soft-confiscated by this PR.\n\n### EDIT: PR #13194; merged 2018-05-30\nThis PR refactors the Solver.  The solver now fails when *m* > *n* in an *m*-of-*n* multisig.  This is not a soft confiscation because such outputs are (a) unspendable anyways, and (b) were never standard to begin with.\n\n### PR #20867; merged 2021-05-03\n\nThis PR lifts the solvability of *m*-of-*n* multisig up from 16 to 20, *increasing* the types of legacy multisig scripts that are now redeemable.  Transactions creating legacy multisig continue to be limited to 1 ≤ m ≤ n ≤ 3.",
          "created_at": "2025-11-16T02:12:29Z"
        },
        {
          "user": "ajtowns",
          "body": "> standardness requires solvable MULTISIG tx outputs to be at most _m_-of-3 and _m_ to be less than _n_.\n\nThe requirement is for `m` not to be greater than `n`, as far as I can see? (via both `IsStandard()` and `Solver()`)\n\n> Solvability (and hence standardness) for script is tightened so that for script standardness purposes pubkey data must be between 33 and 65 bytes rather than 33 and 120 bytes.\n> \n> ::TODO:: see if any such UTXOs exist.\n\nI believe there are four utxos that match this for bare multisig (ie, have a pubkey push of more than 65 bytes):\n\n * [f039df74dc453ea138d03ca463bd60ab947a27a5c62002c6e3404ba8222a77cc:3](https://mempool.space/tx/f039df74dc453ea138d03ca463bd60ab947a27a5c62002c6e3404ba8222a77cc) 12000 sats, block 269754\n * [c1836e90b62e0907ba39381c2b86e2cc78a79bfc8dd2c5fdf849e1f3ad2b89df:3](https://mempool.space/tx/c1836e90b62e0907ba39381c2b86e2cc78a79bfc8dd2c5fdf849e1f3ad2b89df) 12000 sats, block 269786\n * [791c0a733fa4815f54119de0a1378e6a27528be3da78a3bc6d9109ea92cf4e75:3](https://mempool.space/tx/791c0a733fa4815f54119de0a1378e6a27528be3da78a3bc6d9109ea92cf4e75) 12000 sats, block 269791\n * [13960ff2e2b37dc3437b1d905973d9b0f8c94a24750d5b8b1b9b71f94a8a1dcd:3](https://mempool.space/tx/13960ff2e2b37dc3437b1d905973d9b0f8c94a24750d5b8b1b9b71f94a8a1dcd) 12000 sats, block 269602\n\nHowever, they're all 1-of-1 with 66 byte keys (that look like two 33 byte compressed keys concatenated?) so are presumably unspendable anyway.\n\n> PR [#12460](https://github.com/bitcoin/bitcoin/pull/12460); merged 2018-04-04;\n> \n> Solvability rules for scripts are tightened to require pubkeys in them to be well-formed, but not-necessarily canonical.\n> \n> ::TODO:: Find examples of UTXOs newly soft-confiscated by this PR.\n\nI believe this means that while we previously allowed spending `1 [data] [pubkey] 2 CHECKMULTISIG` via a signature from `pubkey`, but not `1 [pubkey] [data] 2 CHECKMULTISIG` (because we'd see `data` was not a compressed-or-uncompressed pubkey, and abort), we now would not, because `data` is not a valid-sized-pubkey. (This would fail `AreInputsStandard()` due to `Solver()` failing due to `CPubKey::ValidSize()` being strict)\n\nI think there are 405 utxos that fit that pattern, though they're all very small. The ones with more than 786 sats are:\n\n * [c04ee885ce41068497381633a5d47dcdf5ad1a1e2affd8417aab028334dcb08f:1](https://mempool.space/tx/c04ee885ce41068497381633a5d47dcdf5ad1a1e2affd8417aab028334dcb08f) 7800 sats, block 334012\n * [b66904081cef5cadfd693715e2d0bd622a5726aa410217b9f26bd5bdd92e2231:1](https://mempool.space/tx/b66904081cef5cadfd693715e2d0bd622a5726aa410217b9f26bd5bdd92e2231) 7800 sats, block 346429\n * [a3c66f98eea1f34b81fe4e30215cb04c9c9810207f4119b4154c2fc83e735c9b:1](https://mempool.space/tx/a3c66f98eea1f34b81fe4e30215cb04c9c9810207f4119b4154c2fc83e735c9b) 7800 sats, block 347150\n * [9da063f7aad545b97e3ad5a5b12fdadbe8a7f2ebd39c437cd8a56541a4d8049b:1](https://mempool.space/tx/9da063f7aad545b97e3ad5a5b12fdadbe8a7f2ebd39c437cd8a56541a4d8049b) 7800 sats, block 346429\n * [9336b7e53d30bf4d7d7e8d9bc37a4af13ec48fba46474d682fa34ebd177ef384:1](https://mempool.space/tx/9336b7e53d30bf4d7d7e8d9bc37a4af13ec48fba46474d682fa34ebd177ef384) 7800 sats, block 346421\n * [8f7c4607cdf8867ca04f13de2585cb362b01354d7a05ce8ecbb94060d4d65c6e:1](https://mempool.space/tx/8f7c4607cdf8867ca04f13de2585cb362b01354d7a05ce8ecbb94060d4d65c6e) 7800 sats, block 347143\n * [58c09c0adfe1154023272203b327bae2151a652f62f6533cc76a9a1afc4cc19e:1](https://mempool.space/tx/58c09c0adfe1154023272203b327bae2151a652f62f6533cc76a9a1afc4cc19e) 7800 sats, block 346423\n * [3cd32f8e095162596af58f9ef89833ce3926d4bd18b8faa18bceefd47c3a527c:1](https://mempool.space/tx/3cd32f8e095162596af58f9ef89833ce3926d4bd18b8faa18bceefd47c3a527c) 5460 sats, block 337857\n * [2ecae24a049993142260861d32275d40461936679e9efa9c2504cacd4048914c:1](https://mempool.space/tx/2ecae24a049993142260861d32275d40461936679e9efa9c2504cacd4048914c) 5460 sats, block 338414\n * [90b92bfa1c76d97adde6304ef3aa597f0d8e0901e5bfdecf6f02dc870f32bc9c:1](https://mempool.space/tx/90b92bfa1c76d97adde6304ef3aa597f0d8e0901e5bfdecf6f02dc870f32bc9c) 882 sats, block 334019\n\nHere's a CSV of what I think are all the baremultisigs that aren't just all-compressed-keys (ie every pubkey push is 33 bytes beginning with 02 or 03, m is less than n, n is 1 through 16): [baremult-923997.csv.bz2](http://azure.erisian.com.au/~aj/tmp/baremult-923997.csv.bz2) sha256 is `9951903516def05402ca4a6d8f64773f87e5f6611324e8ee86e44ce2a34982e7`. It's 21M compressed, 76M uncompressed, 266k utxos. spktype is BMU if it just has some uncompressed keys, BMD if it has hybrid/invalid keys, BMSZ if it has keys outside the 33-65 byte range, and BMWEIRD if it didn't parse as expected. Doesn't include anything that didn't match `OP_m ... OP_n OP_CHECKMULTISIG` with 1<=m<=n<=16.\n\nFor interest, looking at all utxos by type (with a little marker for ones that expose pubkeys to quantum attackers):\n\n|type|num utxos|total value|qv|type desc|\n|---|---:|---:|---|---|\n|WPKH|48,099,317|7,054,948.7201_8170||p2wpkh (segwit v0 single sig)|\n|PKH|45,291,937|5,721,757.7725_2479||p2pkh|\n|SH|12,946,965|4,015,214.8756_0840||p2sh|\n|PKU|34,376|1,711,833.0160_1304|:atom:|pay to bare pubkey, uncompressed|\n|WSH|2,421,892|1,254,033.7434_0198||p2wsh (segwit v0 script/multisig)|\n|TR|55,861,027|182,751.7906_9625|:atom:|taproot|\n|PK|10,276|6,536.6290_0123|:atom:|pay to bare pubkey, compressed|\n|UNK|20,752|2,617.5862_4609||weird stuff (eg \"sign with a pubkey that hashes to 0\")|\n|BMC|2,175,608|52.2136_0141|:atom:|bare multisig, compressed keys|\n|BMD|176,159|9.9984_3912|:atom:|bare multisig, data in keys|\n|BMU|89,796|6.9910_7231|:atom:|bare multisig, some uncompressed keys|\n|SWUPG|54,957|0.3051_4917||insecure, future segwit versions|\n|BMWEIRD|42|0.0207_3932||weird things that look like a multisig, generally unspendable|\n|BMSZ|4|0.0004_8000||listed above|\n\nFWIW, all the BMC, BMU, BMD and BMSZ utxos have n in [1,2,3].\n\nThe BMWEIRD ones are mostly 0 or 1 sat stuff, most of which is unspendable anyway; the remaining four are:\n\n * [3482ea1d219120b13f3be49f63fd7079136785dff2bf7487726b640da5876e33:0](https://mempool.space/tx/3482ea1d219120b13f3be49f63fd7079136785dff2bf7487726b640da5876e33) 2023000 sats, block 320071 (NOTIF != 17, unspendable)\n * [2bb7e8720356f79a9005488a529ab12d6f516879b2357224204cb5f2b780fd02:0](https://mempool.space/tx/2bb7e8720356f79a9005488a529ab12d6f516879b2357224204cb5f2b780fd02) 30919 sats, block 272252 (PUSH, DROP, 1-of-1 CMS)\n * [72590fcf0d8021bad77826c5008eaca3541f81d212d55bb7c02ec6a4bf584404:0](https://mempool.space/tx/72590fcf0d8021bad77826c5008eaca3541f81d212d55bb7c02ec6a4bf584404) 10000 sats, block 244029 (3 invalid keys, unspendable)\n * [66747648ef92d78bb36c267c0f444e6df96e44f463a2f92541483fcb8e882b27:1](https://mempool.space/tx/66747648ef92d78bb36c267c0f444e6df96e44f463a2f92541483fcb8e882b27) 10000 sats, block 278495 (checkmultisig but with pubkeyhashes)\n\nSo I believe only the BMD utxos are interesting here (BMC and BMU should already be both spendable and, depending on permitbaremultisig, creatable). \n\nPersonally, my take is that we should:\n * allow spending anything that (a) was previously spendable, (b) doesn't make validation slow, and (c) doesn't prohibit upgrade hooks/similar. ie, we should make it easy to spend bare multisigs with embedded data, or with hybrid pubkeys; but shouldn't change how restricted segwitv0 p2wsh scripts are\n * by default, disallow creating obsolete scriptPubKeys, including both bare multisig and bare un/compressed pubkey\n * if the permitbaremultisig=0 default is overridden, allow creating bare multisig outputs that include hybrid pubkeys or encoded data up to 65 bytes (in particular, so that allowing spending of such outputs involves fewer special cases in the code)",
          "created_at": "2025-11-17T13:54:51Z"
        },
        {
          "user": "roconnor-blockstream",
          "body": "> The requirement is for m not to be greater than n, as far as I can see? (via both IsStandard() and Solver())\n\nYeah, I meant to say \"less than or equal to\".  However, AFAICT this inequality is only enforced in standardness, not solvability.",
          "created_at": "2025-11-17T14:26:55Z"
        },
        {
          "user": "roconnor-blockstream",
          "body": ">  we should make it easy to spend bare multisigs with embedded data, or with hybrid pubkeys\n\nJust to be clear, we cannot allow hybrid pubkeys to be processed by `CHECKMULTISIG` without undermining the purpose of the hybrid pubkey ban. (However we can allow hybrid pubkeys that are unprocessed by `CHECKMULTISIG`.)\n\nMy understanding of the hybrid pubkey ban is that it is in place in case we wish to, one day, introduce a soft-fork that would allow implementations of Bitcoin Core to use a normal ECDSA validation routine that only succeeds on SEC 1 formatted public keys (i.e. canonical keys).  This requires failing script in  `CHECKSIG` and `CHECKMULTISIG` as soon as a hybrid pubkey is encountered for processing.\n\nI was previously thinking that we could only ban *successful* hybrid pubkey signatures.  In other words, `CHECKSIG` and `CHECKMULTISIG` could process they hybrid pubkey and only fail the script in case the signature was successful. Alas, this would fail to meet the above purpose of the hybrid pubkey ban, for if this rule were to become part of consensus, then consensus implementation would still have to run the ECDSA validation engine on hybrid pubkeys in order to determine if they need to abort the script or not.\n\nThat said we *could* simply abandon our hybrid pubkey policy entirely and give up on this soft-fork.  I'm not advocating this, but it is a possibility.\n\nIt might be worth dividing your BMD category into those with some hybrid pubkeys and those without any hybrid pubkeys.",
          "created_at": "2025-11-17T15:06:51Z"
        },
        {
          "user": "instagibbs",
          "body": "> The requirement is for m not to be greater than n, as far as I can see? (via both IsStandard() and Solver())\n\ncirca e679ec969c8b22c676ebb10bea1038f6c8f13b33 *creation* was constrained to m-of-3",
          "created_at": "2025-11-17T16:22:23Z"
        },
        {
          "user": "ajtowns",
          "body": "> Yeah, I meant to say \"less than or equal to\". However, AFAICT this inequality is only enforced in standardness, not solvability.\n\n`Solver()` calls `MatchMultisig()` which invokes `num_keys = GetScriptNuymber(opcode, data, required_sigs, MAX_PUBKEYS_PER_MULTISIG)` which returns nullopt if the CScriptNum isn't minimal and between `required_sigs` and `MAX_PUBKEYS_..`, so I believe it's enforced in both places.\n\n> Just to be clear, we cannot allow hybrid pubkeys to be processed by `CHECKMULTISIG` without undermining the purpose of the hybrid pubkey ban\n\nYes; I don't think a hybrid pubkey ban is worth maintaining. By switching from openssl to libsecp256k1 we've avoided the possibility of new formats being unexpectedly introduced ([ref](https://gnusha.org/pi/bitcoindev/CA+s+GJAc8ZX9ziapULE7KJpJUonTv+sfncw0RGLwu_YPQrM=zw@mail.gmail.com/)), and the validation cost (and data carrying ability if faked) of a hybrid pubkey is essentially the same as that of an uncompressed pubkey which we'll continue to support for spending. So I'm not seeing the value in treating hybrid keys differently from uncompressed keys.\n\nNot intending to strongly advocate that view vs other alternatives at this point; just putting it out there to ensure that if we stick with the current direction, that it's for a good reason, not just because it's the status quo.\n\n> introduce a soft-fork that would allow implementations of Bitcoin ~~Core~~ to use a normal ECDSA validation routine that only succeeds on SEC 1 formatted public keys\n\nWhat we support by consensus matches the (earlier) ANSI X9.62-1998 standard; I don't see why we'd go to the trouble of a soft fork just to switch to a different standard/library. ([ref](https://bitcoin.stackexchange.com/questions/57855/c-secp256k1-what-do-prefixes-0x06-and-0x07-in-an-uncompressed-public-key-signif))\n\n> It might be worth dividing your BMD category into those with some hybrid pubkeys and those without any hybrid pubkeys.\n\nI think there are 384 BMD outputs with a hybrid-ish pubkey (65 bytes beginning with 06/07), but all but one are 1-sat. Here are the 5 most recent such utxos:\n\n * [2ecae24a049993142260861d32275d40461936679e9efa9c2504cacd4048914c:1](https://mempool.space/tx/2ecae24a049993142260861d32275d40461936679e9efa9c2504cacd4048914c) 5460 sats, block 338414 (hybrid pubkey is fake, ending in 112 bits of zeroes)\n * [d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d:9](https://mempool.space/tx/d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d) 1 sats, block 230622\n * [d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d:69](https://mempool.space/tx/d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d) 1 sats, block 230622\n * [d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d:57](https://mempool.space/tx/d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d) 1 sats, block 230622\n * [d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d:47](https://mempool.space/tx/d246f58b59be6595df03c404a6497177564c7b2bf5396596641e59d268b1b40d) 1 sats, block 230622\n\nI think there's five bare hybrid(looking) pubkey utxos:\n\n * [519c79dc444009744e5dec35817d0a7530ba3601aed58ac34837397134177db8:2](https://mempool.space/tx/519c79dc444009744e5dec35817d0a7530ba3601aed58ac34837397134177db8) 2817 sats, block 707034 (looks like a test transaction, with bare compressed and uncompressed variants of the same pubkey having been created and spent)\n * [657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1:34](https://mempool.space/tx/657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1) 1 sats, block 230217\n * [657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1:100](https://mempool.space/tx/657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1) 1 sats, block 230217\n * [657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1:158](https://mempool.space/tx/657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1) 1 sats, block 230217\n * [657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1:360](https://mempool.space/tx/657aecafe66d729d2e2f6f325fcc4acb8501d8f02512d1f5042a36dd1bbd21d1) 1 sats, block 230217\n\nObviously there could be zero to many hybrid pubkeys in either p2pkh or p2sh outputs as well.\n\nPython code:\n\n```python\ndef split_spk(spk):\n    ops = []\n    while len(spk) > 0:\n        if spk[0] <= 75 and len(spk) > spk[0]:\n            ops.append((spk[0], spk[1:spk[0]+1].hex()))\n            spk = spk[spk[0]+1:]\n        elif spk[0] >= 0x51 and spk[0] <= 0x60:\n            ops.append(spk[0] - 0x50)\n            spk = spk[1:]\n        else:\n            ops.append(\"OP_x%02X\" % (spk[0]))\n            spk = spk[1:]\n    return ops\n\ndef find_hybrid(sspk):\n    for a in sspk:\n        if isinstance(a, tuple):\n            l,x = a\n            if l == 65 and x[0] == '0' and x[1] in \"67\": return True\n    return False\n\nx = [a for a in [a.strip().split(\",\") for a in open(\"baremulti-923997.csv\", \"r\").readlines()]][1:] # if you unbz2'ed the datafile above\ny = [tuple(a + [split_spk(bytes.fromhex(a[6]))]) for a in x]\nz = [yy for yy in y if find_hybrid(yy[7])]\n```",
          "created_at": "2025-11-18T03:16:47Z"
        },
        {
          "user": "roconnor-blockstream",
          "body": "> Solver() calls MatchMultisig() which invokes num_keys = GetScriptNuymber(opcode, data, required_sigs, MAX_PUBKEYS_PER_MULTISIG).\n\nThis checking m ≤ n behaviour in the Solver seems to have been added in #13194.  However this wouldn't count as soft-confiscations because multisigs with m > n are presumably unspendable anways.\n\n> What we support by consensus matches the (earlier) ANSI X9.62-1998 standard\n\nAh, I was not aware of this.\n\nI wouldn't object to dropping the hybrid key protections.  I probably wouldn't object even if I didn't know about ANSI X9.62-1998.",
          "created_at": "2025-11-18T15:08:00Z"
        },
        {
          "user": "ajtowns",
          "body": "> This checking m ≤ n behaviour in the Solver seems to have been added in [#13194](https://github.com/bitcoin/bitcoin/pull/13194). However this wouldn't count as soft-confiscations because multisigs with m > n are presumably unspendable anways.\n\nYeah, see https://github.com/bitcoin/bitcoin/blob/4405b78d6059e536c36974088a8ed4d9f0f29898/script.cpp#L745 from the start of git history.\n",
          "created_at": "2025-11-19T02:38:44Z"
        },
        {
          "user": "151henry151",
          "body": "P2SH allows non-solvable redeem scripts with low sigop counts (PR #4365), while legacy scripts still require solvability. This inconsistency is hard to justify, especially since both rely on sigop limits for security.\n\nAligning legacy script redemption with P2SH policy would remove the asymmetry and fix the Counterparty UTXOs without special-casing, while preserving security through existing sigop limits.\n\nIf hybrid key bans are reconsidered (as ajtowns suggested), that could simplify further, but fixing the policy asymmetry seems like the right first step.",
          "created_at": "2025-11-20T04:39:32Z"
        },
        {
          "user": "roconnor-blockstream",
          "body": "I agree.  I think my next step would be to PR a change to `AreInputsStandard` to bring P2SH and legacy script policy into alignment.\n\nI'm not quite sure when I'll get to this, so if someone else wants to take a crack at it, I wouldn't be surprised if they can do it better / sooner than me.",
          "created_at": "2025-11-20T18:04:47Z"
        },
        {
          "user": "ajtowns",
          "body": "> P2SH allows non-solvable redeem scripts with low sigop counts (PR https://github.com/bitcoin/bitcoin/pull/4365), while legacy scripts still require solvability. This inconsistency is hard to justify, especially since both rely on sigop limits for security.\n\n> I agree. I think my next step would be to PR a change to `AreInputsStandard` to bring P2SH and legacy script policy into alignment.\n\nI think I disagree with this -- we allow spends of fairly arbitrary p2sh scripts, but limit legacy spends to only a few known templates. That's a good thing because it reserves a lot of space for upgrade hooks, which have been used for p2sh, segwit and taproot.\n\nI think maybe the issue is more that the way we check the templates is to use the Solver(), which is something we also use for the wallet; so when we attempt to clean up the wallet feature set to avoid doing stupid things that waste our users money in fees, that also impacts relay policy. Maybe we should separate out the \"can we parse this\" and \"is this stupid\" parts of Solver?",
          "created_at": "2025-12-02T14:29:44Z"
        },
        {
          "user": "roconnor-blockstream",
          "body": "> I think I disagree with this -- we allow spends of fairly arbitrary p2sh scripts, but limit legacy spends to only a few known templates. That's a good thing because it reserves a lot of space for upgrade hooks, which have been used for p2sh, segwit and taproot.\n\nOne thing I suggested to @151henry151 was to not only limit the number of checksig operations, as P2SH does, but to require at least one checksig operation.  Does that make you more comfortable?",
          "created_at": "2025-12-02T15:31:23Z"
        },
        {
          "user": "151henry151",
          "body": "If I'm not mistaken, my code in commit [1c67900568](https://github.com/151henry151/bitcoin/commit/1c67900568) does indeed limit the number of checksig operations to `MAX_P2SH_SIGOPS` (same limit as P2SH) and require at least one checksig operation. The implementation checks `if (sigop_count == 0 || sigop_count > MAX_P2SH_SIGOPS)` for non-P2SH legacy scripts (see [here](https://github.com/bitcoin/bitcoin/blob/1c67900568344aff642abd577722f9d3fc6c3e4a/src/policy/policy.cpp#L247) and [here](https://github.com/bitcoin/bitcoin/blob/1c67900568344aff642abd577722f9d3fc6c3e4a/src/policy/policy.cpp#L272)), ensuring scripts must have at least 1 sigop and at most 15 sigops, matching P2SH policy.",
          "created_at": "2026-01-11T05:31:25Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 0,
    "issues": 4
  }
}