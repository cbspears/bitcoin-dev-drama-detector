{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T05:41:30.461367+00:00",
  "date": "2026-01-06",
  "pull_requests": [
    {
      "number": 34214,
      "title": "policy: restore 80-byte default for datacarriersize",
      "user": "bensig",
      "state": "closed",
      "created_at": "2026-01-06T21:29:16Z",
      "updated_at": "2026-01-07T16:47:28Z",
      "body": "Restore the historical default of 80 bytes (83 with OP_RETURN + pushdata overhead) for -datacarriersize, while preserving the ability for node operators to configure any limit they prefer.\r\n\r\nThis is not a hard cap - users can still set -datacarriersize=100000 (or any value) to allow larger OP_RETURN outputs. The change only affects the default behavior when no explicit configuration is provided.\r\n\r\nRationale:\r\n- The unlimited default introduced in #32406 remains controversial\r\n- ~20% of nodes run Bitcoin Knots which maintains the 80-byte default\r\n- Inscriptions have no economic incentive to move to OP_RETURN since witness data is ~4x cheaper due to the segwit discount\r\n- Restoring the default provides a middle ground while respecting node operator choice\r\n\r\nTest changes add explicit -datacarriersize=100000 to tests that require large OP_RETURN outputs for transaction padding.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34214"
    },
    {
      "number": 34213,
      "title": "net: do not read/dump anchors if network is not active",
      "user": "brunoerg",
      "state": "open",
      "created_at": "2026-01-06T21:26:09Z",
      "updated_at": "2026-01-14T22:11:14Z",
      "body": "We currently save 2 block-relay-only (anchor) connections when stopping a node and connect to them right after starting it. However, if you start a node with network disabled (setting -networkactive=0 or disabling using the RPC), it will read the anchors, obviously will not be able to connect to them and then, when stopping the node, considering it will have 0 block-relay-only connections, it will save 0 anchors, basically deleting the previous ones. With this PR, we will only read and write the anchors if the network is active. It will avoid losing the anchors when using the node without network activity and also avoid unecessary actions (like reading the anchors even knowing we have no network activity).",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34213"
    },
    {
      "number": 34212,
      "title": ".",
      "user": "BitcoinMechanic",
      "state": "closed",
      "created_at": "2026-01-06T19:26:08Z",
      "updated_at": "2026-01-06T19:26:31Z",
      "body": ".",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34212"
    },
    {
      "number": 34211,
      "title": "build: Alt restore cross-compilation for Android",
      "user": "D33r-Gee",
      "state": "open",
      "created_at": "2026-01-06T16:48:55Z",
      "updated_at": "2026-01-13T09:33:28Z",
      "body": "# build, qt, doc: Add Android GUI support and APK packaging\r\n\r\nThis PR restores cross-compilation for Android (previously removed in #30049 and proposed in #32262) and extends it to support the Bitcoin-Qt GUI and Android Application Package (APK) generation.\r\n\r\nUnlike #32262, which focused on restoring the base cross-compilation, this PR provides a complete path to a functional Android application. It achieves this by updating the `depends` system to handle Android-specific requirements (shared Qt libraries, JNI support), integrating `androiddeployqt` into the CMake build system, and providing a standard Android entry point.\r\n\r\n### Alternatives\r\nThis PR is offered as an alternative to #32262. It incorporates and builds upon the `depends` fixes introduced there while adding the necessary components for a full GUI application and automated APK packaging.\r\n\r\n### Key Changes (mostly from #32262)\r\n- **build**: Restored and updated Android cross-compilation support in the `depends` system. This includes handling Android ABIs and mapping them to Bitcoin Core's `HOST` triples.\r\n- **build**: Added APK generation support via a new `apk_package` CMake target. This target automates the generation of `deploy.json` and the execution of `androiddeployqt` to produce ready-to-install `.apk` files.\r\n- **qt**: Added Android-specific GUI configurations, including a Java entry point (`BitcoinQtActivity.java`), high-resolution icons, and a manifest template.\r\n- **doc**: Added `doc/build-android.md` with detailed instructions for setting up the Android SDK/NDK and building the GUI.\r\n- **util**: Added a deduction guide for `util::Overloaded` to ensure compatibility with modern Android C++ toolchains.\r\n- **depends**: Applied several patches to Qt to fix JNI static linking issues and duplicate symbols encountered during Android builds.\r\n\r\n### Testing\r\nThe changes have been tested on Ubuntu 22.04 targeting `x86_64-linux-android` (API level 34) with NDK r26b and Qt 6.7.3. The resulting APK has been verified to install and run correctly on an Android emulator (see screenshot at the bottom).\r\nAlso it has been tested on a real devices with Android 13 (API level 33) for both abis `arm64-v8a` (aarch64) and `armv7a`.\r\n\r\n**Build Example:**\r\n```bash\r\n# Set environment\r\nexport ANDROID_SDK_ROOT=/path/to/Android/Sdk\r\nexport ANDROID_NDK_ROOT=$ANDROID_SDK_ROOT/ndk/26.1.10909125\r\n\r\n# Build dependencies\r\ngmake -C depends HOST=x86_64-linux-android ANDROID_SDK=$ANDROID_SDK_ROOT ANDROID_NDK=$ANDROID_NDK_ROOT ANDROID_API_LEVEL=34 NO_IPC=1  -j$(nproc)\r\n\r\n# Configure and build APK\r\ncmake -G Ninja -B build --toolchain depends/x86_64-linux-android/toolchain.cmake \\\r\n      -DBUILD_GUI=ON -DANDROID_API_LEVEL=34  -j$(nproc)\r\ncmake --build build --target apk_package  -j$(nproc)\r\n```\r\n\r\n### Note for Reviewers\r\n- Android does not support the system-wide IPC mechanisms used by Bitcoin Core's multiprocess support, so `NO_IPC=1` is currently required.\r\n- CI integration for the Android build is not included in this PR and will be addressed in a follow-up task if deemed necessary.\r\n\r\n### Emulator Screenshot\r\n<details>\r\n  <summary>Click to expand</summary>\r\n  \r\n<img width=\"968\" height=\"2187\" alt=\"Screenshot 2026-01-06 082824\" src=\"https://github.com/user-attachments/assets/9d7b0130-b624-4817-adf4-f5825c8e4c9d\" />\r\n\r\n</details>\r\n\r\n",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34211"
    },
    {
      "number": 34210,
      "title": "bench: Remove -priority-level= option",
      "user": "maflcko",
      "state": "closed",
      "created_at": "2026-01-06T16:43:15Z",
      "updated_at": "2026-01-14T22:49:17Z",
      "body": "The option was added in https://github.com/bitcoin/bitcoin/pull/26158, when the project was using an autotools-based build system. However, in the meantime this option is unused:\r\n\r\n* First, commit 27f11217ca63e0f8f78f14db139150052dcd9962 removed the option from one CI task\r\n* Then https://github.com/bitcoin/bitcoin/pull/32310 removed the option from CMakeList.txt, because:\r\n \r\n  * they only run as a sanity check (fastest version)\r\n  * no one otherwise runs them, not even CI\r\n  * issues have been missed due to this\r\n\r\nFinally, after commit 0ad4376a49fae6f705128b326ba92317cb8e0639, I don't see a single reason to keep this option, so remove it.\r\n\r\nAlso, there is a commit to turn a silent ignore of duplicate bench names into an error.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34210"
    },
    {
      "number": 34209,
      "title": "[30.x]: Final backports & 30.2rc1",
      "user": "fanquake",
      "state": "closed",
      "created_at": "2026-01-06T16:18:12Z",
      "updated_at": "2026-01-08T20:32:29Z",
      "body": "Backports:\r\n* #34156\r\n* #34215",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34209"
    },
    {
      "number": 34208,
      "title": "bench: add fluent API for untimed `setup` steps in nanobench",
      "user": "l0rinc",
      "state": "open",
      "created_at": "2026-01-06T11:45:35Z",
      "updated_at": "2026-01-14T23:07:01Z",
      "body": "### Context\r\nAs described in https://github.com/martinus/nanobench/issues/130, we have a few benchmarks where we have to reset the state between runs, otherwise the repetitions will do something else than the first iteration.\r\n\r\n### Upstream\r\nI have opened a PR to `nanobench` to introduce an untimed setup phase, see: https://github.com/martinus/nanobench/pull/136\r\nUnfortunately the author has health issues and couldn't contribute to it in the past 2 years.\r\n\r\n### Tests\r\n\r\nTests were only added upstream, would be a bit awkward to wire in `nanobench.h` outside the benchmarking setup:\r\nhttps://github.com/martinus/nanobench/pull/136/changes/58350cfe5912d7e0533ccfcd759eea5d62eb55bb#diff-88160f647ce57661afe7d755fa70a5fa342a2b79d72d3511596878e69ed5cdc3\r\n\r\n### Fix\r\nI have moved the changes here as well and applied it to a few simple benchmarks as demonstration.\r\nWe can revert ones that are controversial and add other ones in follow-ups, this PR is mostly meant to add the `setup` feature.\r\n\r\n### Benchmarks\r\nMost benchmarks show a modest \"speedup\", others a \"slowdown\" - but it's only the effect of the setup that's not measured anymore - and a `run` phase which does the same operation in each epoch iteration (wallet benchmark changes were reverted since for simplicity):\r\n<img width=\"1496\" height=\"882\" alt=\"image\" src=\"https://github.com/user-attachments/assets/34c14565-f3df-41e5-9a86-95b2ca21703a\" />\r\n",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34208"
    },
    {
      "number": 34207,
      "title": "coins/refactor: enforce `GetCoin()` returns only unspent coins",
      "user": "l0rinc",
      "state": "open",
      "created_at": "2026-01-06T11:24:58Z",
      "updated_at": "2026-01-11T20:34:41Z",
      "body": "### Summary \r\n`::GetCoin()` is an interface for querying the UTXO set, so production implementations should only ever return unspent coins. Tests should mimic this to provide useful feedback.\r\n\r\n### Context\r\nThis PR is split out from #33018 to keep that PR focused on removing the `FRESH-but-not-DIRTY` cache state.\r\n\r\n### Changes:\r\n* Add a fail-fast assertion that `CCoinsViewDB::GetCoin()` never returns a spent coin.\r\n* Align unit tests and fuzz simulations with the production `GetCoin()` contract by never returning spent coins.\r\n* Replace the unreachable “spent coin returned by parent” handling in `CCoinsViewCache::FetchCoin()` with `Assert(!coin.IsSpent())`, drop outdated `spent+FRESH` docs, and tighten `SanityCheck()` invariants.\r\n\r\nBehavior is unchanged, it just aligns our tests to exercise valid states.",
      "comments": 0,
      "url": "https://github.com/bitcoin/bitcoin/pull/34207"
    }
  ],
  "issues": [
    {
      "number": 34206,
      "title": "wallet: Assertion `!wtx.truc_child_in_mempool.has_value()' failed",
      "user": "dergoegge",
      "state": "open",
      "created_at": "2026-01-06T11:02:14Z",
      "updated_at": "2026-01-09T13:45:08Z",
      "body": "The following `Assume` in the wallet will fail (triggered through rpc) under certain reorg conditions:\nhttps://github.com/bitcoin/bitcoin/blob/114901c0655d1dea3024a1daa362716c948bbde3/src/wallet/spend.cpp#L413\n\n\n<details>\n\n<summary>Vibe coded functional test patch to demonstrate (`-DABORT_ON_FAILED_ASSUME` is required):</summary>\n\n\n```patch\nFrom 54aea28e6439be5645267f0344a6337d9798ba14 Mon Sep 17 00:00:00 2001\nFrom: dergoegge <n.goeggi@gmail.com>\nDate: Tue, 6 Jan 2026 10:49:02 +0000\nSubject: [PATCH] truc wallet reorg bug\n\n---\n test/functional/mempool_truc.py | 163 +++++++++++++++++++++++++-------\n 1 file changed, 127 insertions(+), 36 deletions(-)\n\ndiff --git a/test/functional/mempool_truc.py b/test/functional/mempool_truc.py\nindex 2586308e4d..a155d57b68 100755\n--- a/test/functional/mempool_truc.py\n+++ b/test/functional/mempool_truc.py\n@@ -47,6 +47,36 @@ class MempoolTRUC(BitcoinTestFramework):\n         self.extra_args = [[]]\n         self.setup_clean_chain = True\n\n+    def skip_test_if_missing_module(self):\n+        self.skip_if_no_wallet()\n+\n+    def create_tx(self, wallet, inputs, outputs, version, prevtxs=None):\n+        \"\"\"Create a signed transaction using the real wallet.\n+\n+        Args:\n+            wallet: The wallet RPC to use\n+            inputs: List of inputs (empty to let fundrawtransaction pick)\n+            outputs: Dict of address -> amount\n+            version: Transaction version\n+            prevtxs: Optional list of previous transaction info for signing\n+                     unbroadcast transactions. Each entry should have:\n+                     {\"txid\": ..., \"vout\": ..., \"scriptPubKey\": ..., \"amount\": ...}\n+        \"\"\"\n+        raw_tx = wallet.createrawtransaction(inputs=inputs, outputs=outputs, version=version)\n+        if inputs == []:\n+            raw_tx = wallet.fundrawtransaction(raw_tx, {'include_unsafe': True})[\"hex\"]\n+        if prevtxs:\n+            signed_tx = wallet.signrawtransactionwithwallet(raw_tx, prevtxs)\n+        else:\n+            signed_tx = wallet.signrawtransactionwithwallet(raw_tx)\n+        return signed_tx[\"hex\"]\n+\n+    def send_tx(self, wallet, inputs, outputs, version, prevtxs=None):\n+        \"\"\"Create and broadcast a transaction using the real wallet.\"\"\"\n+        tx_hex = self.create_tx(wallet, inputs, outputs, version, prevtxs)\n+        txid = wallet.sendrawtransaction(tx_hex)\n+        return txid\n+\n     def check_mempool(self, txids):\n         \"\"\"Assert exact contents of the node's mempool (by txid).\"\"\"\n         mempool_contents = self.nodes[0].getrawmempool()\n@@ -173,41 +203,102 @@ class MempoolTRUC(BitcoinTestFramework):\n     @cleanup()\n     def test_truc_reorg(self):\n         node = self.nodes[0]\n+        self.log.info(\"Test TRUC transactions survive reorg correctly\")\n+\n+        # Create a wallet for this test\n+        node.createwallet(\"truc_reorg_wallet\")\n+        wallet = node.get_wallet_rpc(\"truc_reorg_wallet\")\n+\n+        # Fund the wallet\n+        funding_addr = wallet.getnewaddress()\n+        self.generatetoaddress(node, 1, funding_addr)\n+        self.generate(node, 100)  # Mature the coinbase\n\n         # Prep for fork\n         fork_blocks = create_empty_fork(node)\n-        self.log.info(\"Test that, during a reorg, TRUC rules are not enforced\")\n         self.check_mempool([])\n\n-        # Testing 2<-3 versions allowed\n-        tx_v2_block = self.wallet.create_self_transfer(version=2)\n+        # tx_chain_1: v2 transaction with 2 outputs\n+        addr1 = wallet.getnewaddress()\n+        addr2 = wallet.getnewaddress()\n+        tx_chain_1_hex = self.create_tx(wallet, [], {addr1: 10, addr2: 10}, version=2)\n+        tx_chain_1_decoded = node.decoderawtransaction(tx_chain_1_hex)\n+        tx_chain_1_txid = tx_chain_1_decoded[\"txid\"]\n+\n+        # Find which vout corresponds to which address and get scriptPubKey info\n+        vout_for_addr1 = None\n+        vout_for_addr2 = None\n+        scriptpubkey_addr1 = None\n+        scriptpubkey_addr2 = None\n+        for vout in tx_chain_1_decoded[\"vout\"]:\n+            if vout[\"scriptPubKey\"].get(\"address\") == addr1:\n+                vout_for_addr1 = vout[\"n\"]\n+                scriptpubkey_addr1 = vout[\"scriptPubKey\"][\"hex\"]\n+            elif vout[\"scriptPubKey\"].get(\"address\") == addr2:\n+                vout_for_addr2 = vout[\"n\"]\n+                scriptpubkey_addr2 = vout[\"scriptPubKey\"][\"hex\"]\n+\n+        # tx_chain_2: v3 transaction spending first output of tx_chain_1\n+        addr3 = wallet.getnewaddress()\n+        prevtxs_chain_2 = [{\n+            \"txid\": tx_chain_1_txid,\n+            \"vout\": vout_for_addr1,\n+            \"scriptPubKey\": scriptpubkey_addr1,\n+            \"amount\": Decimal(\"10\")\n+        }]\n+        tx_chain_2_hex = self.create_tx(\n+            wallet,\n+            [{\"txid\": tx_chain_1_txid, \"vout\": vout_for_addr1}],\n+            {addr3: Decimal(\"9.99999\")},\n+            version=3,\n+            prevtxs=prevtxs_chain_2\n+        )\n+        tx_chain_2_decoded = node.decoderawtransaction(tx_chain_2_hex)\n+        tx_chain_2_txid = tx_chain_2_decoded[\"txid\"]\n+\n+        # Get scriptPubKey for tx_chain_2 output\n+        scriptpubkey_addr3 = tx_chain_2_decoded[\"vout\"][0][\"scriptPubKey\"][\"hex\"]\n+\n+        # tx_chain_3: v3 transaction spending output of tx_chain_2\n+        addr4 = wallet.getnewaddress()\n+        prevtxs_chain_3 = [{\n+            \"txid\": tx_chain_2_txid,\n+            \"vout\": 0,\n+            \"scriptPubKey\": scriptpubkey_addr3,\n+            \"amount\": Decimal(\"9.99999\")\n+        }]\n+        tx_chain_3_hex = self.create_tx(\n+            wallet,\n+            [{\"txid\": tx_chain_2_txid, \"vout\": 0}],\n+            {addr4: Decimal(\"9.99998\")},\n+            version=3,\n+            prevtxs=prevtxs_chain_3\n+        )\n+        tx_chain_3_decoded = node.decoderawtransaction(tx_chain_3_hex)\n+        tx_chain_3_txid = tx_chain_3_decoded[\"txid\"]\n\n-        # Testing 3<-2 versions allowed\n-        tx_v3_block = self.wallet.create_self_transfer(version=3)\n+        tx_to_mine = [tx_chain_1_hex, tx_chain_2_hex, tx_chain_3_hex]\n+        self.generateblock(node, output=\"raw(42)\", transactions=tx_to_mine)\n\n-        # Testing overly-large child size\n-        tx_v3_block2 = self.wallet.create_self_transfer(version=3)\n+        self.check_mempool([])\n\n-        # Also create a linear chain of 3 TRUC transactions that will be directly mined, followed by one v2 in-mempool after block is made\n-        tx_chain_1 = self.wallet.create_self_transfer(version=3)\n-        tx_chain_2 = self.wallet.create_self_transfer(utxo_to_spend=tx_chain_1[\"new_utxo\"], version=3)\n-        tx_chain_3 = self.wallet.create_self_transfer(utxo_to_spend=tx_chain_2[\"new_utxo\"], version=3)\n+        self.trigger_reorg(fork_blocks)\n\n-        tx_to_mine = [tx_v3_block[\"hex\"], tx_v2_block[\"hex\"], tx_v3_block2[\"hex\"], tx_chain_1[\"hex\"], tx_chain_2[\"hex\"], tx_chain_3[\"hex\"]]\n-        self.generateblock(node, output=\"raw(42)\", transactions=tx_to_mine)\n+        self.check_mempool([tx_chain_1_txid, tx_chain_2_txid, tx_chain_3_txid])\n\n-        self.check_mempool([])\n+        # tx_chain_4: v2 transaction funded by the wallet (spending unconfirmed outputs from tx_chain_1)\n+        addr5 = wallet.getnewaddress()\n+        self.log.info(\"Creating tx_chain_4 spending from unconfirmed tx_chain_1\")\n+        tx_chain_4_txid = self.send_tx(\n+            wallet,\n+            [],  # Let fundrawtransaction pick inputs\n+            {addr5: Decimal(\"9.99\")},\n+            version=2\n+        )\n\n-        tx_v2_from_v3 = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=tx_v3_block[\"new_utxo\"], version=2)\n-        tx_v3_from_v2 = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=tx_v2_block[\"new_utxo\"], version=3)\n-        tx_v3_child_large = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=tx_v3_block2[\"new_utxo\"], target_vsize=1250, version=3)\n-        assert_greater_than(node.getmempoolentry(tx_v3_child_large[\"txid\"])[\"vsize\"], TRUC_CHILD_MAX_VSIZE)\n-        tx_chain_4 = self.wallet.send_self_transfer(from_node=node, utxo_to_spend=tx_chain_3[\"new_utxo\"], version=2)\n-        self.check_mempool([tx_v2_from_v3[\"txid\"], tx_v3_from_v2[\"txid\"], tx_v3_child_large[\"txid\"], tx_chain_4[\"txid\"]])\n+        self.check_mempool([tx_chain_1_txid, tx_chain_2_txid, tx_chain_3_txid, tx_chain_4_txid])\n\n-        # Reorg should have all block transactions re-accepted, ignoring TRUC enforcement\n-        self.trigger_reorg(fork_blocks)\n-        self.check_mempool([tx_v3_block[\"txid\"], tx_v2_block[\"txid\"], tx_v3_block2[\"txid\"], tx_v2_from_v3[\"txid\"], tx_v3_from_v2[\"txid\"], tx_v3_child_large[\"txid\"], tx_chain_1[\"txid\"], tx_chain_2[\"txid\"], tx_chain_3[\"txid\"], tx_chain_4[\"txid\"]])\n+        wallet.unloadwallet()\n\n     @cleanup(extra_args=[\"-limitclustercount=1\"])\n     def test_nondefault_package_limits(self):\n@@ -658,20 +749,20 @@ class MempoolTRUC(BitcoinTestFramework):\n         node = self.nodes[0]\n         self.wallet = MiniWallet(node)\n         self.generate(self.wallet, 200)\n-        self.test_truc_max_vsize()\n-        self.test_truc_acceptance()\n-        self.test_truc_replacement()\n+        #self.test_truc_max_vsize()\n+        #self.test_truc_acceptance()\n+        #self.test_truc_replacement()\n         self.test_truc_reorg()\n-        self.test_nondefault_package_limits()\n-        self.test_truc_ancestors_package()\n-        self.test_truc_ancestors_package_and_mempool()\n-        self.test_sibling_eviction_package()\n-        self.test_truc_package_inheritance()\n-        self.test_truc_in_testmempoolaccept()\n-        self.test_reorg_2child_rbf()\n-        self.test_truc_sibling_eviction()\n-        self.test_reorg_sibling_eviction_1p2c()\n-        self.test_minrelay_in_package_combos()\n+        #self.test_nondefault_package_limits()\n+        #self.test_truc_ancestors_package()\n+        #self.test_truc_ancestors_package_and_mempool()\n+        #self.test_sibling_eviction_package()\n+        #self.test_truc_package_inheritance()\n+        #self.test_truc_in_testmempoolaccept()\n+        #self.test_reorg_2child_rbf()\n+        #self.test_truc_sibling_eviction()\n+        #self.test_reorg_sibling_eviction_1p2c()\n+        #self.test_minrelay_in_package_combos()\n\n\n if __name__ == \"__main__\":\n--\n2.50.1\n```\n\n</details>\n\nAssertion was added in #32896\n\n*This was found with a test running on [Antithesis](https://antithesis.com/).*",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/issues/34206"
    },
    {
      "number": 34205,
      "title": "Intermittent issue in feature_bip68_sequence.py: in test_sequence_lock_confirmed_inputs                                        num_inputs = random.randint(1, min(10, available_utxos)): ValueError: empty range in randint(1, 0)",
      "user": "maflcko",
      "state": "closed",
      "created_at": "2026-01-06T08:28:42Z",
      "updated_at": "2026-01-13T23:30:07Z",
      "body": "https://github.com/bitcoin/bitcoin/actions/runs/20722345957/job/59492260670?pr=34188#step:14:34425:\n\n```\n...\n node0 2026-01-05T18:28:42.795754Z [httpworker.1] [D:\\a\\bitcoin\\bitcoin\\src\\rpc\\request.cpp:243] [parse] [rpc] ThreadRPCServer method=getblockchaininfo user=__cookie__ \n node0 2026-01-05T18:28:42.796627Z [http] [D:\\a\\bitcoin\\bitcoin\\src\\httpserver.cpp:307] [http_request_cb] [http] Received a POST request for / from 127.0.0.1:59122 \n node0 2026-01-05T18:28:42.796705Z [httpworker.0] [D:\\a\\bitcoin\\bitcoin\\src\\rpc\\request.cpp:243] [parse] [rpc] ThreadRPCServer method=getrawtransaction user=__cookie__ \n node0 2026-01-05T18:28:42.797538Z [http] [D:\\a\\bitcoin\\bitcoin\\src\\httpserver.cpp:307] [http_request_cb] [http] Received a POST request for / from 127.0.0.1:59122 \n node0 2026-01-05T18:28:42.797608Z [httpworker.1] [D:\\a\\bitcoin\\bitcoin\\src\\rpc\\request.cpp:243] [parse] [rpc] ThreadRPCServer method=getblockchaininfo user=__cookie__ \n node0 2026-01-05T18:28:42.798538Z [http] [D:\\a\\bitcoin\\bitcoin\\src\\httpserver.cpp:307] [http_request_cb] [http] Received a POST request for / from 127.0.0.1:59122 \n node0 2026-01-05T18:28:42.798612Z [httpworker.1] [D:\\a\\bitcoin\\bitcoin\\src\\rpc\\request.cpp:243] [parse] [rpc] ThreadRPCServer method=getblockchaininfo user=__cookie__ \n test  2026-01-05T18:28:42.799132Z TestFramework (ERROR): Unexpected exception \n                                   Traceback (most recent call last):\n                                     File \"D:\\a\\bitcoin\\bitcoin\\build\\test\\functional\\test_framework\\test_framework.py\", line 142, in main\n                                       self.run_test()\n                                       ~~~~~~~~~~~~~^^\n                                     File \"D:\\a\\bitcoin\\bitcoin\\build\\test\\functional\\feature_bip68_sequence.py\", line 66, in run_test\n                                       self.test_sequence_lock_confirmed_inputs()\n                                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^\n                                     File \"D:\\a\\bitcoin\\bitcoin\\build\\test\\functional\\feature_bip68_sequence.py\", line 149, in test_sequence_lock_confirmed_inputs\n                                       num_inputs = random.randint(1, min(10, available_utxos))\n                                     File \"C:\\hostedtoolcache\\windows\\Python\\3.14.2\\x64\\Lib\\random.py\", line 341, in randint\n                                       raise ValueError(f\"empty range in randint({a}, {b})\")\n                                   ValueError: empty range in randint(1, 0)",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/issues/34205"
    }
  ],
  "summary": {
    "pull_requests": 8,
    "issues": 2
  }
}