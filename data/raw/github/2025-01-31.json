{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T19:13:41.729430+00:00",
  "date": "2025-01-31",
  "pull_requests": [
    {
      "number": 31774,
      "title": "crypto: Use secure_allocator for `AES256_ctx`",
      "body": "Fixes #31744 \r\n\r\nReuse `secure_allocator` for `AES256_ctx` in the aes 256 encrypters and decrypters and the `iv` of `AES256CBC` encrypters and decrypters. These classes are relevant to `CCrypter`, used for encrypting wallets, and my understanding is that if an attacker knows some or all of the contents of these data structures (`AES256_ctx` & `iv`) they might be able to decrypt a user's wallet.\r\n\r\n Presently the `secure_allocator` tries to protect sensitive data with `mlock()` on POSIX systems and `VirtualLock()` on Windows to prevent memory being paged to disk, and by zero'ing out memory contents on deallocation with `memory_cleanse()` which is similar to `OPENSSL_cleanse()` by scaring compilers away from optimizing `memset` calls on non-Windows systems, and using `SecureZeroMemory()` on Windows.",
      "state": "open",
      "user": "davidgumberg",
      "created_at": "2025-01-31T20:10:56Z",
      "updated_at": "2026-01-14T21:01:36Z",
      "comments": 18,
      "url": "https://github.com/bitcoin/bitcoin/pull/31774",
      "labels": [
        "Utils/log/libs"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31774.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Stale ACK | [sipa](https://github.com/bitcoin/bitcoin/pull/31774#pullrequestreview-3412340683), [theStack](https://github.com/bitcoin/bitcoin/pull/31774#pullrequestreview-3416932085), [furszy](https://github.com/bitcoin/bitcoin/pull/31774#pullrequestreview-3443301033) |\n\nIf your review is incorrectly listed, please copy-paste <code>&lt;!--meta-tag:bot-skip--&gt;</code> into the comment that the bot should ignore.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#34004](https://github.com/bitcoin/bitcoin/pull/34004) (Implementation of SwiftSync by rustaceanrob)\n* [#28690](https://github.com/bitcoin/bitcoin/pull/28690) (build: Introduce internal kernel library by sedited)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n<!--5faf32d7da4f0f540f40219e4f7537a3-->",
          "created_at": "2025-01-31T20:10:59Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36501336640</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
          "created_at": "2025-01-31T21:32:45Z"
        },
        {
          "user": "theStack",
          "body": "Concept ACK on clearing out the ctx/iv members\r\n\r\nI'm wondering if a minimum-diff fix which simply replaces the `memset` calls in the dtors with `memory_cleanse` would be largely sufficient here? In https://github.com/bitcoin/bitcoin/pull/31166#issuecomment-2446055905 one argument for not needing secure allocators was the short-lived nature of the secrets. Looking at the only usage in the wallet, this would imho apply here too (en/decrypting might take a while for larger inputs, but I still wouldn't classify that as long-lived):\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/94ca99ac51dddbee79d6409ebcc43b1119b0aca9/src/wallet/crypter.cpp#L85-L91\r\nhttps://github.com/bitcoin/bitcoin/blob/94ca99ac51dddbee79d6409ebcc43b1119b0aca9/src/wallet/crypter.cpp#L102-L108\r\n\r\nThe reasoning might be a bit loose as there might be other uses of these classes in the future where the situation is different. Curious about other opinions.",
          "created_at": "2025-02-04T15:51:03Z"
        },
        {
          "user": "sipa",
          "body": "I think the approach here might have an unacceptable performance impact, as it is allocating and deallocating a secure area for every individual key being encrypted/decrypted.\r\n\r\nIt may be better to:\r\n* Somehow make the `AES256CBC` classes members of `CCrypter`, surviving an individual encryption/decryption (e.g. by adding a reset function that can get called for each encryption/decryption, resetting the CBC state, but letting the key material survive).\r\n* Follow @theStack's suggestion of not locking the memory, but just securely wiping it after each operation.",
          "created_at": "2025-02-04T16:35:20Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Debug: https://github.com/bitcoin/bitcoin/runs/36882999841</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n",
          "created_at": "2025-02-08T00:50:43Z"
        },
        {
          "user": "davidgumberg",
          "body": "> I'm wondering if a minimum-diff fix which simply replaces the `memset` calls in the dtors with `memory_cleanse` would be largely sufficient here? In [#31166 (comment)](https://github.com/bitcoin/bitcoin/pull/31166#issuecomment-2446055905) one argument for not needing secure allocators was the short-lived nature of the secrets. \r\n\r\nIt seems right to me that this structure is always short lived, but I also felt in #31166 `secure_allocator` should have been used over just `memory_cleanse()`. I feel that the alloc/dealloc strategy for secrets in memory should be reused and applied universally unless there is a good reason not to.\r\n\r\n----\r\n\r\n> I think the approach here might have an unacceptable performance impact, as it is allocating and deallocating a secure area for every individual key being encrypted/decrypted.\r\n\r\nI added a benchmark for `WalletEncrypt()` which I ran a few times and it appears that the performance impact is neglible on my machine (Ryzen 7900x, Fedora 40),  if the benchmark I wrote is actually representative:\r\n\r\n| wallet type | branch                                                                                         | EncryptWallet() (ns/key) | benchmark overhead (ns/key)  | normalized value (total - overhead) |                                                                         flamegraph |\r\n|-------------|------------------------------------------------------------------------------------------------|--------------------------|------------------------------|-------------------------------------|-----------------------------------------------------------------------------------:|\r\n| Descriptor  | https://github.com/bitcoin/bitcoin/pull/31774/commits/15d8500f99012422be495b8e85e4e25e6a4419d8 | 42,106.55                | 36,235.03                    | 5,871.53                            | [link](https://davidgumberg.github.io/fg/aes-secure-alloc/branch-descriptors.html) |\r\n| Descriptor  | master                                                                                         | 42,050.82                | 36,362.40                    | 5,688.42                            | [link](https://davidgumberg.github.io/fg/aes-secure-alloc/master-descriptors.html) |\r\n| Legacy      | https://github.com/bitcoin/bitcoin/pull/31774/commits/15d8500f99012422be495b8e85e4e25e6a4419d8 |  17,067.82               | 2,779.16                     | 14,288.6                            | [link](https://davidgumberg.github.io/fg/aes-secure-alloc/branch-legacy.html)      |\r\n| Legacy      | master                                                                                         | 16,812.63                | 2,757.26                     | 14,055.57                           | [link](https://davidgumberg.github.io/fg/aes-secure-alloc/master-legacy.html)      |\r\n\r\n---\r\n\r\n\r\nBut if the short-lived nature of the key material makes just using `memory_cleanse()` a good-enough solution over having to reason about whether the benchmark is sufficiently correct, and whether the larger / more complicated diff required to reuse `secure_allocator` is worth the review effort / risk, I'm happy to change it.\r\n\r\n",
          "created_at": "2025-02-08T01:49:49Z"
        },
        {
          "user": "laanwj",
          "body": "> I think the approach here might have an unacceptable performance impact, as it is allocating and deallocating a secure area for every individual key being encrypted/decrypted.\r\n\r\nThis may still be true, though FWIW the idea behind the `LockedPool` is that it reduces the amount of locking/unlocking operations by mapping and locking memory in blocks, not every time it's requested.\r\n\r\nBut agree that for short-lived key material, it's less important, there is little to no chance of it ending up in swap anyway.",
          "created_at": "2025-03-27T13:27:45Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `ARM, unit tests, no functional tests`: https://github.com/bitcoin/bitcoin/runs/41468173464</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is caused by an assertion failure in wallet creation during the bench_sanity_check test.</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-05-01T05:42:13Z"
        },
        {
          "user": "davidgumberg",
          "body": "Rebased to address merge conflict, dropped legacy wallet encryption benchmark, and reduced number of keys since the benchmark was taking an unreasonably long time.",
          "created_at": "2025-05-01T05:44:18Z"
        },
        {
          "user": "davidgumberg",
          "body": "Rebase to address style feedback. ",
          "created_at": "2025-05-02T01:17:23Z"
        },
        {
          "user": "davidgumberg",
          "body": "> I don't see why the first commit is necessary. Couldn't you just mock the time so that it's fixed and the number of derivation rounds always stays at the default value?\r\n\r\nMaybe I'm not thinking creatively enough, but I think because the timing takes place entirely inside of `EncryptWallet()->EncryptMasterKey`, from the `wallet_encrypt.cpp` benchmark, I could only mock the clock so that it's static during the derivation \"benchmark\"[^1] runs, so the difference between the end time and the start time of a run will be `0` which will result in dividing by `0`:\r\nhttps://github.com/bitcoin/bitcoin/blob/68ac9f116c0228a277f18f60ba2278b56356e6ac/src/wallet/wallet.cpp#L581-L589\r\n\r\n[^1]: The ones that [decide](https://github.com/bitcoin/bitcoin/blob/68ac9f116c0228a277f18f60ba2278b56356e6ac/src/wallet/wallet.cpp#L587-L597) how many derivations to perform based on hardware speed.",
          "created_at": "2025-05-05T23:36:11Z"
        },
        {
          "user": "furszy",
          "body": "> so the difference between the end time and the start time of a run will be 0 which will result in dividing by 0:\r\n\r\nYes, it seems simpler and more scoped to address that inside the encryption function (which could arguably be considered a 'fix', since we shouldnâ€™t be dividing by zero regardless of whether the clock time is messed up) than to add a test-only field to the wallet and another function arg just just for this.",
          "created_at": "2025-05-05T23:54:12Z"
        },
        {
          "user": "davidgumberg",
          "body": ">  since we shouldnâ€™t be dividing by zero regardless of whether the clock time is messed up\r\n\r\nAFAIK, `std::chrono::steady_clock`, unlike the system clock, cannot fail to move forward, and this will never happen.\r\n\r\n> than to add a test-only field to the wallet and another function arg just just for this.\r\n\r\nI agree that adding a test-only field and arg is very bad, and would like to avoid it, but it seems to me worse to imbue secret meaning into the benchmark by handling a time difference of 0 in this special way which appears on the surface to be error-handling, but is really a \"side-channel\" for test code to sneak an extra parameter into `EncryptWallet`, but I don't feel strongly enough about which of those is worse, so I'll implement your approach. \r\n",
          "created_at": "2025-05-06T00:11:05Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `lint`: https://github.com/bitcoin/bitcoin/runs/41695411207</sub>\n<sub>LLM reason (âœ¨ experimental): The CI failure is due to issues identified by `lint-includes.py` and the `all_python_linters` check.\n</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-05-06T04:03:17Z"
        },
        {
          "user": "davidgumberg",
          "body": "Refactored to address @furszy feedback to avoid adding a test-only parameter to `CWallet`, and added a somewhat opinionated refactor (https://github.com/bitcoin/bitcoin/pull/31774/commits/7176b26cde7cbaffdd92af9c25f85f8e5233e78a) of `CWallet::EncryptMasterKey()` since I was touching the iteration measuring stuff anyways.\r\n\r\nI don't like the idea of using a `for` loop that iterates once with `0` and once with `1`, but it's shorter, I believe it is easier to understand how the weighted average calculation is working, and this version generalizes to any number of measurement runs.",
          "created_at": "2025-05-06T04:26:42Z"
        },
        {
          "user": "glozow",
          "body": "IIRC we're waiting on @davidgumberg to address the comments from @achow101 's reviews https://github.com/bitcoin/bitcoin/pull/31774#discussion_r2511273130 here?",
          "created_at": "2025-12-09T15:53:45Z"
        },
        {
          "user": "DrahtBot",
          "body": "<!--85328a0da195eb286784d51f73fa0af9-->\nðŸš§ At least one of the CI tasks failed.\n<sub>Task `Windows-cross to x86_64, msvcrt`: https://github.com/bitcoin/bitcoin/actions/runs/20080403030/job/57605821707</sub>\n<sub>LLM reason (âœ¨ experimental): Linker failure from multiple definitions in lockedpool.cpp (duplicate symbols across modules).</sub>\n\n<details><summary>Hints</summary>\n\nTry to run the tests locally, according to the documentation. However, a CI failure may still\nhappen due to a number of reasons, for example:\n\n* Possibly due to a silent merge conflict (the changes in this pull request being\nincompatible with the current code in the target branch). If so, make sure to rebase on the latest\ncommit of the target branch.\n\n* A sanitizer issue, which can only be found by compiling with the sanitizer and running the\n  affected test.\n\n* An intermittent issue.\n\nLeave a comment here, if you need help tracking down a confusing failure.\n\n</details>\n\n",
          "created_at": "2025-12-09T22:36:10Z"
        },
        {
          "user": "davidgumberg",
          "body": "```\r\ngit range-diff 68ac9f1..8bdcd12 9890058..e54690a\r\n```\r\n\r\nRebased against master to fix a silent merge conflict with `lockedpool.cpp` being moved from util -> kernel in aed38ea, and addressed @achow101's comment about the previous benchmark only measuring encryption of a single key, I've updated the benchmarks to test encryption of 2000 keys, the performance impact is still negligible:\r\n\r\n| branch |  EncryptWallet (total - overhead) | total ns/key | overhead ns/key\r\n|-------:|----------------------------------:|-------------:|:---------------\r\n| master + benchmarks (8abee2b) | 192,652.62 ns | 293,553.20 ns | 104,682.68 ns\r\n| branch (e54690a)                | 192,772.32 ns | 294,794.46 ns | 104,329.09 ns\r\n\r\n<details>\r\n\r\n<summary>\r\n\r\n### Benchmark details\r\n\r\n</summary>\r\nTo set up, I cleaned my build dir and used pyperf.\r\n```bash\r\nrm -rf ./build \r\npip install pyperf && sudo pyperf system tune\r\n```\r\n\r\n#### Master + benchmarks (8abee2b)\r\n```bash\r\ngit checkout 8abee2b\r\ncmake -B build -DBUILD_BENCH=ON && cmake --build build -j $(nproc)\r\n./build/bin/bench_bitcoin --filter=\"WalletEncrypt.*\" -min-time=12000\r\n```\r\n\r\n|              ns/key |               key/s |    err% |         ins/key |         cyc/key |    IPC |        bra/key |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|          293,553.20 |            3,406.54 |    0.1% |    6,848,134.51 |    1,258,326.47 |  5.442 |     151,429.70 |    0.9% |     12.91 | `WalletEncryptDescriptors`\r\n|          104,682.68 |            9,552.68 |    0.1% |    2,329,994.28 |      448,813.08 |  5.191 |      74,084.65 |    0.9% |     13.02 | `WalletEncryptDescriptorsBenchOverhead`\r\n\r\n\r\n-----\r\n\r\nBranch (e54690a)\r\n```bash\r\ngit checkout e54690a\r\ncmake -B build -DBUILD_BENCH=ON && cmake --build build -j $(nproc)\r\n./build/bin/bench_bitcoin --filter=\"WalletEncrypt.*\" -min-time=12000\r\n```\r\n\r\n|              ns/key |               key/s |    err% |         ins/key |         cyc/key |    IPC |        bra/key |   miss% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------------:|----------------:|-------:|---------------:|--------:|----------:|:----------\r\n|          294,794.46 |            3,392.19 |    0.3% |    6,855,246.26 |    1,264,321.32 |  5.422 |     153,125.52 |    0.9% |     12.97 | `WalletEncryptDescriptors`\r\n|          104,329.09 |            9,585.05 |    0.1% |    2,330,778.18 |      447,414.99 |  5.209 |      74,203.06 |    0.8% |     12.94 | `WalletEncryptDescriptorsBenchOverhead`\r\n\r\n</details>",
          "created_at": "2025-12-10T00:12:20Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 31772,
      "title": "test: 32-bit Clang `ipc_test` failure at `-O0`",
      "body": "Noticed as part of this branch #29796, however it can also be reproduced with master (8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf) by reproducing the equivalent CI & setting C(XX)FLAGS to -O0:\n```bash\nmake -C depends/ MULTIPROCESS=1 NO_QT=1 NO_WALLET=1 NO_ZMQ=1 NO_USDT=1 CFLAGS=\"-O0\" CXXFLAGS=\"-O0\" DEBUG=1 -j19 HOST=i686-pc-linux-gnu\ncmake -B build --toolchain /root/ci_scratch/depends/i686-pc-linux-gnu/toolchain.cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_COMPILER='clang;-m32' -DCMAKE_CXX_COMPILER='clang++;-m32'\ncmake --build build -j18\n```\n\n```bash\n./build/src/test/test_bitcoin --run_test=ipc*\nRunning 2 test cases...\nterminate called after throwing an instance of 'kj::ExceptionImpl'\n  what():  /root/ci_scratch/depends/i686-pc-linux-gnu/include/kj/common.h:1797: failed: expected start <= end && end <= size_; Out-of-bounds ArrayPtr::slice().\nstack: 5ca0dd6d 5c78b5db 5c8cc599 5ca0adc9 5c94fb37 5c950070 5c9cd709 5c9cf58a 5c9d72fd 5c9d025e 5c776f11 5bf6351d 5bf6347d 5bf633cd 5bf6337b 5bf6331d 5bf63194 f7afa4b0 f773dff6 f77d55b7\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\n    ??:0: returning here\nunknown location(0): fatal error: in \"ipc_tests/ipc_tests\": signal: SIGABRT (application abort requested)\ntest/ipc_tests.cpp(12): last checkpoint: \"ipc_tests\" test entry\ntest_bitcoin: common/args.cpp:578: void ArgsManager::AddArg(const std::string &, const std::string &, unsigned int, const OptionsCategory &): Assertion `ret.second' failed.\nunknown location(0): fatal error: in \"ipc_tests/parse_address_test\": signal: SIGABRT (application abort requested)\ntest/ipc_tests.cpp(20): last checkpoint: \"parse_address_test\" fixture ctor\n\n*** 2 failures are detected in the test module \"Bitcoin Core Test Suite\"\n```",
      "state": "closed",
      "user": "fanquake",
      "created_at": "2025-01-31T15:12:40Z",
      "updated_at": "2025-03-13T00:52:42Z",
      "comments": 19,
      "url": "https://github.com/bitcoin/bitcoin/issues/31772",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "fanquake",
          "body": "cc @ryanofsky ",
          "created_at": "2025-02-03T17:58:48Z"
        },
        {
          "user": "ryanofsky",
          "body": "I tried those steps except I left off the ` -DCMAKE_C_COMPILER='clang;-m32' -DCMAKE_CXX_COMPILER='clang++;-m32'` part and the test passed without a problem.\n\nIs the clang part important? It seems odd to use gcc for the depends build and clang for the bitcoin build, and when when I tried the adding the clang arguments specified, cmake complained about not being able to find libstdc++, which maybe makes sense because, I don't know if it is supposed to work with the gnu library.\n\nIf there are any easier steps to reproduce this maybe using docker, or just a CI run I can look at that would be helpful. I ran into countless problems just getting i686 default build to work at all on my machine, so it is hard to know what things may be particular to the configuration this is happening in.",
          "created_at": "2025-02-04T02:21:11Z"
        },
        {
          "user": "fanquake",
          "body": "> If there are any easier steps to reproduce this maybe using docker,\n\nRunning `time env -i HOME=\"$HOME\" PATH=\"$PATH\" USER=\"$USER\" bash -c 'FILE_ENV=\"./ci/test/00_setup_env_i686_multiprocess.sh\" ./ci/test_run_all.sh'` with the branch from #29796.\n\n> or just a CI run I can look at that would be helpful.\n\nhttps://github.com/bitcoin/bitcoin/pull/29796/checks?check_run_id=36485685971",
          "created_at": "2025-02-04T09:49:43Z"
        },
        {
          "user": "ryanofsky",
          "body": "Thanks was able to get a stack trace by running `cd /ci_container_base/ci/scratch/build-i686-pc-linux-gnu`, `gdb -ex run --args ./src/test/test_bitcoin -t ipc_tests`, and `bt` in container:\n\n```c++\n#0  0xf7f4b5b9 in __kernel_vsyscall ()\n#1  0xf79e6037 in ?? () from /lib32/libc.so.6\n#2  0xf7994c51 in raise () from /lib32/libc.so.6\n#3  0xf797c2b7 in abort () from /lib32/libc.so.6\n#4  0xf7d4bf71 in ?? () from /lib32/libstdc++.so.6\n#5  0xf7d65a97 in ?? () from /lib32/libstdc++.so.6\n#6  0xf7d4b8f9 in std::terminate() () from /lib32/libstdc++.so.6\n#7  0xf7d65ddc in __cxa_throw () from /lib32/libstdc++.so.6\n#8  0x597d7e12 in kj::ExceptionCallback::RootExceptionCallback::onFatalException (this=0x5c8344b0, exception=...) at /usr/src/kj/exception.c++:1107\n#9  0x597d6085 in kj::throwFatalException (exception=..., ignoreCount=1) at /usr/src/kj/exception.c++:1194\n#10 0x597d05e5 in kj::_::Debug::Fault::fatal (this=0xf75cbc28) at /usr/src/kj/debug.c++:371\n#11 0x597cf19a in kj::_::inlineRequireFailure (file=0x59e9a314 \"/ci_container_base/depends/i686-pc-linux-gnu/include/kj/common.h\", line=1797, expectation=0x59e9a2f7 \"start <= end && end <= size_\", \n    macroArgs=0x59e9a2d4 \"\\\"Out-of-bounds ArrayPtr::slice().\\\"\", message=0x59e9a2b0 \"Out-of-bounds ArrayPtr::slice().\") at /usr/src/kj/common.c++:36\n#12 0x5954afc8 in kj::ArrayPtr<char const>::slice (this=0xf75cbd54, start=1498659230, end=13) at /usr/src/kj/common.h:1797\n#13 0x5968bd88 in kj::StringPtr::slice (this=0xf75cbd54, start=1498659230) at /usr/src/kj/string.h:734\n#14 0x597cc1e4 in kj::CidrRange::CidrRange (this=0x5a9ddc80 <kj::_::reservedCidrs()::result>, pattern=...) at /usr/src/kj/cidr.c++:53\n#15 0x597105fe in kj::_::reservedCidrs () at /usr/src/kj/async-io.c++:3007\n#16 0x59710b37 in kj::_::NetworkFilter::NetworkFilter (this=0x5c838b70) at /usr/src/kj/async-io.c++:3038\n#17 0x5978e80c in kj::(anonymous namespace)::SocketNetwork::SocketNetwork (this=0x5c838b68, lowLevel=...) at /usr/src/kj/async-io-unix.c++:1742\n#18 0x5979068d in kj::(anonymous namespace)::AsyncIoProviderImpl::AsyncIoProviderImpl (this=0x5c838b60, lowLevel=...) at /usr/src/kj/async-io-unix.c++:1974\n#19 0x59798404 in kj::heap<kj::(anonymous namespace)::AsyncIoProviderImpl, kj::(anonymous namespace)::LowLevelAsyncIoProviderImpl&> () at /usr/src/kj/memory.h:609\n#20 0x59791361 in kj::setupAsyncIo () at /usr/src/kj/async-io-unix.c++:2058\n#21 0x595373c2 in mp::EventLoop::EventLoop(char const*, std::function<void (bool, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)>, void*) (this=0xf75cc110, \n    exe_name=0x59b257f6 \"IpcPipeTest\", log_fn=..., context=0x0) at /usr/src/mp/proxy.cpp:158\n#22 0x58a4064e in IpcPipeTest()::$_0::operator()() const (this=0x5c8542d4) at ./test/ipc_test.cpp:60\n#23 0x58a405ae in std::__invoke_impl<void, IpcPipeTest()::$_0>(std::__invoke_other, IpcPipeTest()::$_0&&) (__f=...) at /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h:61\n#24 0x58a404fe in std::__invoke<IpcPipeTest()::$_0>(IpcPipeTest()::$_0&&) (__fn=...) at /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/invoke.h:96\n#25 0x58a404ac in std::thread::_Invoker<std::tuple<IpcPipeTest()::$_0> >::_M_invoke<0u>(std::_Index_tuple<0u>) (this=0x5c8542d4)\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h:292\n#26 0x58a4044e in std::thread::_Invoker<std::tuple<IpcPipeTest()::$_0> >::operator()() (this=0x5c8542d4) at /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h:299\n#27 0x58a402c5 in std::thread::_State_impl<std::thread::_Invoker<std::tuple<IpcPipeTest()::$_0> > >::_M_run() (this=0x5c8542d0)\n    at /usr/bin/../lib/gcc/x86_64-linux-gnu/13/../../../../include/c++/13/bits/std_thread.h:244\n#28 0xf7d98d21 in ?? () from /lib32/libstdc++.so.6\n#29 0xf79e4157 in ?? () from /lib32/libc.so.6\n#30 0xf7a78e08 in ?? () from /lib32/libc.so.6\n```",
          "created_at": "2025-02-04T14:05:18Z"
        },
        {
          "user": "ryanofsky",
          "body": "Stack trace seems to be showing something going wrong in capnproto code, but unclear what the cause is. The crash is happening in the CidrRange::CidrRange constructor here:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/cidr.c%2B%2B#L53\n\nwhich is being called on a static list of address patterns:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/async-io.c%2B%2B#L2999-L3007\n\nAll of the patterns look valid so no reason there should be a parsing exception like seems to be happening. It seems like this might be a more strange compiler / build issue",
          "created_at": "2025-02-04T14:21:56Z"
        },
        {
          "user": "ryanofsky",
          "body": "gdb shows invalid results being returned from `pattern.findFirst('/')` call where pattern is `192.0.0.0/24`\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/cidr.c%2B%2B#L51C48-L51C57\n\n```\n#14 0x5971f1e4 in kj::CidrRange::CidrRange (this=0x5a930c80 <kj::_::reservedCidrs()::result>, pattern=...) at /usr/src/kj/cidr.c++:53\n(gdb) p pattern\n$6 = {content = {<kj::DisallowConstCopyIfNotConst<char const>> = {<No data fields>}, ptr = 0x59e13a45 \"192.0.0.0/24\", size_ = 13}}\n(gdb) p slashPos\n$7 = 1497950621\n(gdb) p pattern.findFirst('/')\n$8 = {ptr = {isSet = true, {value = 2155537998}}}\n```",
          "created_at": "2025-02-04T14:29:50Z"
        },
        {
          "user": "ryanofsky",
          "body": "I thought I tracked down the problem, and some change I made to the test caused it to pass, but rerunning the the fix in a new container, it no longer works, so I have to go back.\n\nHere were notes I was about to post about potential problem & fix. In any case I suspect problem would be avoided if we just consistently used gcc or clang for this build and didn't try to mix them.\n\n---\n\nTest failure seems to be caused by the container using incompatible ABI versions for the depends build and the main build. The depends build is using gcc with ABI version 18:\n\n```bash\ngcc -E -x c++ - -dM <<< \"\" | grep ABI\n#define __GXX_ABI_VERSION 1018\n```\n\nThe bitcoin build is using clang with ABI version 2:\n\n```bash\nclang++ -E -x c++ - -dM <<< \"\" | grep ABI\n#define __GXX_ABI_VERSION 1002\n```\n\nIn clang, the ABI version is determined when the compiler is built, but in gcc you can control it with the `-fabi-version` option, so the following change seems to fix the build:\n\n```diff\n--- a/depends/hosts/linux.mk\n+++ b/depends/hosts/linux.mk\n@@ -1,5 +1,5 @@\n linux_CFLAGS=-pipe -std=$(C_STANDARD)\n-linux_CXXFLAGS=-pipe -std=$(CXX_STANDARD)\n+linux_CXXFLAGS=-pipe -std=$(CXX_STANDARD) -fabi-version=2\n \n ifneq ($(LTO),)\n linux_AR = $(host_toolchain)gcc-ar\n--- a/depends/packages/libmultiprocess.mk\n+++ b/depends/packages/libmultiprocess.mk\n@@ -27,3 +27,5 @@ endef\n define $(package)_stage_cmds\n   $(MAKE) DESTDIR=$($(package)_staging_dir) install-lib\n endef\n+\n+$(package)_cxxflags += -fabi-version=11\n\n```\n\nFirst part of the diff setting ` -fabi-version=2` in the depends build is the main fix. The second part of the diff setting ` -fabi-version=11` is a workaround for an issue that happened specifically with the multiprocess package. Because when `-fabi-version` is set to 10 or below there is a compile error:\n\n\n<details><summary>error: no matching function for call to â€˜std::__uniq_ptr_data</summary>\n<p>\n\n```c++\n[ 20%] Building CXX object CMakeFiles/mputil.dir/src/mp/util.cpp.o\nIn file included from /usr/include/c++/13/bits/shared_ptr_base.h:59,\n                 from /usr/include/c++/13/bits/shared_ptr.h:53,\n                 from /usr/include/c++/13/condition_variable:45,\n                 from /usr/include/c++/13/future:41,\n                 from /ci_container_base/depends/work/build/i686-pc-linux-gnu/libmultiprocess/07c917f7ca910d66abc6d3873162fc9061704074-722fc6d9234/include/mp/util.h:11,\n                 from /ci_container_base/depends/work/build/i686-pc-linux-gnu/libmultiprocess/07c917f7ca910d66abc6d3873162fc9061704074-722fc6d9234/src/mp/util.cpp:6:\n/usr/include/c++/13/bits/unique_ptr.h: In instantiation of â€˜constexpr std::unique_ptr<_Tp, _Dp>::unique_ptr() [with _Del = std::__future_base::_Result_base::_Deleter; <template-parameter-2-2> = void; _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter]â€™:\n/usr/include/c++/13/future:340:34:   required from here\n/usr/include/c++/13/bits/unique_ptr.h:305:11: error: no matching function for call to â€˜std::__uniq_ptr_data<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter, true, true>::__uniq_ptr_data()â€™\n  305 |         : _M_t()\n      |           ^~~~~~\n/usr/include/c++/13/bits/unique_ptr.h:241:40: note: candidate: â€˜template<class _Del> std::__uniq_ptr_data<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter, true, true>::__uniq_ptr_data(std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::pointer, _Del&&) [inherited from std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>]â€™\n  241 |       using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;\n      |                                        ^~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/unique_ptr.h:241:40: note:   template argument deduction/substitution failed:\n/usr/include/c++/13/bits/unique_ptr.h:305:11: note:   candidate expects 2 arguments, 0 provided\n  305 |         : _M_t()\n      |           ^~~~~~\n/usr/include/c++/13/bits/unique_ptr.h:241:40: note: candidate: â€˜std::__uniq_ptr_data<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter, true, true>::__uniq_ptr_data(std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>::pointer) [inherited from std::__uniq_ptr_impl<std::__future_base::_Result_base, std::__future_base::_Result_base::_Deleter>]â€™\n  241 |       using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;\n      |                                        ^~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/unique_ptr.h:241:40: note:   candidate expects 1 argument, 0 provided\n/usr/include/c++/13/bits/unique_ptr.h:242:7: note: candidate: â€˜std::__uniq_ptr_data<_Tp, _Dp, <anonymous>, <anonymous> >::__uniq_ptr_data(std::__uniq_ptr_data<_Tp, _Dp, <anonymous>, <anonymous> >&&) [with _Tp = std::__future_base::_Result_base; _Dp = std::__future_base::_Result_base::_Deleter; bool <anonymous> = true; bool <anonymous> = true]â€™\n  242 |       __uniq_ptr_data(__uniq_ptr_data&&) = default;\n      |       ^~~~~~~~~~~~~~~\n/usr/include/c++/13/bits/unique_ptr.h:242:7: note:   candidate expects 1 argument, 0 provided\nmake[4]: *** [CMakeFiles/mputil.dir/build.make:76: CMakeFiles/mputil.dir/src/mp/util.cpp.o] Error 1\n```\n\n</p>\n</details>",
          "created_at": "2025-02-04T19:48:19Z"
        },
        {
          "user": "maflcko",
          "body": "Interesting that this did not result in a compile or link failure instead.\n\nI switched to clang in commit fad0f21c3caba129106799fe6c14aff323ef99f2 to avoid OOM with g++, (which was before switching to 32-bit in commit fae0295a799499268caca9c385ac4d7061543980), but now that the CI machines have more memory, it should be fine if this CI task takes more memory and time.\n\nHappy to review a pull, if someone submits one.",
          "created_at": "2025-02-04T20:28:04Z"
        },
        {
          "user": "ryanofsky",
          "body": "Can confirm switching from clang to gcc does seem to fix this. `-Wno-error=documentation` also had to be dropped because gcc does not support it.\n\n```c++\n--- a/ci/test/00_setup_env_i686_multiprocess.sh\n+++ b/ci/test/00_setup_env_i686_multiprocess.sh\n@@ -10,15 +10,12 @@ export HOST=i686-pc-linux-gnu\n export CONTAINER_NAME=ci_i686_multiprocess\n export CI_IMAGE_NAME_TAG=\"docker.io/ubuntu:24.04\"\n export CI_IMAGE_PLATFORM=\"linux/amd64\"\n-export PACKAGES=\"llvm clang g++-multilib\"\n-export DEP_OPTS=\"DEBUG=1 MULTIPROCESS=1\"\n+export PACKAGES=\"g++-multilib\"\n+export DEP_OPTS=\"DEBUG=1 MULTIPROCESS=1 NO_QT=1\"\n export GOAL=\"install\"\n export TEST_RUNNER_EXTRA=\"--v2transport\"\n export BITCOIN_CONFIG=\"\\\n  -DCMAKE_BUILD_TYPE=Debug \\\n- -DCMAKE_C_COMPILER='clang;-m32' \\\n- -DCMAKE_CXX_COMPILER='clang++;-m32' \\\n- -DCMAKE_CXX_FLAGS='-Wno-error=documentation' \\\n  -DAPPEND_CPPFLAGS='-DBOOST_MULTI_INDEX_ENABLE_SAFE_MODE' \\\n \"\n export BITCOIND=bitcoin-node  # Used in functional tests\n```\n\n---\n\n> Interesting that this did not result in a compile or link failure instead.\n\nI was just seeing a lot of strange things here. Theoretically, I think it should be fine to use gcc and clang together. Some other things I noticed: when I ran gdb I could step into the [findFirst](https://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/common.h#L1882-L1920) methods and see it looking for the '/' character and `pos` pointing to the right place but then the return value was wrong (a very large number instead of the position of the character). Also in I couldn't even tell which findFirst overload I was in because line number did not seem to correspond to the source file.\n\nWhen I added the -fabi-version flags and rebuilt I saw the ipc tests run and passed, and the  -fabi-version fix worked twice in two different containers when I applied it manually, but did not seem to work when it was already applied at the beginning of the build. So I think something else I was doing in my rebuild steps, like reconfiguring cmake was causing the problem to go away. So I don't know. I want to debug more but I think I already spent way too much time on this.",
          "created_at": "2025-02-04T21:28:51Z"
        },
        {
          "user": "ryanofsky",
          "body": "I tried to repeat previous steps rebuilding depends and test_bitcoin in container to figure out what I was doing that caused the test to stop crashing, but it seems to crash reliably, so I can't work out what I other changes I might have made while trying -fabi-version flags in https://github.com/bitcoin/bitcoin/issues/31772#issuecomment-2634917217 that would have caused it not to crash.\n\nAdditionally, I went back to original build and debugged it with GDB, and could easily step through and see where the bug is happening when I run with:\n\n```bash\ngdb -ex 'b findFirst' -ex run --args ./src/test/test_bitcoin -t ipc_tests\n```\n\nEverything works well up until reaching the `ArrayPtr<const char>::findFirst` method:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/common.h#L1882-L1890\n\nThe method also seems to work fine until it reaches the `return pos - ptr;` line. Because the function returns a Maybe value, this calls Maybe constructor:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/common.h#L1389\n\nwhich has a NullableValue member and calls NullableValue constructor:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/common.h#L1158\n\nwhich calls a function called ctor:\n\nhttps://github.com/capnproto/capnproto/blob/b34ec28cceaf15b1082b74b50f03f770873c3636/c%2B%2B/src/kj/common.h#L1061\n\nand unfortunately that function seems to be completely broken and not do anything. The `ctor` function is supposed to construct a `T` value inside the `NullableValue<T>` object, but it fails to do that. In this case `T` is a `size_t` object so it is supposed to assign the `pos - ptr` size that was computed into the `Maybe<size_t>` object that is being returned. But it doesn't do this. So the `Maybe<size_t>` object is only half-initialized as `{isSet = true, {value = 1497966205}}`, where the value 1497966205 is just the preexisting value it held before it was constructed, and is much longer than the size of the string being searched, so the code later throws an exception when there is an attempt to slice the \"192.0.0.0/24\" string at that position.\n\nThis bug seems like it is is probably a compiler bug, but not one is necessarily going to happen reliably because if the unitialized memory location started of as 0 instead 1497966205, crash would not happen. So I'm not sure switching bitcoin compiler from clang to gcc really fixes the problem, or just makes it appear not to happen. And I\"m not sure what I was doing before that caused the problem to disappear as well. It seems like there might be just be a problem with this version of gcc and -O0 and this piece of code.\n\nNext steps might be to look at generated assembly and confirm compiler is really producing buggy code or try to reproduce a minimal test case. Another thing we could try to do is update to a new version of gcc. Version here seems to be `gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0`\n\nHere is disassembly of relevant functions:\n\n<details><summary>disassembly</summary>\n<p>\n\n```c++\n(gdb) disassemble /s\nDump of assembler code for function _ZNK2kj8ArrayPtrIKcE9findFirstERS1_:\n/usr/src/kj/common.h:\n1883    inline Maybe<size_t> ArrayPtr<const char>::findFirst(const char& c) const {\n   0x5977156c <+0>:     push   %ebp\n   0x5977156d <+1>:     mov    %esp,%ebp\n   0x5977156f <+3>:     push   %ebx\n   0x59771570 <+4>:     sub    $0x24,%esp\n   0x59771573 <+7>:     call   0x566e8da0 <__x86.get_pc_thunk.bx>\n   0x59771578 <+12>:    add    $0x121eff0,%ebx\n   0x5977157e <+18>:    mov    0x8(%ebp),%eax\n   0x59771581 <+21>:    mov    %eax,-0x1c(%ebp)\n   0x59771584 <+24>:    mov    0xc(%ebp),%eax\n   0x59771587 <+27>:    mov    %eax,-0x20(%ebp)\n   0x5977158a <+30>:    mov    0x10(%ebp),%eax\n   0x5977158d <+33>:    mov    %eax,-0x24(%ebp)\n=> 0x59771590 <+36>:    mov    %gs:0x14,%eax\n   0x59771596 <+42>:    mov    %eax,-0xc(%ebp)\n   0x59771599 <+45>:    xor    %eax,%eax\n\n1884      const char* pos = reinterpret_cast<const char*>(memchr(ptr, c, size_));\n   0x5977159b <+47>:    mov    -0x20(%ebp),%eax\n   0x5977159e <+50>:    mov    0x4(%eax),%ecx\n   0x597715a1 <+53>:    mov    -0x24(%ebp),%eax\n   0x597715a4 <+56>:    movzbl (%eax),%eax\n   0x597715a7 <+59>:    movsbl %al,%edx\n   0x597715aa <+62>:    mov    -0x20(%ebp),%eax\n   0x597715ad <+65>:    mov    (%eax),%eax\n   0x597715af <+67>:    sub    $0x4,%esp\n   0x597715b2 <+70>:    push   %ecx\n   0x597715b3 <+71>:    push   %edx\n   0x597715b4 <+72>:    push   %eax\n   0x597715b5 <+73>:    call   0x5664a880 <memchr@plt>\n   0x597715ba <+78>:    add    $0x10,%esp\n   0x597715bd <+81>:    mov    %eax,-0x10(%ebp)\n\n1885      if (pos == nullptr) {\n   0x597715c0 <+84>:    cmpl   $0x0,-0x10(%ebp)\n   0x597715c4 <+88>:    jne    0x597715d8 <_ZNK2kj8ArrayPtrIKcE9findFirstERS1_+108>\n\n1886        return nullptr;\n   0x597715c6 <+90>:    sub    $0x8,%esp\n   0x597715c9 <+93>:    push   $0x0\n   0x597715cb <+95>:    push   -0x1c(%ebp)\n   0x597715ce <+98>:    call   0x595224a6 <_ZN2kj5MaybeIjEC2EDn>\n   0x597715d3 <+103>:   add    $0x10,%esp\n   0x597715d6 <+106>:   jmp    0x597715f9 <_ZNK2kj8ArrayPtrIKcE9findFirstERS1_+141>\n\n1887      } else {\n1888        return pos - ptr;\n   0x597715d8 <+108>:   mov    -0x20(%ebp),%eax\n   0x597715db <+111>:   mov    (%eax),%eax\n   0x597715dd <+113>:   mov    -0x10(%ebp),%edx\n   0x597715e0 <+116>:   sub    %eax,%edx\n   0x597715e2 <+118>:   mov    %edx,%eax\n   0x597715e4 <+120>:   mov    %eax,-0x14(%ebp)\n   0x597715e7 <+123>:   sub    $0x8,%esp\n   0x597715ea <+126>:   lea    -0x14(%ebp),%eax\n   0x597715ed <+129>:   push   %eax\n   0x597715ee <+130>:   push   -0x1c(%ebp)\n   0x597715f1 <+133>:   call   0x595224d0 <_ZN2kj5MaybeIjEC2EOj>\n   0x597715f6 <+138>:   add    $0x10,%esp\n\n1889      }\n1890    }\n   0x597715f9 <+141>:   mov    -0xc(%ebp),%eax\n   0x597715fc <+144>:   sub    %gs:0x14,%eax\n   0x59771603 <+151>:   je     0x5977160a <_ZNK2kj8ArrayPtrIKcE9findFirstERS1_+158>\n   0x59771605 <+153>:   call   0x597cf290 <__stack_chk_fail_local>\n   0x5977160a <+158>:   mov    -0x1c(%ebp),%eax\n   0x5977160d <+161>:   mov    -0x4(%ebp),%ebx\n   0x59771610 <+164>:   leave\n   0x59771611 <+165>:   ret    $0x4\nEnd of assembler dump.\n(gdb) disassemble /s _ZN2kj5MaybeIjEC2EOj\nDump of assembler code for function _ZN2kj5MaybeIjEC2EOj:\n/usr/src/kj/common.h:\n1389      Maybe(T&& t): ptr(kj::mv(t)) {}\n   0x595224d0 <+0>:     push   %ebp\n   0x595224d1 <+1>:     mov    %esp,%ebp\n   0x595224d3 <+3>:     push   %esi\n   0x595224d4 <+4>:     push   %ebx\n   0x595224d5 <+5>:     call   0x566e8da0 <__x86.get_pc_thunk.bx>\n   0x595224da <+10>:    add    $0x146e08e,%ebx\n   0x595224e0 <+16>:    mov    0x8(%ebp),%esi\n   0x595224e3 <+19>:    sub    $0xc,%esp\n   0x595224e6 <+22>:    push   0xc(%ebp)\n   0x595224e9 <+25>:    call   0x59502e4c <_ZN2kj2mvIjEEOT_RS1_>\n   0x595224ee <+30>:    add    $0x10,%esp\n   0x595224f1 <+33>:    sub    $0x8,%esp\n   0x595224f4 <+36>:    push   %eax\n   0x595224f5 <+37>:    push   %esi\n   0x595224f6 <+38>:    call   0x5952b7d8 <_ZN2kj1_13NullableValueIjEC2EOj>\n   0x595224fb <+43>:    add    $0x10,%esp\n   0x595224fe <+46>:    nop\n   0x595224ff <+47>:    lea    -0x8(%ebp),%esp\n   0x59522502 <+50>:    pop    %ebx\n   0x59522503 <+51>:    pop    %esi\n   0x59522504 <+52>:    pop    %ebp\n   0x59522505 <+53>:    ret\nEnd of assembler dump.\n(gdb) disassemble /s _ZN2kj1_13NullableValueIjEC2EOj\nDump of assembler code for function _ZN2kj1_13NullableValueIjEC2EOj:\n/usr/src/kj/common.h:\n1156      inline NullableValue(T&& t)\n   0x5952b7d8 <+0>:     push   %ebp\n   0x5952b7d9 <+1>:     mov    %esp,%ebp\n   0x5952b7db <+3>:     push   %ebx\n   0x5952b7dc <+4>:     sub    $0x4,%esp\n   0x5952b7df <+7>:     call   0x566e8da0 <__x86.get_pc_thunk.bx>\n   0x5952b7e4 <+12>:    add    $0x1464d84,%ebx\n\n1157          : isSet(true) {\n   0x5952b7ea <+18>:    mov    0x8(%ebp),%eax\n   0x5952b7ed <+21>:    movb   $0x1,(%eax)\n\n1158        ctor(value, kj::mv(t));\n   0x5952b7f0 <+24>:    sub    $0xc,%esp\n   0x5952b7f3 <+27>:    push   0xc(%ebp)\n   0x5952b7f6 <+30>:    call   0x59502e4c <_ZN2kj2mvIjEEOT_RS1_>\n   0x5952b7fb <+35>:    add    $0x10,%esp\n   0x5952b7fe <+38>:    mov    0x8(%ebp),%edx\n   0x5952b801 <+41>:    add    $0x4,%edx\n   0x5952b804 <+44>:    sub    $0x8,%esp\n   0x5952b807 <+47>:    push   %eax\n   0x5952b808 <+48>:    push   %edx\n   0x5952b809 <+49>:    call   0x595314f8 <_ZN2kj4ctorIjIjEEEvRT_DpOT0_>\n   0x5952b80e <+54>:    add    $0x10,%esp\n\n1159      }\n   0x5952b811 <+57>:    nop\n   0x5952b812 <+58>:    mov    -0x4(%ebp),%ebx\n   0x5952b815 <+61>:    leave\n   0x5952b816 <+62>:    ret\nEnd of assembler dump.\n(gdb) disassemble /s _ZN2kj4ctorIjIjEEEvRT_DpOT0_\n\nDump of assembler code for function _ZN2kj4ctorIjIjEEEvRT_DpOT0_:\n/usr/src/kj/common.h:\n1060    inline void ctor(T& location, Params&&... params) {\n   0x595314f8 <+0>:     push   %ebp\n   0x595314f9 <+1>:     mov    %esp,%ebp\n   0x595314fb <+3>:     push   %esi\n   0x595314fc <+4>:     push   %ebx\n   0x595314fd <+5>:     call   0x566e8da0 <__x86.get_pc_thunk.bx>\n   0x59531502 <+10>:    add    $0x145f066,%ebx\n\n1061      new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n   0x59531508 <+16>:    sub    $0x4,%esp\n   0x5953150b <+19>:    push   0x8(%ebp)\n   0x5953150e <+22>:    push   %eax\n   0x5953150f <+23>:    push   $0x4\n   0x59531511 <+25>:    call   0x58a0ec00 <_ZnwjN2kj1_12PlacementNewEPv>\n   0x59531516 <+30>:    add    $0x10,%esp\n   0x59531519 <+33>:    mov    %eax,%esi\n   0x5953151b <+35>:    test   %esi,%esi\n   0x5953151d <+37>:    je     0x59531531 <_ZN2kj4ctorIjIjEEEvRT_DpOT0_+57>\n   0x5953151f <+39>:    sub    $0xc,%esp\n   0x59531522 <+42>:    push   0xc(%ebp)\n   0x59531525 <+45>:    call   0x59502e70 <_ZN2kj3fwdIjEEOT_RNS_8NoInfer_IS1_E4TypeE>\n   0x5953152a <+50>:    add    $0x10,%esp\n   0x5953152d <+53>:    mov    (%eax),%eax\n   0x5953152f <+55>:    mov    %eax,(%esi)\n\n1062    }\n   0x59531531 <+57>:    nop\n   0x59531532 <+58>:    lea    -0x8(%ebp),%esp\n   0x59531535 <+61>:    pop    %ebx\n   0x59531536 <+62>:    pop    %esi\n   0x59531537 <+63>:    pop    %ebp\n   0x59531538 <+64>:    ret\nEnd of assembler dump.\n(gdb) \nDump of assembler code for function _ZN2kj4ctorIjIjEEEvRT_DpOT0_:\n/usr/src/kj/common.h:\n1060    inline void ctor(T& location, Params&&... params) {\n   0x595314f8 <+0>:     push   %ebp\n   0x595314f9 <+1>:     mov    %esp,%ebp\n   0x595314fb <+3>:     push   %esi\n   0x595314fc <+4>:     push   %ebx\n   0x595314fd <+5>:     call   0x566e8da0 <__x86.get_pc_thunk.bx>\n   0x59531502 <+10>:    add    $0x145f066,%ebx\n\n1061      new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n   0x59531508 <+16>:    sub    $0x4,%esp\n   0x5953150b <+19>:    push   0x8(%ebp)\n   0x5953150e <+22>:    push   %eax\n   0x5953150f <+23>:    push   $0x4\n   0x59531511 <+25>:    call   0x58a0ec00 <_ZnwjN2kj1_12PlacementNewEPv>\n   0x59531516 <+30>:    add    $0x10,%esp\n   0x59531519 <+33>:    mov    %eax,%esi\n   0x5953151b <+35>:    test   %esi,%esi\n   0x5953151d <+37>:    je     0x59531531 <_ZN2kj4ctorIjIjEEEvRT_DpOT0_+57>\n   0x5953151f <+39>:    sub    $0xc,%esp\n   0x59531522 <+42>:    push   0xc(%ebp)\n   0x59531525 <+45>:    call   0x59502e70 <_ZN2kj3fwdIjEEOT_RNS_8NoInfer_IS1_E4TypeE>\n   0x5953152a <+50>:    add    $0x10,%esp\n   0x5953152d <+53>:    mov    (%eax),%eax\n   0x5953152f <+55>:    mov    %eax,(%esi)\n\n1062    }\n   0x59531531 <+57>:    nop\n   0x59531532 <+58>:    lea    -0x8(%ebp),%esp\n   0x59531535 <+61>:    pop    %ebx\n   0x59531536 <+62>:    pop    %esi\n   0x59531537 <+63>:    pop    %ebp\n   0x59531538 <+64>:    ret\nEnd of assembler dump.\n(gdb) disassemble /s _ZnwjN2kj1_12PlacementNewEPv\nDump of assembler code for function _ZnwjN2kj1_12PlacementNewEPv:\n/ci_container_base/depends/i686-pc-linux-gnu/include/kj/common.h:\n1051    inline void* operator new(size_t, kj::_::PlacementNew, void* __p) noexcept {\n   0x58a0ec00 <+0>:     endbr32\n   0x58a0ec04 <+4>:     push   %ebp\n   0x58a0ec05 <+5>:     mov    %esp,%ebp\n   0x58a0ec07 <+7>:     push   %ebx\n   0x58a0ec08 <+8>:     sub    $0x14,%esp\n   0x58a0ec0b <+11>:    call   0x58a0ec10 <_ZnwjN2kj1_12PlacementNewEPv+16>\n   0x58a0ec10 <+16>:    pop    %eax\n   0x58a0ec11 <+17>:    add    $0x1f81958,%eax\n   0x58a0ec17 <+23>:    mov    %eax,-0x14(%ebp)\n   0x58a0ec1a <+26>:    mov    0xc(%ebp),%eax\n   0x58a0ec1d <+29>:    mov    0x8(%ebp),%eax\n   0x58a0ec20 <+32>:    mov    %gs:0x14,%eax\n   0x58a0ec26 <+38>:    mov    %eax,-0x8(%ebp)\n\n1052      return __p;\n   0x58a0ec29 <+41>:    mov    0xc(%ebp),%eax\n   0x58a0ec2c <+44>:    mov    %eax,-0x10(%ebp)\n   0x58a0ec2f <+47>:    mov    %gs:0x14,%eax\n   0x58a0ec35 <+53>:    mov    -0x8(%ebp),%ecx\n   0x58a0ec38 <+56>:    cmp    %ecx,%eax\n   0x58a0ec3a <+58>:    jne    0x58a0ec49 <_ZnwjN2kj1_12PlacementNewEPv+73>\n   0x58a0ec40 <+64>:    mov    -0x10(%ebp),%eax\n   0x58a0ec43 <+67>:    add    $0x14,%esp\n   0x58a0ec46 <+70>:    pop    %ebx\n   0x58a0ec47 <+71>:    pop    %ebp\n   0x58a0ec48 <+72>:    ret\n   0x58a0ec49 <+73>:    mov    -0x14(%ebp),%ebx\n   0x58a0ec4c <+76>:    call   0x56649250 <__stack_chk_fail@plt>\nEnd of assembler dump.\n(gdb) disassemble /s _ZN2kj3fwdIjEEOT_RNS_8NoInfer_IS1_E4TypeE\nDump of assembler code for function _ZN2kj3fwdIjEEOT_RNS_8NoInfer_IS1_E4TypeE:\n/ci_container_base/depends/i686-pc-linux-gnu/include/kj/common.h:\n700     template<typename T> constexpr T&& fwd(NoInfer<T>& t) noexcept { return static_cast<T&&>(t); }\n   0x59502e70 <+0>:     push   %ebp\n   0x59502e71 <+1>:     mov    %esp,%ebp\n   0x59502e73 <+3>:     call   0x584df28a <__x86.get_pc_thunk.ax>\n   0x59502e78 <+8>:     add    $0x148d6f0,%eax\n   0x59502e7d <+13>:    mov    0x8(%ebp),%eax\n   0x59502e80 <+16>:    pop    %ebp\n   0x59502e81 <+17>:    ret\nEnd of assembler dump.\n```\n\n</p>\n</details>\n\nWhen I fed this to chatgpt (https://chatgpt.com/share/67a2aa92-e100-800a-b5b3-999982d1a648) it claimed to find a bug in the dissembly where operator new function is not interpreting its parameters correctly, and I could confirm this with gdb (at least to the best of my understanding, I am not that familiar with assembly and calling conventions). But gdb definitely showed operator new returning the wrong address (source address not destination address), which explained why the destination was not being updated and contained a garbage value.\n\nSo I think there is pretty good evidence that this version of gcc contains a bug with -O0 and is miscompiling the code. Again I'm not sure if we care about this or not. It's an older version of gcc so might be logical to just update it. Or just not compile this code with -O0.\n\n\n",
          "created_at": "2025-02-05T00:04:47Z"
        },
        {
          "user": "maflcko",
          "body": "> This bug seems like it is is probably a compiler bug, but not one is necessarily going to happen reliably because if the unitialized memory location started of as 0 instead 1497966205, crash would not happen. So I'm not sure switching bitcoin compiler from clang to gcc really fixes the problem, or just makes it appear not to happen. And I\"m not sure what I was doing before that caused the problem to disappear as well. It seems like there might be just be a problem with this version of gcc and -O0 and this piece of code.\n> \n> Next steps might be to look at generated assembly and confirm compiler is really producing buggy code or try to reproduce a minimal test case. Another thing we could try to do is update to a new version of gcc. Version here seems to be `gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0`\n\nInteresting. It would be nice to reduce this, if someone wants to spend more time on this. However, I am not familiar with libmp and the build process around it, so if someone manages to produce one (or two) cpp files (even if large) with the corresponding compiler flags, I am happy to take it from there and minimize further.",
          "created_at": "2025-02-05T09:45:20Z"
        },
        {
          "user": "ryanofsky",
          "body": "> Interesting. It would be nice to reduce this\n\nSo I reduced the failure down to a standalone case, but it could be reduced further. Now it is unclear to me if there is a compiler bug here or not, because this is caused by a very specific interaction between the two compiler versions we are using:\n\n- gcc version Ubuntu 13.3.0-6ubuntu2~24.04\n- clang version 18.1.3 (1ubuntu1)\n\nand maybe the specific flags we are using. The bug happens because the linker links together the\n\n- `_ZN2kj4ctorIjIjEEEvRT_DpOT0_` function (`void kj::ctor<unsigned int, unsigned int>(unsigned int&, unsigned int&&)`)\n\ngenerated by GCC in the capnproto static libraries\n\n-  `_ZnwjN2kj1_12PlacementNewEPv` function (`operator new(unsigned int, kj::_::PlacementNew, void*)`)\n\ngenerated by clang in the `libbitcoin_ipc_test.a` library.\n\nThis happens due to linker command line order. The `ipc_test` library comes before the kj static libraries in the command line, but it only contains an `operator new` symbol, not a `ctor` symbol, while kj static libraries contain both symbols. The link will prefer the first symbol definition it sees so it uses the `operator new` from bitcoin together with the `ctor` from libkj and this does not work because gcc `ctor` calls clang `operator new` with a calling convention it is not expecting (as described by chatgpt above).\n\nHere's the reduced test case I have which reproduces the bug with the same code and flags as the CI build:\n\n```c++\ncat > test.h <<EOS\n#include <cstddef>\ntemplate <typename T> struct NoInfer_ { typedef T Type; };\ntemplate <typename T> using NoInfer = typename NoInfer_<T>::Type;\n\ntemplate<typename T> constexpr T&& fwd(NoInfer<T>& t) noexcept { return static_cast<T&&>(t); }\n\nstruct PlacementNew {};\n\nvoid* operator new(size_t, PlacementNew, void* __p) noexcept;\n\ntemplate <typename T, typename... Params>\ninline void ctor(T& location, Params&&... params) {\n  new (PlacementNew(), &location) T(fwd<Params>(params)...);\n}\nEOS\n\ncat > test_gcc.cpp <<EOS\n#include \"test.h\"\ntemplate void ctor<size_t, size_t>(size_t&, size_t&&);\nEOS\n\ncat > test_clang.cpp <<EOS\n#include \"test.h\"\n#include <iostream>\n\nvoid* operator new(size_t, PlacementNew, void* __p) noexcept {\n  return __p;\n}\n\nsize_t f() {\n    size_t i = 10;\n    size_t j = 20;\n    ctor(i, std::move(j));\n    return i;\n}\n\nint main() {\n    std::cout << \"i = \" << f() << std::endl;\n}\nEOS\n\ng++ -m32 -D_GLIBCXX_DEBUG -D_GLIBCXX_DEBUG_PEDANTIC -D_LIBCPP_HARDENING_MODE=_LIBCPP_HARDENING_MODE_DEBUG -pipe -std=c++20 -O0 -g -fPIC -Wall -Wextra -Wno-strict-aliasing -Wno-sign-compare -Wno-unused-parameter -pthread -c test_gcc.cpp -o test_gcc.o\nclang++ -m32 -Wno-error=documentation -O0 -ftrapv -O0 -g3 -g3 -fstack-protector-all -fcf-protection=full -fstack-clash-protection -fPIE -c test_clang.cpp -o test_clang.o\nclang++ -m32 -Wno-error=documentation -O0 -ftrapv -O0 -g3 -g3 -fstack-protector-all -fcf-protection=full -fstack-clash-protection -Wl,-z,relro -Wl,-z,now -Wl,-z,separate-code -fPIE -pie test_gcc.o test_clang.o\n./a.out\n```\n\nIf the test case were compiled properly it would print 20, but due to the calling convention problem here it prints 10, because the line `ctor(i, std::move(j));` is supposed to assign `j` (20) to `i`, but doesn't do that because `operator new` returns a garbage value.\n\nI confirmed that adding `-fabi-version=2` to gcc command line above does not fix the problem (the program still prints 10 instead of 20). But I did not experiment further to see which of the compiler flags we are passing may be causing the incompatibility, or if the flags are irrelevant and gcc and clang just disagree on the calling convention for this `operator new`.\n\nI am not sure if there is a general solution for this problem. If linker order were changed so that kj libraries were always specified first before the bitcoin library, that would prevent crashing inside kj libraries, but then it might cause a similar crash in the bitcoin code.\n\nAll of this suggests that if you are using depends, and you want to change the compiler or pass different flags in bitcoin, you really need to make the same changes in both builds. Mixing different flags and compiler versions might not be a good idea.",
          "created_at": "2025-02-05T18:50:28Z"
        },
        {
          "user": "ryanofsky",
          "body": "Following seem to be minimal flags to reproduce this issue. None of the other flags except for `-fPIC` was making any difference, and without `-fPIC` the program just segfaults instead of printing the wrong value:\n\n```bash\ng++ -m32 -fPIC -c test_gcc.cpp -o test_gcc.o\nclang++ -m32 -fPIC -c test_clang.cpp -o test_clang.o\nclang++ -m32 -fPIC test_gcc.o test_clang.o\n./a.out\n```\n\nSo it seems like this version of gcc and clang just always (regardless of flags) assume incompatible calling conventions for `operator new` and can't be used together here.\n\nFix for the bug should just be to use either clang or gcc for this CI build and not try to use both.",
          "created_at": "2025-02-05T19:06:05Z"
        },
        {
          "user": "ryanofsky",
          "body": "This also seems to be a known issue: \"It has come to my attention that GCC and clang generate incompatible code\nfor passing an argument of an empty class type.\" https://itanium-cxx-abi.github.io/cxx-abi/cxx-abi-dev/archives/2015-December/002869.html",
          "created_at": "2025-02-06T02:31:27Z"
        },
        {
          "user": "maflcko",
          "body": "I wonder if there is a way to detect those at compile or link time. Other than that, printing a warning when mixing two compilers when compiling with depends may be useful? ",
          "created_at": "2025-02-06T08:23:30Z"
        },
        {
          "user": "fanquake",
          "body": "> Other than that, printing a warning when mixing two compilers when compiling with depends may be useful?\n\nWhy only depends though? If the issue is generally mixing compilers/flags, then using Clang + system libs on any (gcc-based) Linux system (potentially) has the same problem. It's currently the case that we use Clang + (GCC built) system libs in at least the ASAN,fuzz,valgrind CIs, and Clang + GCC depends libs in the 32-bit job.",
          "created_at": "2025-02-06T11:41:50Z"
        },
        {
          "user": "ryanofsky",
          "body": "> Why only depends though? If the issue is generally mixing compilers/flags, then using Clang + system libs on any (gcc-based) Linux system (potentially) has the same problem.\n\nYes this issue is not specific to depends, and could theoretically could happen if, for example an ubuntu library package was compiled with gcc and exposed a function with an empty struct parameter, and you tried to use the library with clang. \n\nThe point of having an ABI is to prevent issues like this and allow different compilers to interoperate, but this is a corner case where something hasn't been standardized. Also, in this case, issue goes away if either package is compiled with any optimization (even `-O` is sufficient) because this makes the call to `operator new` inlined. And this issue could also be masked by having a different linker command line order that would cause linker to choose compatible `ctor` and `operator new` symbol definitions instead of incompatible ones.\n\nGiven corner case nature of this problem, I'm thinking it would be good to send a patch to upstream capnproto to avoid the issue by changing parameter order. Following patch seems to fix the issue in our CI job:\n\n```diff\ndiff --git a/depends/packages/capnp.mk b/depends/packages/capnp.mk\nindex 0c211cbc455d..00ccf08acf4b 100644\n--- a/depends/packages/capnp.mk\n+++ b/depends/packages/capnp.mk\n@@ -5,6 +5,12 @@ $(package)_download_file=$(native_$(package)_download_file)\n $(package)_file_name=$(native_$(package)_file_name)\n $(package)_sha256_hash=$(native_$(package)_sha256_hash)\n \n+$(package)_patches = abifix.patch\n+\n+define $(package)_preprocess_cmds\n+  patch -p2 < $($(package)_patch_dir)/abifix.patch\n+endef\n+\n define $(package)_set_vars :=\n   $(package)_config_opts := -DBUILD_TESTING=OFF\n   $(package)_config_opts += -DWITH_OPENSSL=OFF\ndiff --git a/depends/patches/capnp/abifix.patch b/depends/patches/capnp/abifix.patch\nnew file mode 100644\nindex 000000000000..1386aadc7452\n--- /dev/null\n+++ b/depends/patches/capnp/abifix.patch\n@@ -0,0 +1,35 @@\n+diff --git a/c++/src/kj/common.h b/c++/src/kj/common.h\n+index 237c41d3..dc2e6381 100644\n+--- a/c++/src/kj/common.h\n++++ b/c++/src/kj/common.h\n+@@ -1041,24 +1041,26 @@ private:\n+ \n+ // We want placement new, but we don't want to #include <new>.  operator new cannot be defined in\n+ // a namespace, and defining it globally conflicts with the definition in <new>.  So we have to\n+-// define a dummy type and an operator new that uses it.\n++// define a dummy type and an operator new that uses it. The dummy type is intentionally passed\n++// as the last parameter to avoid an ABI issues caused by GCC and clang using incompatible calling\n++// conventions for passing empty struct parameters.\n+ \n+ namespace _ {  // private\n+ struct PlacementNew {};\n+ }  // namespace _ (private)\n+ } // namespace kj\n+ \n+-inline void* operator new(size_t, kj::_::PlacementNew, void* __p) noexcept {\n++inline void* operator new(size_t, void* __p, kj::_::PlacementNew) noexcept {\n+   return __p;\n+ }\n+ \n+-inline void operator delete(void*, kj::_::PlacementNew, void* __p) noexcept {}\n++inline void operator delete(void*, void* __p, kj::_::PlacementNew) noexcept {}\n+ \n+ namespace kj {\n+ \n+ template <typename T, typename... Params>\n+ inline void ctor(T& location, Params&&... params) {\n+-  new (_::PlacementNew(), &location) T(kj::fwd<Params>(params)...);\n++  new (&location, _::PlacementNew()) T(kj::fwd<Params>(params)...);\n+ }\n+ \n+ template <typename T>\n```\n\n",
          "created_at": "2025-02-06T13:37:18Z"
        },
        {
          "user": "ryanofsky",
          "body": "Submitted patch in https://github.com/capnproto/capnproto/pull/2235",
          "created_at": "2025-02-06T14:08:40Z"
        },
        {
          "user": "fanquake",
          "body": "> Submitted patch in https://github.com/capnproto/capnproto/pull/2235\n\nThanks. Pulled that into #29796.",
          "created_at": "2025-02-07T10:23:30Z"
        }
      ]
    },
    {
      "number": 31771,
      "title": "cmake: incorrectly reporting MSVC as using ccache",
      "body": "Mentioned by @stickies-v. The CMake configure currently outputs that MSVC builds are using ccache, i.e (https://github.com/bitcoin/bitcoin/actions/runs/13063954360/job/36452895056#step:8:2374):\n```bash\nTreat compiler warnings as errors ..... ON\nUse ccache for compiling .............. ON\n```\n\nHowever that's a bug, as MSVC is currently excluded entirely from using ccache: \nhttps://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/cmake/ccache.cmake#L4-L6",
      "state": "closed",
      "user": "fanquake",
      "created_at": "2025-01-31T14:35:09Z",
      "updated_at": "2025-03-05T09:54:30Z",
      "comments": 12,
      "url": "https://github.com/bitcoin/bitcoin/issues/31771",
      "labels": [
        "Build system"
      ],
      "comment_list": [
        {
          "user": "vijayabhaskar78",
          "body": "Hey, can I contribute to this issue\n",
          "created_at": "2025-02-02T10:40:28Z"
        },
        {
          "user": "hebasto",
          "body": "@vijayabhaskar78 \n\n> Hey, can I contribute to this issue\n\nSure! No need to ask :)",
          "created_at": "2025-02-02T10:44:51Z"
        },
        {
          "user": "vijayabhaskar78",
          "body": "@hebasto sir Proposing a fix for #31771:\n\n    Set USE_CCACHE=OFF for MSVC in cmake/ccache.cmake.\n    Update status reporting in CMakeLists.txt.\n\nQuestions:\n\n    Does this align with project conventions?\n    Any edge cases (MinGW/cross-compile) to test?",
          "created_at": "2025-02-02T10:59:04Z"
        },
        {
          "user": "purpleKarrot",
          "body": "I don't understand the motivation for setting `CMAKE_<lang>_COMPILER_LAUNCHER` from inside the project. Ideally, the project should not interfere with compiler launchers at all.\n\nThis gives individual users as well as CI instances the highest flexibility.\n\nAssuming I have `ENV{CMAKE_CXX_COMPILER_LAUNCHER}` set locally to use [`sccache`](https://github.com/mozilla/sccache). What is the expected behavior when `cmake/ccache.cmake` invokes `list(APPEND CMAKE_CXX_COMPILER_LAUNCHER ${CCACHE_EXECUTABLE})`? Will it use `sccache`, `ccache`, or both?",
          "created_at": "2025-02-02T18:36:43Z"
        },
        {
          "user": "vijayabhaskar78",
          "body": "@purpleKarrot Should we remove the CMAKE_*_COMPILER_LAUNCHER assignments from ccache.cmake to prioritize user/CI flexibility? This would:\n\n    Avoid conflicts with external launchers like sccache set via ENV{CMAKE_CXX_COMPILER_LAUNCHER}.\n    Follow CMake best practices by letting users control launchers externally.\n    Prevent invalid command chains (e.g., sccache;ccache;cl.exe) when multiple launchers are set.\n\nIf agreed, I can update the PR to delete these lines and add documentation instead",
          "created_at": "2025-02-02T18:53:24Z"
        },
        {
          "user": "vijayabhaskar78",
          "body": "I'm a newbie to this repository. Can you help me to understand it?",
          "created_at": "2025-02-02T18:58:28Z"
        },
        {
          "user": "purpleKarrot",
          "body": "@vijayabhaskar78, I am a newbe in this repository too, but I am not a newbie with CMake ;-)\nMy recommendation would be to remove `cmake/ccache.cmake` for the reason you wrote.\nBut let the original authors of that file chime in.",
          "created_at": "2025-02-02T19:08:37Z"
        },
        {
          "user": "vijayabhaskar78",
          "body": "OK let us see ",
          "created_at": "2025-02-02T19:28:57Z"
        },
        {
          "user": "vijayabhaskar78",
          "body": "@fanquake @hebasto @purpleKarrot  \n\n### **Problem Summary**  \n\n- **False Reporting:** CMake incorrectly reports `ccache` as \"ON\" for MSVC builds despite excluding it in `cmake/ccache.cmake`.  \n- **Launcher Conflicts:** Forced `CMAKE_*_COMPILER_LAUNCHER` assignments override user/CI settings (e.g., `sccache`).  \n\n### **Proposed Fix**  \n\n#### **1. Delete `cmake/ccache.cmake`**  \n\n```bash\nrm cmake/ccache.cmake\n```\n\n- **Why?** Removes forced `ccache` logic conflicting with external launchers.  \n- **Impact:** Users/CI regain full control via `CMAKE_CXX_COMPILER_LAUNCHER`.  \n\n#### **2. Update Status Message**  \n\n```cmake\nif(DEFINED ENV{CMAKE_CXX_COMPILER_LAUNCHER})  \n  message(STATUS \"Compiler launcher .............. $ENV{CMAKE_CXX_COMPILER_LAUNCHER}\")  \nelse()  \n  message(STATUS \"Use ccache for compiling .............. NO\")  \nendif()\n```\n\n- **Result:** Accurately reflects whether a launcher (e.g., `ccache`) is active.  \n\n#### **3. Document MSVC + `ccache` Workflow**  \n\nAdd to `doc/build-windows.md`:  \n\n\n### **Caching MSVC Builds**  \n- **Step 1**: Use Ninja:  \n  ```sh\n  -G \"Ninja\"\n  ```\n- **Step 2**: Configure launcher:  \n  ```sh\n  cmake -B build -DCMAKE_CXX_COMPILER_LAUNCHER=ccache\n  ```\n- **Step 3**: Use `/Z7` (not `/Zi`) for debug flags.  \n\n\n### **Why This Approach?**  \n\n- **Flexibility:** No forced `ccache`/generator logic. Users/CI control launchers via CMake/env vars.  \n- **CMake Compliance:** Follows [CMake best practices](https://cmake.org/cmake/help/latest/envvar/CMAKE_LANG_COMPILER_LAUNCHER.html).  \n- **Simplification:** Deletes 50+ lines of error-prone code.  \n\n### **Feedback Requested**  \n\n- @purpleKarrot: Does this address your concerns about launcher flexibility?  \n- Maintainers (@fanquake, @hebasto): Any objections to deleting `ccache.cmake`?  \n\n",
          "created_at": "2025-02-03T12:03:22Z"
        },
        {
          "user": "s373nZ",
          "body": "> I don't understand the motivation for setting `CMAKE_<lang>_COMPILER_LAUNCHER` from inside the project.\n\nI'm also ignorantly curious about this. Is it primarily a requirement from the feature parity list with the prior `autotools`?\n\nhttps://gist.github.com/hebasto/2ef97d3a726bfce08ded9df07f7dab5e\n",
          "created_at": "2025-02-18T20:51:41Z"
        },
        {
          "user": "maflcko",
          "body": "Is the msvc configure summary a blocker for the release? I've removed the milestone from https://github.com/bitcoin/bitcoin/pull/30861 because it looks more like an involved feature than a bugfix, so maybe it can be removed here as well?",
          "created_at": "2025-02-25T15:01:08Z"
        },
        {
          "user": "fanquake",
          "body": "I've opened #31983 to deal with this for now.",
          "created_at": "2025-03-04T11:48:18Z"
        }
      ]
    },
    {
      "number": 31770,
      "title": "fuzz: oss-fuzz coverage build is failing",
      "body": "It first failed on the 25th (https://oss-fuzz-build-logs.storage.googleapis.com/log-7da28be4-dcf5-4e23-a6ca-153f67ad2f60.txt):\n```bash\nStep #7: \u001b[0m\u001b[0;31mwarning: The file '/usr/evmap.c' isn't covered.\nStep #7: \u001b[0m\u001b[0;31merror: /workspace/out/libfuzzer-coverage-x86_64/usr/arc4random.c: No such file or directory\nStep #7: \u001b[0m\u001b[0;31mwarning: The file '/usr/arc4random.c' isn't covered.\nStep #7: \u001b[0m\u001b[0;31merror: /workspace/out/libfuzzer-coverage-x86_64/usr/buffer.c: No such file or directory\nStep #7: \u001b[0m\u001b[0;31mwarning: The file '/usr/buffer.c' isn't covered.\nStep #7: \u001b[0m\u001b[0;31merror: /workspace/out/libfuzzer-coverage-x86_64/usr/util-internal.h: No such file or directory\nStep #7: \u001b[0m\u001b[0;31mwarning: The file '/usr/util-internal.h' isn't covered.\nStep #7: \u001b[0m[2025-01-31 07:01:44,276 DEBUG] Finished generating per-file code coverage summary.\nStep #7: [2025-01-31 07:01:44,277 DEBUG] Generating file view html index file as: \"/workspace/out/libfuzzer-coverage-x86_64/report/linux/file_view_index.html\".\nStep #7: Traceback (most recent call last):\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 829, in <module>\nStep #7:     sys.exit(Main())\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 823, in Main\nStep #7:     return _CmdPostProcess(args)\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 780, in _CmdPostProcess\nStep #7:     processor.PrepareHtmlReport()\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 577, in PrepareHtmlReport\nStep #7:     self.GenerateFileViewHtmlIndexFile(per_file_coverage_summary,\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 450, in GenerateFileViewHtmlIndexFile\nStep #7:     self.GetCoverageHtmlReportPathForFile(file_path),\nStep #7:   File \"/opt/code_coverage/coverage_utils.py\", line 422, in GetCoverageHtmlReportPathForFile\nStep #7:     assert os.path.isfile(\nStep #7: AssertionError: \"/usr/arc4random.c\" is not a file.\nStep #7: ********************************************************************************\nStep #7: Code coverage report generation failed.\nStep #7: To reproduce, run:\nStep #7: python infra/helper.py build_image bitcoin-core\nStep #7: python infra/helper.py build_fuzzers --sanitizer coverage bitcoin-core\nStep #7: python infra/helper.py coverage bitcoin-core\nStep #7: ********************************************************************************\nFinished Step #7\nERROR\nERROR: build step 7 \"gcr.io/oss-fuzz-base/base-runner\" failed: step exited with non-zero status: 1\n```\n\nSee also: https://issues.oss-fuzz.com/issues/391974928.",
      "state": "closed",
      "user": "fanquake",
      "created_at": "2025-01-31T13:33:00Z",
      "updated_at": "2025-02-07T11:09:59Z",
      "comments": 2,
      "url": "https://github.com/bitcoin/bitcoin/issues/31770",
      "labels": [],
      "comment_list": [
        {
          "user": "davidgumberg",
          "body": "Bisected to https://github.com/bitcoin/bitcoin/commit/5691fa93c48c5b2c767f19aad5e972e4d760414a (#31661),\n\nCan reproduce doing something like:\n\n```bash\n# setup \ngit clone --depth 1 https://github.com/google/oss-fuzz.git\ngit clone https://github.com/bitcoin/bitcoin oss-fuzz/bitcoin\ngit clone --depth 1 https://github.com/bitcoin-core/qa-assets oss-fuzz/bitcoin/assets\ncd oss-fuzz\npython infra/helper.py build_image bitcoin-core\n\n# check out a commit hash for the local copy\nBAD_COMMIT=5691fa93c4\nGOOD_COMMIT=8fc7140846\ncd bitcoin && git checkout $BAD_COMMIT && cd ..\n\npython infra/helper.py build_fuzzers --sanitizer coverage bitcoin-core bitcoin/\npython infra/helper.py coverage bitcoin-core --fuzz-target psbt\n```\n\nProbably related to using `-ffile-prefix-map` (https://github.com/bitcoin/bitcoin/pull/31661#discussion_r1923896475)",
          "created_at": "2025-02-01T03:30:34Z"
        },
        {
          "user": "hebasto",
          "body": "A fix has been proposed in https://github.com/bitcoin/bitcoin/pull/31800.",
          "created_at": "2025-02-05T14:57:24Z"
        }
      ]
    },
    {
      "number": 31769,
      "title": "incrementalrelayfee configuration option should be present in bitcoin.conf",
      "body": "### Please describe the feature you'd like to see added.\n\n... just like minrelaytxfee and others. Ideally, bitcoin.conf should encompass all configuration options.\n\n### Is your feature related to a problem, if so please describe it.\n\nAs a user, I would like to specify value of the incrementalrelayfee configuration option in bitcoin.conf file so that I don't have to type it in a command line each time I start bitcoind.\n\nIn Bitcoin 28.1, the option is hidden, i.e. there isn't any description of the option shown in --help.\n\n### Describe the solution you'd like\n\n_No response_\n\n### Describe any alternatives you've considered\n\n_No response_\n\n### Please leave any additional context\n\n_No response_",
      "state": "closed",
      "user": "GregTonoski",
      "created_at": "2025-01-31T12:47:47Z",
      "updated_at": "2025-01-31T15:01:09Z",
      "comments": 1,
      "url": "https://github.com/bitcoin/bitcoin/issues/31769",
      "labels": [
        "Feature"
      ],
      "comment_list": [
        {
          "user": "achow101",
          "body": "All command line options, hidden or not, can be set in the bitcoin.conf.\n\nThe help for incrementalrelayfee can be seen if `-help-debug` is additionally passed.",
          "created_at": "2025-01-31T15:01:07Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 1,
    "issues": 4
  }
}