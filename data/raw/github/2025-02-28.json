{
  "source": "github",
  "repository": "bitcoin/bitcoin",
  "fetched_at": "2026-01-15T20:15:53.457853+00:00",
  "date": "2025-02-28",
  "pull_requests": [
    {
      "number": 31966,
      "title": "tests: Improve stderr validation in test_runner.py",
      "body": "This PR implements the improvement suggested in a TODO comment in test/util/test_runner.py. \r\nIt adds validation that stderr is empty when no errors are expected in test cases.\r\n\r\nThe change adds a check that verifies stderr is empty when no error_txt is specified in \r\nthe test object, with a special exception for bitcoin-tx running under Wine, which was \r\nmentioned in the original TODO comment.\r\n\r\nThis improvement helps catch unexpected error messages that might otherwise go unnoticed \r\nduring testing, making the test framework more robust.\r\n\r\nThe implementation:\r\n1. Checks if stderr contains output when no error is expected\r\n2. Makes an exception for the known case of bitcoin-tx running under Wine\r\n3. Raises an exception with a detailed error message if unexpected stderr output is found\r\n\r\nThis change improves test coverage by ensuring that tests don't silently pass when they \r\nproduce unexpected error output.",
      "state": "closed",
      "user": "GarmashAlex",
      "created_at": "2025-02-28T20:25:55Z",
      "updated_at": "2025-04-28T13:47:42Z",
      "comments": 6,
      "url": "https://github.com/bitcoin/bitcoin/pull/31966",
      "labels": [
        "Tests"
      ],
      "comment_list": [
        {
          "user": "DrahtBot",
          "body": "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--006a51241073e994b41acfe9ec718e94-->\n### Code Coverage & Benchmarks\nFor details see: https://corecheck.dev/bitcoin/bitcoin/pulls/31966.\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\nA summary of reviews will appear here.\n",
          "created_at": "2025-02-28T20:25:57Z"
        },
        {
          "user": "yancyribbens",
          "body": "Is there any reason the `TODO` was not removed on L159 with this commit?",
          "created_at": "2025-03-10T15:19:33Z"
        },
        {
          "user": "GarmashAlex",
          "body": "@yancyribbens Sorry, my bad. I removed TODO",
          "created_at": "2025-03-11T17:28:17Z"
        },
        {
          "user": "fanquake",
          "body": "> Sorry, my bad. I removed TODO\r\n\r\nYou partially removed it?  You should also read https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#committing-patches in regards to fixing your commits messages & fixing your commits.",
          "created_at": "2025-03-12T01:27:56Z"
        },
        {
          "user": "maflcko",
          "body": "Please squash your commits according to https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#squashing-commits",
          "created_at": "2025-03-12T08:15:41Z"
        },
        {
          "user": "GarmashAlex",
          "body": "@maflcko could i just create a new PR instead of this one . I don't know how to squash commits",
          "created_at": "2025-03-13T16:57:23Z"
        }
      ]
    }
  ],
  "issues": [
    {
      "number": 31965,
      "title": "Revisiting us self-hosting parts of our CI",
      "body": "The project currently self-hosts the runners for ~half of our CI jobs. The other half of the CI jobs run on GitHub Actions hosted by GitHub. In an offline discussion, the question came up if we should move the self-hosted runners to some other non-self-hosted infrastructure or if there are other ways to improve on the following areas:\n\n- reduce infrastructure maintenance burden: someone has to take care of the servers, but that's (normally) not too much work. Shouldn't be a single person maintaining it to reduce the bus-factor and single point of failures. \n- increase performance: generally faster CI is welcome, maybe solvable with more CPU, but also related to https://github.com/bitcoin/bitcoin/issues/30852 - not clear yet what exactly is targeted - and performance could be improved with self-hosted CI too - no need to go non-self-hosted for this alone.\n- increase security/robustness: generally, running public jobs CI on self-hosted hardware is a security risk and [not recommended](https://docs.github.com/en/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners#self-hosted-runner-security) - making it (more) secure is possible, but probably a lot of work that we might want to outsource to e.g. a company that specializes on it\n\nCurrently, the self-hosted CI has implicit caches for docker images, ccache, depends (sources and built). Caching would need to be implemented on non-selfhosted runners too. Some more discussion about the implicit caches is [here](https://github.com/bitcoin/bitcoin/issues/30852#issuecomment-2558198430).\n\nSome mentioned ideas, but there are probably more approaches worth exploring:\n- Github Actions: move all jobs to GitHub actions. GitHub cache is limited to 10GB, which is too small. PR authors can't rerun PRs. Even more dependency on GitHub/Microsoft, but we already have half of the jobs there.  \nSee also [#30304 ci: Move more tasks to GHA?](https://github.com/bitcoin/bitcoin/issues/30304).\n- runson.com: would need to move the cirrus jobs to GitHub Actions format. Allows to use a way bigger cache, potentially cheaper than GitHub actions?\n- [actions-runner-controller](https://github.com/actions/actions-runner-controller): bring our own machines for a kubernetes cluster, or rent pods on demand and let the controller spin up things for new jobs. In theory, helps with performance and probably with security. Would need to move from Cirrus to GitHub Actions.\n- [Cirrus-CI on Cloud machines](https://cirrus-ci.org/guide/supported-computing-services/): use cloud machines and keep Cirrus. Needs us to figure out caching.\n- [bitcoin-core-cirrus-runner](https://github.com/0xB10C/bitcoin-core-cirrus-runner): is a experimental NixOS module that runs jobs in a isolated, ephemeral, and minimal QEMU VM. Would still be self-hosted CI, does address some of the security concerns about the current CI, not production ready yet, and probably a more complex solutions that wound't reduce maintenance burden in the long run.\n- Keep status status quo: use self-hosted, persistent, but potentially insecure Cirrus runners - \"if it ain't broken, don't fix it\"",
      "state": "closed",
      "user": "0xB10C",
      "created_at": "2025-02-28T16:42:02Z",
      "updated_at": "2025-10-16T07:34:24Z",
      "comments": 22,
      "url": "https://github.com/bitcoin/bitcoin/issues/31965",
      "labels": [
        "Tests"
      ]
    },
    {
      "number": 31964,
      "title": "Ability to build the library",
      "body": "### Please describe the feature you'd like to see added.\n\nIs it possible t build the library so it can be used by external applications as well?\n\nI would like to be able to build the project, do `make install` and then have the headers and libs in `/usr/local/include` and `/usr/local/lib`\n\n### Is your feature related to a problem, if so please describe it.\n\n_No response_\n\n### Describe the solution you'd like\n\n_No response_\n\n### Describe any alternatives you've considered\n\n_No response_\n\n### Please leave any additional context\n\n_No response_",
      "state": "closed",
      "user": "placintaalexandru",
      "created_at": "2025-02-28T15:02:50Z",
      "updated_at": "2025-07-15T17:00:05Z",
      "comments": 9,
      "url": "https://github.com/bitcoin/bitcoin/issues/31964",
      "labels": [
        "Questions and Help"
      ],
      "comment_list": [
        {
          "user": "pinheadmz",
          "body": "First of all we have migrated to `cmake` instead of `make install` ;-)\n\nBitcoin Core does not plan on exposing a shared library, this is an old discussion: https://github.com/bitcoin/bitcoin/pull/5084",
          "created_at": "2025-02-28T15:06:24Z"
        },
        {
          "user": "purpleKarrot",
          "body": "> First of all we have migrated to `cmake` instead of `make install` ;-)\n\nThis is not an argument. CMake's \"Unix Makefiles\" generator does generate an `install` target, as [documented here](https://cmake.org/cmake/help/latest/generator/Unix%20Makefiles.html).\n\nExecuting `make install` in the build directory installs executables and manpages, no headers and no libraries.",
          "created_at": "2025-02-28T15:19:34Z"
        },
        {
          "user": "placintaalexandru",
          "body": "Yes, I saw the transition to cmake. My question is more about the ability to build project as a library so other projects can link against it",
          "created_at": "2025-02-28T15:21:00Z"
        },
        {
          "user": "purpleKarrot",
          "body": "When `BUILD_KERNEL_LIB` is set to ON, a `libbitcoinkernel.so` is installed together with a `libbitcoinkernel.pc` for pgkconfig. But no header files. Also no CMake config files.",
          "created_at": "2025-02-28T15:25:25Z"
        },
        {
          "user": "placintaalexandru",
          "body": "unfortunately I need libbitcoin_consensus and some headers from that lib",
          "created_at": "2025-02-28T15:41:33Z"
        },
        {
          "user": "pinheadmz",
          "body": "> unfortunately I need libbitcoin_consensus and some headers from that lib\n\nCan you explain a bit more what you are working on?",
          "created_at": "2025-02-28T16:00:41Z"
        },
        {
          "user": "fanquake",
          "body": "I think what you want is #30595?",
          "created_at": "2025-03-04T18:29:51Z"
        },
        {
          "user": "placintaalexandru",
          "body": "Yes, I want to be able to build (selectively of possible) the libs used by the project and be able to get the header files as well",
          "created_at": "2025-03-04T18:36:18Z"
        },
        {
          "user": "fanquake",
          "body": "Closing this in favour of #27587 & #30595. Those are the threads to follow for progress on this.",
          "created_at": "2025-07-15T17:00:05Z"
        }
      ]
    },
    {
      "number": 31962,
      "title": "compact blocks in IBD resets m_stalling_since",
      "body": "During IBD it is possible that a malicious peer sends unsolicited compact-block messages to reset its `m_stalling_since` state. This requires two or more malicious peer connections and can happen with the following steps:\n- Malicious peer A sends a headers message that contains height `h+1`. The node requests block `h+1` from peer A.\n- Malicious peer B sends a headers message that contains heights `{h+1, h+2, ..., h+1024}`. The node requests `MAX_BLOCKS_IN_TRANSIT_PER_PEER` blocks from B. Peer B does not need to reply with any of these blocks.\n- Honest peer C sends a headers message that contains heights `{h+1, h+2, ..., h+1024}`. The node will request blocks continuing from where it last requested from peer B.\n- Peer A sends a compact-block for `h+2` with non-empty but bogus `shorttxids`.\n  - The target node will attempt to process the compact-block since it is within two blocks of `h`. The `CanDirectFetch` logic is also skipped [here](https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L4386-L4389) as the block is already in-flight with peer B.\n  - Since the `shorttxids` field is bogus, execution hits [this branch](https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L4449-L4450) and calls `RemoveBlockRequest`. This will reset `m_stalling_since` even though peer A hasn't actually provided a block.\n  - This can be repeated by peer A to reset `m_stalling_since` before [the timeout triggers](https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L5789-L5801). The peer should eventually be disconnected (unless it gives the block) after the larger block download timeout of ~10minutes+ depending on the number of downloading peers which could be numerous in IBD.\n\nI think this scenario is a bit contrived since it requires two (or more?) malicious peers whom are requested subsequent blocks, but it illustrates that:\n- resetting `m_stalling_since` in this case is a bug\n- compact-blocks can be received unsolicited even in IBD.  The block must be currently in-flight and must be one of the two blocks above the target node's tip.\n\nHere is a branch that demonstrates this with a functional test: https://github.com/Crypt-iQ/bitcoin/tree/ibd_cmpct",
      "state": "open",
      "user": "Crypt-iQ",
      "created_at": "2025-02-28T01:53:55Z",
      "updated_at": "2025-10-03T11:36:29Z",
      "comments": 5,
      "url": "https://github.com/bitcoin/bitcoin/issues/31962",
      "labels": [
        "P2P"
      ],
      "comment_list": [
        {
          "user": "mzumsande",
          "body": "I don't think this would work with blocks below the minchainwork threshold, we should abort [here](https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L4309) - \nso large parts of IBD shouldn't be affected. We will still be in IBD for a while after reaching that threshold though, depending on how up-to-date the bitcoind release is.\n\nAlso, the node schedules the blocks it downloads during IBD not as an answer to received headers messages, but on its own initiative in [SendMessages](https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L5867).  So it shouldn't be possible to trigger this by sending header messages, but the two attacking peers could be be randomly selected next to each other. \n\nGuessing that this could be connected to #27626 (fyi @instagibbs) because before we shouldn't have processed a `CMPCTBLOCK` for a block that was already in flight?!\n\nAs for a fix, I wonder Is there a reason to have https://github.com/bitcoin/bitcoin/blob/3c1f72a36700271c7c1293383549c3be29f28edb/src/net_processing.cpp#L4386-L4389 dependent on `already_in_flight` - could we unconditionally skip out here if `CanDirectFetch()` returns false? At least removing the condition doesn't break any existing tests.",
          "created_at": "2025-03-03T20:47:19Z"
        },
        {
          "user": "Crypt-iQ",
          "body": "Ah, I did not consider the minchainwork.\n\n> So it shouldn't be possible to trigger this by sending header messages, but the two attacking peers could be be randomly selected next to each other.\n\nI could have made that more clear in the description that the attacker needed two peers to be selected in sequence for the `SendMessages` call. That's what I meant by \"subsequent\" but I think it was unclear.\n\n> dependent on already_in_flight - could we unconditionally skip out here if CanDirectFetch() returns false? At least removing the condition doesn't break any existing tests.\n\nThat was what I was thinking, I can't see a current use for the `!already_in_flight` check.",
          "created_at": "2025-03-03T21:46:41Z"
        },
        {
          "user": "instagibbs",
          "body": "That code block appears to be in since the dawn of compact blocks: https://github.com/bitcoin/bitcoin/commit/d25cd3ec4e8#diff-34d21af3c614ea3cee120df276c9c4ae95053830d7f1d3deaf009a4625409ad2R5312\n\nI might be missing something of course.\n\n> At least removing the condition doesn't break any existing tests.\n\nNot very comforting :) ",
          "created_at": "2025-03-03T21:57:20Z"
        },
        {
          "user": "Crypt-iQ",
          "body": "I am (still) curious why the `!already_in_flight && !CanDirectFetch()` conditional was introduced and I wasn't able to find an explanation in https://github.com/bitcoin/bitcoin/pull/8068 (because I don't understand it, I'm not advocating for changing it). The check to see if we've requested the block doesn't distinguish between if we requested it with `MSG_CMPCT_BLOCK` or `MSG_BLOCK` in the GETDATA. It also doesn't tell us if we requested the block from the peer sending the compact block. \n\nThere are three places in the original PR (excluding full block fallback in compact block logic) where we'd request full blocks or compact blocks:\n- in response to a HEADERS [here](https://github.com/bitcoin/bitcoin/blob/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/src/main.cpp#L5534) (now `HeadersDirectFetchBlocks`, full blocks or compact blocks)\n- in response to an INV [here](https://github.com/bitcoin/bitcoin/blob/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/src/main.cpp#L4944) (now removed, full blocks or compact blocks)\n- `FindNextBlocksToDownload` (introduced in https://github.com/bitcoin/bitcoin/pull/4468 and referred to as parallel block download, full blocks only)\n\nThe first two cases call `CanDirectFetch` and if the peer supports compact blocks, we would request a compact block. The HEADERS case has an additional caveat that this be the only block in flight and the only block we'd request from the HEADERS message. Since we're requesting the block in here _and_ we've checked `CanDirectFetch`, I think this is unrelated to the conditional. If we hypothetically removed the already_in_flight check, since we've checked `CanDirectFetch` before request, we should still be able to process the compact block _if_ we are close to tip (i.e. not almost 20 blocks away and our peer responds quickly).\n\nIn the original PR, there is only one place where an unsolicited compact block would be sent: when we have only one block to announce and the peer requested hb mode [here](https://github.com/bitcoin/bitcoin/blob/d25cd3ec4e8961c5f36c29a65395f52d0db294c5/src/main.cpp#L6153). This is now in the `SendMessages` loop and still exists. An additional place was added in https://github.com/bitcoin/bitcoin/pull/9375 when `NewPoWValidBlock` was introduced. It then seems to me that the conditional is a belt-and-suspenders check to fallback to full block download if we've somehow fallen behind.\n\n~~If the `already_in_flight` check was removed (which, again, I'm not advocating for), the block download state would need to also be wiped so that fallback to parallel block download could still work. Otherwise, the block would not be requested in `SendMessages` as it's already in flight!~~\n\nLastly, the `CanDirectFetch` check is interesting. It will fail if our tip time is not within 3h20m of our local clock. It seems to me that if miners consistently created blocks with the lowest possible nTime that MTP would allow, they may be able to cause compact blocks to not be processed network-wide (because both requesting compact blocks relies on `CanDirectFetch`, and processing unrequested compact blocks relies on `CanDirectFetch`). I'm not sure if this is rational for them to do.",
          "created_at": "2025-10-01T14:30:47Z"
        },
        {
          "user": "instagibbs",
          "body": "> Lastly, the CanDirectFetch check is interesting. It will fail if our tip time is not within 3h20m of our local clock.\n\nYeah this is a known weirdness @dergoegge . I don't think there's any real motivation to do it, defectors can \"reset\" the MTP forward IIUC. Extremely rare blocks or a big drop in hashing could cause it, but in the latter case lower block rate also makes races less likely.\n\nI'll spend some time next week hopefully trying to mentally tackle this.",
          "created_at": "2025-10-03T11:36:29Z"
        }
      ]
    }
  ],
  "summary": {
    "pull_requests": 1,
    "issues": 3
  }
}